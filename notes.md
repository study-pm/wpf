# WPF

- [Введение в WPF](#введение-в-wpf)
  - [Особенности платформы WPF](#особенности-платформы-wpf)
    - [Преимущества WPF](#преимущества-wpf)
    - [Структура проекта WPF](#структура-проекта-wpf)
- [XAML](#xaml)
  - [Введение в язык XAML](#введение-в-язык-xaml)
    - [Структура XAML](#структура-xaml)
    - [Пространства имен XAML](#пространства-имен-xaml)
    - [Элементы и их атрибуты](#элементы-и-их-атрибуты)
    - [Специальные символы](#специальные-символы)
  - [Файлы отделенного кода](#файлы-отделенного-кода)
    - [Взаимодействие кода C# и XAML](#взаимодействие-кода-c-и-xaml)
    - [Создание элементов в коде C#](#создание-элементов-в-коде-c)
  - [Сложные свойства и конвертеры типов](#сложные-свойства-и-конвертеры-типов)
  - [Пространства имен из C# в XAML](#пространства-имен-из-c-в-xaml)

## Введение в WPF

### Особенности платформы WPF
Технология WPF (Windows Presentation Foundation) является часть экосистемы платформы .NET и представляет собой подсистему для построения графических интерфейсов.

Если при создании традиционных приложений на основе WinForms за отрисовку элементов управления и графики отвечали такие части ОС Windows, как User32 и GDI+, то приложения WPF основаны на DirectX. В этом состоит ключевая особенность рендеринга графики в WPF: используя WPF, значительная часть работы по отрисовке графики, как простейших кнопочек, так и сложных 3D-моделей, ложится на графический процессор на видеокарте, что также позволяет воспользоваться аппаратным ускорением графики.

Одной из важных особенностей является использование языка декларативной разметки интерфейса XAML, основанного на XML: вы можете создавать насыщенный графический интерфейс, используя или декларативное объявление интерфейса, или код на управляемых языках C#, VB.NET и F#, либо совмещать и то, и другое.

Первая версия — WPF 3.0 вышла вместе с .NET Framework 3.0 и операционной системой Windows Vista в 2006 году. И с тех пор платформа WPF является частью экосистемы .NET и развивается вместе с фреймворком .NET. Например, на сегодняшний день последней версией фреймворка .NET является .NET 8, и WPF полностью поддерживается этой версией фреймворка.

#### Преимущества WPF
Что вам, как разработчику, предлагает WPF?

- Использование традиционных языков .NET-платформы — C#, F# и VB.NET для создания логики приложения.

- Возможность **декларативного определения** графического интерфейса с помощью специального языка разметки XAML, основанном на xml и представляющем альтернативу программному созданию графики и элементов управления, а также возможность комбинировать XAML и C#/VB.NET

- **Независимость от разрешения экрана**: поскольку в WPF все элементы измеряются в независимых от устройства единицах, приложения на WPF легко масштабируются под разные экраны с разным разрешением.

- Новые возможности, которых сложно было достичь в WinForms, например, создание трехмерных моделей, привязка данных, использование таких элементов, как стили, шаблоны, темы и др.

- Хорошее **взаимодействие с WinForms**, благодаря чему, например, в приложениях WPF можно использовать традиционные элементы управления из WinForms.

- **Богатые возможности** по созданию различных приложений: это и мультимедиа, и двухмерная и трехмерная графика, и богатый набор встроенных элементов управления, а также возможность самим создавать новые элементы, создание анимаций, привязка данных, стили, шаблоны, темы и многое другое

- **Аппаратное ускорение графики** — вне зависимости от того, работаете ли вы с 2D или 3D, графикой или текстом, все компоненты приложения транслируются в объекты, понятные Direct3D, и затем визуализируются с помощью процессора на видеокарте, что повышает производительность, делает графику более плавной.

- Создание приложений под множество ОС семейства Windows

В тоже время WPF имеет определенные ограничения. Несмотря на поддержку трехмерной визуализации, для создания приложений с большим количеством трехмерных изображений, прежде всего игр, лучше использовать другие средства — DirectX или специальные фреймворки, такие как Monogame или Unity.

Также стоит учитывать, что по сравнению с приложениями на Windows Forms объем программ на WPF и потребление ими памяти в процессе работы в среднем несколько выше. Но это с лихвой компенсируется более широкими графическими возможностями и повышенной производительностью при отрисовке графики.

Кроме того, несмотря на то, что WPF работает поверх кроссплатформенной среды .NET, но в силу природы WPF и зависимости от компонентов Windows, на данный момент создавать приложения на WPF можно только под ОС Windows.

#### Структура проекта WPF
Рассмотрим базовую структуру простейшего стандартного проекта WPF:

*[XML]: Extensible Markup Language (XML)
- *App.config*: файл конфигурации приложения в формате XML, позволяет настроить способ обнаружения и загрузки файлов сборок в среде CLR.

- ***App.xaml*** задает ресурсы приложения и ряд конфигурационных настроек в виде кода XAML. В частности, в файле ***App.xaml*** задается файл окна программы, которое будет открываться при запуске приложения. Если вы откроете этот файл, то можете найти в нем строку **`StartupUri="MainWindow.xaml`** — то есть в данном случае, когда мы запустим приложение, будет создаваться интерфейс из файла ***MainWindow.xaml***.

- ***App.xaml.cs*** — это файл кода на C#, связанный с файлом ***App.xaml***, который также позволяет задать ряд общих ресурсов и общую логику для приложения, но в вид кода C#.

- ***MainWindow.xaml*** представляет визуальный интерфейс окна приложения в виде кода XAML.

- ***MainWindow.xaml.cs*** — это файл логики кода на C#, связанный с окном ***MainWindow.xaml***.

Каталог *Properties*:

- ***AssemblyInfo.cs*** содержит информацию о создаваемой в процессе компиляции сборке.
- *Resources.resx* служит для управления локализованными ресурсами, такими как строки, изображения и другие объекты, которые могут изменяться в зависимости от языка и культуры пользователя. Он является ключевым элементом для создания многоязычных приложений на WPF, обеспечивая гибкость и удобство при работе с локализованными данными.
- *Resources.Designer.cs* автоматически генерируется на основе файла ресурсов *Resources.resx* и служит для упрощения доступа к ресурсам, таким как строки, изображения и другие данные, определенные в .resx файле.
- *Settings.settings* спользуется для хранения настроек приложения, которые могут быть изменены пользователем или программой. Эти настройки позволяют сохранять различные параметры, такие как размеры окна, цвет фона и другие предпочтения, которые должны сохраняться между запусками приложения.
- *Settings.Designer.cs* автоматически генерируется на основе файла настроек *Settings.settings* и служит для упрощения доступа к определенным настройкам приложения. Он содержит сгенерированный код, который позволяет разработчикам легко взаимодействовать с настройками, используя статические свойства.

Объект *References*: используется для управления зависимостями проекта от внешних библиотек и компонентов. Он позволяет разработчику подключать необходимые сборки, которые содержат классы и методы, используемые в приложении.
- **Подключение внешних библиотек**: Объект *References* позволяет добавлять ссылки на внешние библиотеки (например, DLL-файлы), которые могут содержать функциональность, необходимую для работы приложения. Это может включать как сторонние библиотеки, так и другие проекты в решении.

- **Управление зависимостями**: Ссылки создают зависимости между проектами, что позволяет Visual Studio автоматически отслеживать изменения в подключенных библиотеках. Если библиотека изменяется, проект, который на нее ссылается, будет пересобран при следующем запуске сборки.

- **Упрощение разработки**: Благодаря объекту *References* разработчики могут легко использовать классы и методы из подключенных библиотек без необходимости копировать код или вручную управлять путями к файлам.

- **Поддержка различных типов ссылок**: В зависимости от требований проекта можно добавлять ссылки на проекты в решении, на файлы DLL или на общие проекты, что обеспечивает гибкость в организации кода.

Таким образом, объект *References* является ключевым элементом для управления зависимостями и интеграции внешней функциональности в WPF-приложениях, что значительно упрощает процесс разработки.

*References* является частью структуры проекта, управляемой Visual Studio, и не представляет собой отдельный физический файл или папку в файловой системе.

Причины отсутствия объекта *References* в файловом менеджере:
- **Логическая структура проекта**: Объект *References* отображается в Обозревателе решений как логическая группа зависимостей, а не как физическая папка или файл. Это означает, что он не будет виден в файловом менеджере, так как не существует отдельного файла для него.

- **Управление через Visual Studio**: Все ссылки и зависимости управляются через интерфейс Visual Studio. Они хранятся в файле проекта (*.csproj* или *.vbproj*), и при необходимости могут быть добавлены или удалены через диспетчер ссылок.

- **Скрытые файлы**: В некоторых случаях файлы проекта могут быть скрытыми или не отображаться в стандартном файловом менеджере. Например, файлы с расширением *.user* могут быть скрыты по умолчанию.

- ***Task_01.csproj***: стандартный файл проекта C#, который соответствует названию проекта (по умолчанию названию каталога) и описывает все его настройки. Является конфигурационным файлом, который описывает все аспекты проекта, необходимые для его сборки и управления. Он содержит информацию о настройках проекта, зависимостях, ресурсах и других параметрах, которые используются системой сборки MSBuild.

Основные назначения файла *.csproj*:
- **Определение структуры проекта**: Файл *.csproj* описывает, какие файлы и папки входят в проект, включая исходные файлы, ресурсы и зависимости. Это позволяет MSBuild знать, что необходимо собрать и как организовать выходные данные.

- **Настройка параметров сборки**: Внутри файла определяются различные параметры, такие как целевая платформа (.NET Framework или .NET Core), тип выходного файла (например, WinExe для приложений с графическим интерфейсом) и другие настройки, влияющие на процесс сборки.

- **Управление зависимостями**: Файл *.csproj* позволяет добавлять ссылки на внешние библиотеки и пакеты NuGet. Это упрощает управление зависимостями и обновлениями, так как все необходимые компоненты могут быть указаны в одном месте.

- **Поддержка локализации и ресурсов**: В файле можно определить ресурсы приложения (например, файлы XAML), которые будут использоваться в интерфейсе. Это позволяет организовать локализацию и управление ресурсами более эффективно.

- **Интеграция с Visual Studio**: Файл *.csproj* используется Visual Studio для управления проектом. Все изменения, внесенные через интерфейс (например, добавление файлов или зависимостей), автоматически отражаются в этом файле.

Таким образом, файл *.csproj* является ключевым элементом для управления проектом WPF, обеспечивая структурированное описание всех его компонентов и настроек.

- ***Task_01.csproj.user***: является дополнительным конфигурационным файлом, который хранит настройки, специфичные для текущего пользователя (такие, как настройки рабочего пространства/workspace, например, `showAllFiles`). Этот файл создается автоматически Visual Studio и используется для сохранения индивидуальных параметров, которые не должны влиять на другие копии проекта или его пользователей.

Основные назначения файла *.csproj.user*:
- **Хранение пользовательских настроек**: Файл *.csproj.user* содержит настройки, такие как параметры отладки, конфигурации среды выполнения и другие предпочтения, которые могут отличаться у разных пользователей. Это позволяет каждому разработчику настраивать свою среду работы без изменения общего проекта.

- **Изоляция изменений**: Поскольку файл *.csproj.user* не включается в систему контроля версий (например, Git), изменения, внесенные в него, не будут затрагивать других участников команды. Это особенно полезно для настройки локальной отладки или других параметров, специфичных для конкретной машины.

- **Упрощение работы с проектом**: Пользователи могут настроить свои параметры разработки без необходимости редактировать основной файл проекта (*.csproj*), что делает процесс более удобным и безопасным.

- **Формат XML**: Файл *.csproj.user* является XML-документом и может быть открыт и отредактирован вручную при необходимости, хотя обычно это не требуется.

Таким образом, файл *.csproj.user* играет важную роль в управлении индивидуальными настройками разработчиков в проектах WPF, обеспечивая гибкость и возможность персонализации среды разработки.

Каталог *bin* в проекте WPF служит для хранения собранных выходных файлов приложения, таких как исполняемые файлы (.exe) и библиотеки (.dll). Он автоматически создается при сборке проекта и содержит все необходимые файлы для запуска приложения.

Основные назначения каталога *bin*:
- **Хранение выходных файлов**: В каталоге *bin* находятся собранные версии приложения, которые могут быть в режиме отладки (Debug) или релиза (Release). Например, в подкаталоге Debug *будет* находиться исполняемый файл вашего приложения, а также все зависимости, необходимые для его работы1.

- **Упрощение развертывания**: Все необходимые файлы для запуска приложения находятся в одном месте, что упрощает процесс развертывания. Разработчики могут легко копировать содержимое каталога *bin* для установки приложения на другую машину без необходимости собирать проект заново.

- **Отладка и тестирование**: При разработке и тестировании приложения файлы в каталоге *bin* обновляются каждый раз при сборке проекта, что позволяет разработчикам быстро проверять изменения и тестировать функциональность.

- **Поддержка различных конфигураций**: В зависимости от конфигурации сборки (Debug или Release), в каталоге *bin* могут создаваться разные подкаталоги, что позволяет управлять версиями приложения и их зависимостями.

Таким образом, каталог *bin* является важной частью структуры проекта WPF, обеспечивая хранение и организацию выходных файлов, необходимых для работы и развертывания приложения.

Каталог *obj* в проекте WPF используется для хранения временных файлов, которые создаются во время процесса сборки. Этот каталог содержит промежуточные данные, необходимые для компиляции проекта, и не предназначен для конечного использования.

Основные назначения каталога *obj*:
- **Хранение промежуточных файлов**: В каталоге *obj* находятся временные файлы, такие как скомпилированные версии XAML-файлов (например, файлы *.g.cs*), которые генерируются на основе XAML-кода. Эти файлы содержат автоматически сгенерированный код, необходимый для работы с интерфейсом приложения.

- **Оптимизация процесса сборки**: Наличие каталога *obj* позволяет ускорить процесс сборки, так как временные файлы могут быть повторно использованы при последующих сборках. Это снижает время компиляции, так как не требуется каждый раз пересобирать все файлы.

- **Поддержка различных конфигураций**: В каталоге *obj* могут создаваться подкаталоги для различных конфигураций сборки (например, Debug и Release), что позволяет управлять временными файлами в зависимости от выбранной конфигурации.

- **Изоляция от конечного кода**: Файлы в каталоге *obj* не включаются в окончательную сборку приложения и не должны быть переданы другим пользователям или системам контроля версий. Это помогает сохранить чистоту структуры проекта.

Таким образом, каталог *obj* является важным элементом процесса разработки в WPF, обеспечивая хранение временных файлов и оптимизацию сборки приложения.

## XAML

### Введение в язык XAML
*[XAML]: eXtensible Application Markup Language
<dfn title="XAML">XAML</dfn> (eXtensible Application Markup Language) — язык разметки, используемый для инициализации объектов в технологиях на платформе .NET. Применительно к WPF (а также к Silverlight[^Silverlight]) данный язык используется прежде всего для создания пользовательского интерфейса декларативным путем. Хотя функциональность XAML только графическими интерфейсами не ограничивается: данный язык также используется в технологиях WCF[^WCF] и WF, где он никак не связан с графическим интерфейсом. То есть его область шире. Применительно к WPF мы будем говорить о нем чаще всего именно как о языке разметки, который позволяет создавать декларативным путем интерфейс, наподобие HTML в веб-программировании. Однако опять же повторюсь, сводить XAML к одному интерфейсу было бы неправильно, и далее на примерах мы это увидим.

[^Silverlight]: Microsoft Silverlight is a discontinued application framework designed for writing and running rich internet applications, similar to Adobe's runtime, Adobe Flash

[^WCF]: The Windows Communication Foundation, previously known as Indigo, is a free and open-source runtime and a set of APIs in the .NET Framework for building connected, service-oriented applications.

XAML не является обязательной частью приложения, мы вообще можем обходиться без него, создавая все элементы в файле связанного с ним кода на языке C#. Однако использование XAML все-таки несет некоторые преимущества:

- Возможность отделить графический интерфейс от логики приложения, благодаря чему над разными частями приложения могут относительно автономно работать разные специалисты: над интерфейсом — дизайнеры, над кодом логики — программисты.

- Компактность, понятность, код на XAML относительно легко поддерживать.

*[BAML]: Binary Application Markup Language
При компиляции приложения в Visual Studio код в xaml-файлах также компилируется в бинарное представление кода *xaml*, которое называется BAML (Binary Application Markup Language). И затем код baml встраивается в финальную сборку приложения — *exe* или *dll*-файл.

#### Структура XAML
При создании нового проекта WPF он уже содержит файлы с кодом *xaml*. Так, создаваемый по умолчанию в проекте файл *MainWindow.xaml* будет иметь следующую разметку:
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Grid>

    </Grid>
</Window>
```

Подобно структуре веб-страничке на *html*, здесь есть некоторая иерархия элементов. Элементов верхнего уровня является `Window`, который представляет собой окно приложения. При создании других окон в приложении нам придется всегда начинать объявление интерфейса с элемента `Window`, поскольку это элемент самого верхнего уровня.

Кроме `Window` существует еще два элемента верхнего уровня:

- `Page`

- `Application`

Элемент `Window` имеет вложенный пустой элемент `Grid`, а также подобно html-элементам ряд атрибутов (`Title`, `Width`, `Height`) — они задают заголовок, ширину и высоту окна соответственно.

#### Пространства имен XAML
При создании кода на языке C#, чтобы нам были доступны определенные классы, мы подключаем пространства имен с помощью директивы `using`, например, `using System.Windows;`.

Чтобы задействовать элементы в XAML, мы также подключаем пространства имен. Вторая и третья строчки как раз и представляют собой пространства имен, подключаемые в проект по умолчанию. А атрибут **`xmlns`** представляет специальный атрибут для определения пространства имен в XML.

Так, пространство имен **`http://schemas.microsoft.com/winfx/2006/xaml/presentation`** содержит описание и определение большинства элементов управления. Так как является пространством имен по умолчанию, то объявляется без всяких префиксов.

**`http://schemas.microsoft.com/winfx/2006/xaml`** — это пространство имен, которое определяет некоторые свойства XAML, например свойство `Name` или `Key`. Используемый префикс `x` в определении `xmlns:x` означает, что те свойства элементов, которые заключены в этом пространстве имен, будут использоваться с префиксом **`x`** — `x:Name` или `x:Key`. Это же пространство имен используется уже в первой строчке **`x:Class="XamlApp.MainWindow"`** — здесь создается новый класс `MainWindow` и соответствующий ему файл кода, куда будет прописываться логика для данного окна приложения.

Это два основных пространства имен. Рассмотрим остальные:

- **`xmlns:d="http://schemas.microsoft.com/expression/blend/2008"`**: предоставляет поддержку атрибутов в режиме дизайнера. Это пространство имен преимущественно предназначено для другого инструмента по созданию дизайна на XAML — Microsoft Expression Blend

- **`xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"`**: обеспечивает режим совместимости разметок XAML. В определении объекта Window двумя строчками ниже можно найти его применение:

  ```
  mc:Ignorable="d"
  ```

  Это выражение позволяет игнорировать парсерам XAML во время выполнения приложения дизайнерские атрибуты из пространства имен с префиксом **`d`**, то есть из `"http://schemas.microsoft.com/expression/blend/2008"`

- **`xmlns:local="clr-namespace:XamlApp"`**: пространство имен текущего проекта. Так как в моем случае проект называется *XamlApp*, то простраство имен называется аналогично. И через префикс `local` я смогу получить в XAML различные объекты, которые я определил в проекте.

Важно понимать, что эти пространства имен не эквивалентны тем пространствам имен, которые подключаются при помощи директивы `using` в c#. Так, например, **`http://schemas.microsoft.com/winfx/2006/xaml/presentation`** подключает в проект следующие пространства имен:

- `System.Windows`

- `System.Windows.Automation`

- `System.Windows.Controls`

- `System.Windows.Controls.Primitives`

- `System.Windows.Data`

- `System.Windows.Documents`

- `System.Windows.Forms.Integration`

- `System.Windows.Ink`

- `System.Windows.Input`

- `System.Windows.Media`

- `System.Windows.Media.Animation`

- `System.Windows.Media.Effects`

- `System.Windows.Media.Imaging`

- `System.Windows.Media.Media3D`

- `System.Windows.Media.TextFormatting`

- `System.Windows.Navigation`

- `System.Windows.Shapes`

- `System.Windows.Shell`

#### Элементы и их атрибуты
XAML предлагает очень простую и ясную схему определения различных элементов и их свойств. Каждый элемент, как и любой элемент XML, должен иметь открытый и закрытый тег, как в случае с элементом Window:
```xml
<Window></Window>
```

Либо элемент может иметь сокращенную форму с закрывающим слешем в конце, наподобие:
```xml
<Window />
```

Но в отличие от элементов *xml* каждый элемент в XAML соответствует определенному классу C#. Например, элемент `Button` соответствует классу `System.Windows.Controls.Button`. А свойства этого класса соответствуют атрибутам элемента `Button`.

Например, добавим кнопку в создаваемую по умолчанию разметку окна:
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Grid x:Name="grid1">
        <Button x:Name="button1"  Width="100" Height="30" Content="Кнопка" />
    </Grid>
</Window>
```

Сначала идет элемент самого высшего уровня — `Window`, затем идет вложенный элемент `Grid` — контейнер для других элементов, и в нем уже определен элемент `Button`, представляющий кнопку.

Для кнопки мы можем определить свойства в виде атрибутов. Здесь определены атрибуты `x:Name` (имя кнопки), `Width`, `Height` и `Content`. Причем, атрибут `x:Name` берется в данном случае из пространства имен `"http://schemas.microsoft.com/winfx/2006/xaml"`, которое сопоставляется с префиксом **`x`**. А остальные атрибуты не используют префиксы, поэтому берутся из основного пространства имен `"http://schemas.microsoft.com/winfx/2006/xaml/presentation"`.

Подобным образом мы можем определить и другие атрибуты, которые нам нужны. Либо мы в общем можем не определять атрибуты, и тогда они будут использовать значения по умолчанию.

Определив разметку *xaml*, мы можем запустить проект, и нам отобразится графически весь код *xaml* — то есть наша кнопка

#### Специальные символы
При определении интерфейса в XAML мы можем столкнуться с некоторыми ограничениями. В частности, мы не можем использовать специальные символы, такие как знак амперсанда `&,` кавычки `"` и угловые скобки `<` и `>`. Например, мы хотим, чтобы текст кнопки был следующим: `<"Hello">`. У кнопки есть свойство `Content`, которое задает содержимое кнопки. И можно предположить, что нам надо написать так:
```xml
<Button Content="<"Hello">" />
```

Но такой вариант ошибочен и даже не скомпилируется. В этом случае нам надо использовать специальные коды символов:

Символ |	Код
-- | --
`<` |	`&lt;`
`>` |	`&gt;`
`&` |	`&amp;`
`"` |	`&quot;`

Например:
```xml
<Button Content="&lt;&quot;Hello&quot;&gt;" />
```

Еще одна проблема, с которой мы можем столкнуться в XAML — добавление пробелов. Возьмем, к примеру, следующее определение кнопки:
```xml
<Button>
    Hello         World
</Button>
```

Здесь свойство `Content` задается неявно в виде содержимого между тегами `<Button>....</Button>`. Но несмотря на то, что у нас несколько пробелов между словами "Hello" и "World", XAML по умолчанию будет убирать все эти пробелы. И чтобы сохранить пробелы, нам надо использовать атрибут `xml:space="preserve"`:
```xml
<Button xml:space="preserve">
    Hello         World
</Button>
```

### Файлы отделенного кода
При создании нового проекта WPF в дополнение к создаваемому файлу *MainWindow.xaml* создается также файл отделенного кода *MainWindow.xaml.cs*, где, как предполагается, должна находится логика приложения связанная с разметкой из MainWindow.xaml. Файлы XAML позволяют нам определить интерфейс окна, но для создания логики приложения, например, для определения обработчиков событий элементов управления, нам все равно придется воспользоваться кодом C#.

По умолчанию в разметке окна используется атрибут **`x:Class`**:
```xml
<Window x:Class="XamlApp.MainWindow"
.......
```

Атрибут **`x:Class`** указывает на класс, который будет представлять данное окно и в который будет компилироваться код в XAML при компиляции. То есть во время компиляции будет генерироваться класс **`XamlApp.MainWindow`**, унаследованный от класса `System.Windows.Window`.

Кроме того в файле отделенного кода *MainWindow.xaml.cs*, который Visual Studio создает автоматически, мы также можем найти класс с тем же именем — в данном случае класс `XamlApp.MainWindow`. По умолчанию он имеет некоторый код:
```c#
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace XamlApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
```

По сути пустой класс, но этот класс уже выполняет некоторую работу. Во время компиляции этот класс объединяется с классом, сгенерированном из кода XAML. Чтобы такое слияние классов во время компиляции произошло, класс `XamlApp.MainWindow` определяется как частичный с модификатором **`partial`**. А через метод `InitializeComponent()` класс `MainWindow` вызывает скомпилированный ранее код XAML, разбирает его и по нему строит графический интерфейс окна.

#### Взаимодействие кода C# и XAML
В приложении часто требуется обратиться к какому-нибудь элементу управления. Для этого надо установить у элемента в XAML свойство Name.

Еще одной точкой взаимодействия между xaml и C# являются события. С помощью атрибутов в XAML мы можем задать события, которые будут связанны с обработчиками в коде C#.

Итак, создадим новый проект WPF, который назовем XamlApp. В разметке главного окна определим два элемента: кнопку и текстовое поле.
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Grid x:Name="grid1">
        <TextBox x:Name="textBox1" Width="150" Height="30" VerticalAlignment="Top" Margin="20" />
        <Button x:Name="button1"  Width="100" Height="30" Content="Кнопка" Click="Button_Click" />
    </Grid>
</Window>
```

И изменим файл отделенного кода, добавив в него обработчик нажатия кнопки:
```c#
using System.Windows;

namespace XamlApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            string text = textBox1.Text;
            if (text != "")
            {
                MessageBox.Show(text);
            }
        }
    }
}
```

Определив имена элементов в XAML, затем мы можем к ним обращаться в коде c#: `string text = textBox1.Text`.

При определении имен в XAML надо учитывать, что оба пространства имен "http://schemas.microsoft.com/winfx/2006/xaml/presentation" и "http://schemas.microsoft.com/winfx/2006/xaml" определяют атрибут **`Name`**, который устанавливает имя элемента. Во втором случае атрибут используется с префиксом **`x`**: `x:Name`. Какое именно пространство имен использовать в данном случае, не столь важно, а следующие определения имени `x:Name="button1"` и `Name="button1"` фактически будут равноценны.

В обработчике нажатия кнопки просто выводится сообщение , введенное в текстовое поле. После определения обработчика мы его можем связать с событием нажатия кнопки в *xaml* через атрибут `Click`: `Click="Button_Click"`. В результате после нажатия на кнопку мы увидим в окне введенное в текстовое поле сообщение.

#### Создание элементов в коде C#
Еще одну форму взаимодействия C# и XAML представляет создание визуальных элементов в коде C#. Например, изменим код *xaml* следующим образом:
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Grid x:Name="layoutGrid">

    </Grid>
</Window>
```

Здесь для элемента `Grid` установлено свойство `x:Name`, через которое мы можем к нему обращаться в коде. И также изменим код C#:
```c#
using System.Windows;
using System.Windows.Controls;

namespace XamlApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            Button myButton = new Button();
            myButton.Width = 100;
            myButton.Height = 30;
            myButton.Content = "Кнопка";
            layoutGrid.Children.Add(myButton);
        }
    }
}
```

В конструкторе страницы создается элемент `Button` и добавляется в `Grid`. И если мы запустим приложение, то увидим добавленную кнопку.

### Сложные свойства и конвертеры типов
В предыдущих темах было рассмотрено создание элементов в XAML. Например, мы могли бы определить кнопку следующим образом:
```html
<Button x:Name="myButton" Width="120" Height="40" Content="Кнопка" HorizontalAlignment="Center" Background="Red" />
```

С помощью атрибутов мы можем задать различные свойства кнопки. `Height` и `Width` являются простыми свойствами. Они хранят числовое значение. А например, свойства `HorizontalAlignment` или `Background` являются более сложными по своей структуре. Так, если мы будем определять эту же кнопку в коде c#, то нам надо использовать следующий набор инструкций:
```c#
Button myButton = new Button();
myButton.Content = "Кнопка";
myButton.Width = 120;
myButton.Height = 40;
myButton.HorizontalAlignment = HorizontalAlignment.Center;
myButton.Background = new System.Windows.Media.SolidColorBrush(System.Windows.Media.Colors.Red);
```

Чтобы выровнять кнопку по центру, применяется перечисление `HorizontalAlignment`, а для установки фонового цвета — класс `SolidColorBrush`. Хотя в коде XAML мы ничего такого не увидели и устанавливали эти свойства гораздо проще с помощью строк: `Background="Red"`. Дело в том, что по отношению к коду XAML применяются специальные объекты — **type converter** или конвертеры типов, которые могут преобразовать значения из XAML к тем типам тех объектов, которые используются в коде C#.

В WPF имеются встроенные конвертеры для большинства типов данных: `Brush`, `Color`, `FontWeight` и т.д. Все конвертеры типов являются производными от класса **`TypeConverter`**. Например, конкретно для преобразования значения `Background="Red"` в объект `SolidColorBrush` используется производный класс `BrushConverter`. При необходимости можно создать свои конвертеры для каких-то собственных типов данных.

Фактически установка значения в XAML `Background="Red"` сводилась бы к следующему вызову в коде c#:
```c#
myButton.Background = (Brush)System.ComponentModel.TypeDescriptor
        .GetConverter(typeof(Brush)).ConvertFromInvariantString("Red");
```

В данном случае программа пытается получить конвертер для типа `Brush` (базового класса для `SolidColorBrush`) и затем преобразовать строку `"Red"` в конкретный цвет. Для получения нужного конвертера, программа обращается к метаданным класса `Brush`. В частности, он имеет следующий атрибут:
```c#
[TypeConverter(typeof(BrushConverter))]
public abstract class Brush
```

Данный атрибут и позволяет системе определить, какой тип конвертера использовать.

В то же время мы можем более явно использовать эти объекты в коде XAML:
```xml
<Button x:Name="myButton" Width="120" Height="40" Content="Кнопка">
    <Button.HorizontalAlignment>
        <HorizontalAlignment>Center</HorizontalAlignment>
    </Button.HorizontalAlignment>

    <Button.Background>
        <SolidColorBrush Opacity="0.5" Color="Red" />
    </Button.Background>
</Button>
```

Преимуществом такого подхода является то, что у объектов мы можем установить дополнительные параметры.

### Пространства имен из C# в XAML
По умолчанию в WPF в XAML подключается предустановленный набор пространств имен *xml*. Но мы можем задействовать любые другие пространства имен и их функциональность в том числе и стандартные пространства имен платформы .NET, например, `System` или `System.Collections`. Например, по умолчанию в определении элемента Window подключается локальное пространство имен:
```xml
xmlns:local="clr-namespace:XamlApp"
```

Локальное пространство имен, как правило, называется по имени проекта (в моем случае проект называется `XamlApp`) и позволяет подключить все классы, которые определены в коде C# в нашем проекте. Например, добавим в проект следующий класс:
```c#
public class Phone
{
    public string Name { get; set; }
    public int Price { get; set; }

    public override string ToString()
    {
        return $"Смартфон {this.Name}; цена: {this.Price}";
    }
}
```

Используем этот класс в коде *xaml*:
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Grid x:Name="layoutGrid">
        <Button x:Name="phoneButton" Width="250" Height="40" HorizontalAlignment="Center">
            <Button.Content>
                <local:Phone Name="Lumia 950" Price="700" />
            </Button.Content>
        </Button>
    </Grid>
</Window>
```

Так как пространство имен проекта проецируется на префикс **`local`**, то все классы проекта используются в форме `local:Название_Класса`. Так в данном случае объект `Phone` устанавливается в качестве содержимого кнопки через свойство `Content`. Для сложных объектов это свойство принимает их строковое представление, которое возвращается методом `ToString()`.

Мы можем подключить любые другие пространства имен, классы которых мы хотим использовать в приложении. Например:
```xml
<Window x:Class="XamlApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:XamlApp"

        xmlns:col="clr-namespace:System.Collections;assembly=mscorlib"
        xmlns:sys="clr-namespace:System;assembly=mscorlib"

        mc:Ignorable="d"
        Title="MainWindow" Height="350" Width="525">
    <Window.Resources>
        <col:ArrayList x:Key="days">
            <sys:String>Понедельник</sys:String>
            <sys:String>Вторник</sys:String>
            <sys:String>Среда</sys:String>
            <sys:String>Четверг</sys:String>
            <sys:String>Пятница</sys:String>
            <sys:String>Суббота</sys:String>
            <sys:String>Воскресенье</sys:String>
        </col:ArrayList>
    </Window.Resources>
    <Grid>

    </Grid>
</Window>
```

Здесь определены два дополнительных пространства имен:
```xml
xmlns:col="clr-namespace:System.Collections;assembly=mscorlib"
xmlns:sys="clr-namespace:System;assembly=mscorlib"
```

Благодаря этому нам становятся доступными объекты из пространств имен `System.Collections` и `System`. И затем используя префикс, мы можем использовать объекты, входящие в данные пространства имен: `<col:ArrayList...`.

Общий синтаксис подключения пространств имен следующий: `xmlns:Префикс="clr-namespace:Пространство_имен;assembly=имя_сборки"`. Так в предыдущем случае мы подключили пространство имен `System.Collections`, классы которого находятся в сборке `mscorlib`. И данное подключенное пространство имен у нас отображено на префикс `col`.
