## Data Access / Доступ к данным

- [Data Access / Доступ к данным](#data-access--доступ-к-данным)
  - [Основные технологии доступа к данным](#основные-технологии-доступа-к-данным)
  - [Объектно-ориентированные механизмы](#объектно-ориентированные-механизмы)
  - [Технология OLE](#технология-ole)
  - [Базовая технология доступа к данным СОМ](#базовая-технология-доступа-к-данным-сом)
  - [Технология ODBC](#технология-odbc)
  - [DAO и RDO](#dao-и-rdo)
  - [Технология OLE DB](#технология-ole-db)
    - [Суть OLE DB](#суть-ole-db)
    - [Основные понятия OLE DB](#основные-понятия-ole-db)
    - [Объектная модель OLE DB](#объектная-модель-ole-db)
    - [Доступ к OLE DB](#доступ-к-ole-db)
  - [Технология ADO](#технология-ado)
  - [Платформа .NET](#платформа-net)
    - [Особенности .NET](#особенности-net)
      - [CIL и CLR](#cil-и-clr)
      - [.NET Framework и .NET](#net-framework-и-net)
      - [Управляемый и неуправляемый код](#управляемый-и-неуправляемый-код)
      - [JIT-компиляция](#jit-компиляция)
    - [Работа с базами данных в .NET Framework](#работа-с-базами-данных-в-net-framework)
  - [Технология ADO.NET](#технология-adonet)
    - [Обзор ADO.NET](#обзор-adonet)
      - [Три стороны ADO.NET](#три-стороны-adonet)
    - [Архитектура и принцип работы ADO.NET](#архитектура-и-принцип-работы-adonet)
      - [Поставщики данных в ADO.NET](#поставщики-данных-в-adonet)
      - [Стандартизация в ADO.NET](#стандартизация-в-adonet)
      - [Фундаментальные классы ADO.NET](#фундаментальные-классы-adonet)
      - [Автономный уровень](#автономный-уровень)
    - [Сравнение ADO и ADO.NET](#сравнение-ado-и-adonet)
  - [ADO.NET Entity Framework](#adonet-entity-framework)
    - [Предыстория возникновения](#предыстория-возникновения)
    - [ORM / Объектно-реляционное отображение](#orm--объектно-реляционное-отображение)
    - [История развития Entity Framework](#история-развития-entity-framework)
    - [Архитектура Entity Framework](#архитектура-entity-framework)
      - [Роль сущностей](#роль-сущностей)
      - [Роль служб объектов](#роль-служб-объектов)
      - [Роль клиента сущности](#роль-клиента-сущности)
      - [Роль файла \*.edmx](#роль-файла-edmx)
      - [Роль классов ObjectContext и ObjectSet](#роль-классов-objectcontext-и-objectset)
    - [Модель EDM](#модель-edm)
      - [Слои](#слои)
      - [Генерация файла \*.edmx](#генерация-файла-edmx)
        - [Файлы Entity Framework](#файлы-entity-framework)
    - [Entity Client](#entity-client)
    - [Сущности и класс ObjectContext](#сущности-и-класс-objectcontext)
      - [Сущности](#сущности)
      - [ObjectContext](#objectcontext)
    - [Подходы для работы](#подходы-для-работы)
      - [Подход Code-First](#подход-code-first)
      - [Подход Model-First](#подход-model-first)
      - [Подход Database-First](#подход-database-first)
      - [Совместимые с Entity Framework поставщики данных](#совместимые-с-entity-framework-поставщики-данных)
      - [Как выбрать нужный подход?](#как-выбрать-нужный-подход)
      - [Класс контекста данных](#класс-контекста-данных)
  - [Entity Framework Core](#entity-framework-core)
    - [Обзор EF Core](#обзор-ef-core)
    - [EF6 vs. EF Core](#ef6-vs-ef-core)
  - [Работа с данными](#работа-с-данными)
    - [Описание DbContext API](#описание-dbcontext-api)
    - [Создание запросов](#создание-запросов)
      - [Исходный проект](#исходный-проект)
      - [Использование запросов Entity SQL](#использование-запросов-entity-sql)
      - [Использование LINQ](#использование-linq)
      - [Отложенная компиляция LINQ-запросов](#отложенная-компиляция-linq-запросов)
  - [LINQ](#linq)
    - [Появление LINQ](#появление-linq)
    - [Основы LINQ](#основы-linq)
    - [Операторы запросов LINQ](#операторы-запросов-linq)
    - [Методы расширения LINQ](#методы-расширения-linq)
    - [Список используемых методов расширения LINQ](#список-используемых-методов-расширения-linq)
  - [LINQ to Entities](#linq-to-entities)
    - [Обзор LINQ to Entities](#обзор-linq-to-entities)
    - [Загрузка данных](#загрузка-данных)
      - [Указание столбцов, условий и сортировки в запросе](#указание-столбцов-условий-и-сортировки-в-запросе)
      - [Поиск в запросе](#поиск-в-запросе)
      - [Локальные данные](#локальные-данные)
      - [Использование особенностей коллекции ObservableCollection](#использование-особенностей-коллекции-observablecollection)
    - [Загрузка связанных данных](#загрузка-связанных-данных)
      - [Отложенная загрузка (lazy loading)](#отложенная-загрузка-lazy-loading)
      - [Прямая загрузка (eager loading)](#прямая-загрузка-eager-loading)
      - [Явная загрузка (explicit loading)](#явная-загрузка-explicit-loading)
      - [Универсальный метод загрузки данных](#универсальный-метод-загрузки-данных)
    - [Вставка данных](#вставка-данных)
      - [Вставка одного объекта](#вставка-одного-объекта)
      - [Вставка связанных объектов](#вставка-связанных-объектов)
      - [Реализация шаблона “найти или вставить”](#реализация-шаблона-найти-или-вставить)
      - [Создание универсального метода вставки](#создание-универсального-метода-вставки)
    - [Обновление данных](#обновление-данных)
      - [Обновление одного объекта](#обновление-одного-объекта)
      - [Обновление связанных объектов](#обновление-связанных-объектов)
      - [Универсальный метод обновления](#универсальный-метод-обновления)

### Основные технологии доступа к данным
На заре эпохи баз данных разработчикам достаточно было знать только те базы данных, которые они использовали. Но базы данных и их технологии развивались довольно быстро — от реляционных баз данных к нереляционным информационным хранилищам, таким, как электронная почта и файловые системы. Развитие баз данных сейчас идет в ногу со стремительными изменениями в технике. А с появлением клиент-серверных и многоуровневых архитектур разработчикам уже приходится разбираться во всем многообразии технологий баз данных. Большинство разработчиков потратили годы на изучение ODBC, DAO, RDO, OLE DB, ADO и RDS. К настоящему моменту Microsoft представила .NET Framework и вместе с ней новую технологию баз данных ADO.NET.

Как только мы начинаем углубляться в какую-то новую технологию, мы забываем, как она развивалась и что рационального за ней стоит. Проследив развитие технологий баз данных от ODBC до ADO.NET, проще выбрать подходящую технологию и оптимизировать ее для своих целей.

<dfn title="технология доступа к данным">Технологией доступа к данным</dfn> называется система интерфейсов, обеспечивающая взаимодействие между приложением и базой данных. Во многих системах управления базами данных имеются библиотеки, содержащие интерфейсы прикладного программирования (application programming interface – API), представляющие собой функции, при помощи которых можно выполнять с данными те или иные действия.

Для того, чтобы наиболее полно использовать возможности того или иного сервера баз данных, необходимо работать с ним напрямую, через API. Однако это означает полную зависимость приложения от того или иного сервера и сложность перехода на другую платформу, так как будет необходимо переписывать большое количество кода.

Этот вопрос призваны решить различные технологии доступа к данным. Они являются прослойкой между API конкретного сервера и приложением пользователя, предоставляя программисту простой унифицированный механизм работы с данными.

На сегодняшний день существует множество технологий доступа к данным, таких как:
- COM
- ODBC
- OLE DB
- ADO
- ADO.NET
- MIDAS

Все эти технологии основаны на единых принципах – объектных моделях доступа к удаленным БД, и разрабатываются, соответственно, на методах объектно-ориентированного программирования.

### Объектно-ориентированные механизмы
Появление парадигмы объектно-ориентированного программирования подарило программистам очень мощные инструменты для обработки информации. Начали появляться новые языки, которые использовались для разных спектров задач, программное обеспечение становилось модульным. Написание новой программы с функционалом, который использовал стандартные механизмы ввода/вывода стало тривиальной задачей. Нужно было только подключить нужную библиотеку, которая уже содержала все необходимые функции.

Результатом использования парадигмы объектно-ориентированного подхода стали методы логического разбиения приложений на отдельные фрагменты, при этом можно было создавать уже скомпилированные части кода, которые собирались в новые приложения. Модульность позволила задуматься о механизмах, которые могли бы позволить объединять код, фрагменты которого были бы написаны на разных языках программирования, в одну систему, которая решала бы отдельно взятую проблему или целый класс проблем.

После того как объектно-ориентированные технологии стали доминирующими в системном программировании, разработчики приложений клиент-сервер также начали применять этот подход. В этом случае объекты на клиентах и серверах обмениваются сообщениями. Взаимодействие между объектами может быть основано на обмене сообщениями, на удаленном вызове процедур или непосредственно на объектноориентированных возможностях операционной системы.

Клиент, которому требуется услуга, посылает запрос брокеру объектных запросов, действующему как каталог всех доступных в сети удаленных услуг. Брокер вызывает соответствующий объект и передает ему необходимые данные. Затем удаленный объект обслуживает запрос и отвечает брокеру, который возвращает ответ клиенту.

В операционной системе Windows подход к созданию отдельных компонентов был реализован в предоставлении унифицированных интерфейсов, которыми приложения пользуются и по сей день. Эти интерфейсы называются WinAPI. Их исследование достаточно тривиально, большая часть интерфейсов задокументирована и поэтому их обратная разработка заключается в том, чтобы найти в документации название и прочитать данные о параметрах и возвращаемом значении.

Каждый WinAPI интерфейс позволяет сделать минимальное действие, которое может произвести ОС, то есть если программист решит написать приложение, то для его реализации придётся задействовать несколько сотен, а то и тысяч интерфейсов. Отдельно стоит упомянуть, что это далеко не единственный способ, который доступен в ОС для реализации алгоритмов. ОС Windows также предлагает компонентный подход для построения приложений. Это означает, что программист может объединять целые программы вместе, чтобы реализовать выполнение алгоритма. Возможно это за счет использования механизма Component Object Module.

*[COM]: Component Object Model
*[OLE]: Object Linking and Embedding
*[CORBA]: Common Object Request Broker Architecture
Успех объектно-ориентированного подхода зависит от того, насколько хорошо стандартизирован объектный механизм. К сожалению, в этой области сосуществуют сразу несколько конкурирующих схем. Одной из них является модель COM (Component Object Model — модель компонентных объектов) компании Microsoft, являющаяся основой технологии OLE (Object Linking and Embedding — связывание и внедрение объектов). Этот метод получил поддержку со стороны компании Digital Equipment Corporation, разработавшей механизм СОМ для операционной системы UNIX. С этим подходом конкурирует получившая широкую промышленную поддержку технология CORBA (Common Object Request Broker Architecture — обобщенная архитектура брокера объектных запросов), разработанная компанией Object Management Group. Архитектуру CORBA поддерживают компании IBM, Apple, Sun, а также многие другие.

Механизмы доступа к базам данных снижают сложность обмена информацией с базами, однако интерпретация результатов их работы также достаточно трудоемка. Поэтому реализованы наборы компонентов, предназначенные для взаимодействия с механизмами обмена.

Таким образом, можно выделить несколько субъектов, участвующих в движении информации между базой данных и приложением (например, пользовательским интерфейсом):
1) интерфейсная часть приложения или его программная часть, манипулирующая информацией, хранимой в базе данных;
2) компоненты, обеспечивающие связь приложения с механизмом доступа к базе данных;
3) механизм доступа к базе данных;
4) база данных.

При разработчике приложения-СУБД программист работает с наборами компонентов, предназначенных для обмена информацией с базами данных и ее отображения. В зависимости от выбранного механизма доступа к базе данных некоторые наборы компонентов могут не использоваться, однако все они, вне зависимости от особенностей используемой базы данных и механизма доступа к ней, имеют схожие свойства и методы.

### Технология OLE
<dfn title="OLE">OLE</dfn> (<dfn title="Object Linking and Embedding">Object Linking and Embedding</dfn>) — технология связывания и внедрения объектов в другие документы и объекты, разработанные корпорацией Microsoft. Она позволяет пользователям создавать и изменять документы, содержащие элементы или объекты, созданные несколькими приложениями.

<dfn title="связывание объектов">Связывание объектов</dfn> — это технология, входящая в состав Object Linking and Embedding (OLE), разработанная Microsoft. Она позволяет включать ссылки на объекты из одного приложения в документ другого приложения, сохраняя связь с исходным объектом. Это означает, что при изменении исходного объекта, связанная копия в документе также обновляется.

Основные особенности связывания объектов:
- **Сохранение связи с исходным объектом**: Связанный объект остается в исходном документе, а в составном документе хранится только ссылка на него. Это позволяет автоматически обновлять связанные объекты при изменении исходного документа.

- **Экономия места**: Поскольку в документе хранится только ссылка, а не сам объект, это может уменьшить размер файла и улучшить производительность при работе с большими документами.

- **Удобство обновления**: Если объект используется в нескольких документах, его изменение в одном месте автоматически отразится во всех связанных документах.

Для чего нужно связывание объектов?
- **Создание составных документов**: Связывание позволяет объединять данные из разных источников в один документ, сохраняя возможность редактировать эти данные в исходных приложениях.

- **Упрощение обновления данных**: Это особенно полезно в корпоративной среде, где изменения в одном документе должны отражаться во всех связанных с ним документах.

- **Эффективное управление памятью**: Связывание вместо внедрения помогает уменьшить размер документов и улучшить их обработку на устройствах с ограниченными ресурсами.

OLE используется при обработке составных документов (compound documents), может быть использована при передаче данных между различными несвязанными между собой системами посредством интерфейса переноса (drag-and-drop), а также при выполнении операций с буфером обмена.

OLE-объекты являются COM-объектами и поддерживают все требуемые для таких объектов интерфейсы.

Основные особенности OLE:
- **Связывание и внедрение**: OLE позволяет вставлять объекты из одного приложения в документ другого приложения. Объекты могут быть связаны (т.е., ссылаться на исходный файл) или внедрены (т.е., копироваться в документ).

- **Составные документы**: OLE позволяет создавать составные документы, которые включают различные типы данных, такие как текст, изображения, электронные таблицы и аудиоклипы.

- **Автоматизация**: OLE Automation (ныне известная как автоматизация) позволяет скриптовым языкам и другим приложениям взаимодействовать с COM-объектами, что позволяет автоматизировать задачи в приложениях, таких как Microsoft Office.

- **Расширение до COM**: OLE 2.0 стала основой для архитектуры Component Object Model (COM), которая обеспечивает взаимодействие между компонентами программного обеспечения.

Применение OLE
- **Составные документы**: Используется для создания документов, содержащих данные из нескольких источников.

- **Автоматизация**: Позволяет автоматизировать задачи в приложениях, таких как Microsoft Office.

- **Drag-and-Drop**: Поддерживает перетаскивание объектов между приложениями.

Эволюция и наследие
- **ActiveX**: В 1996 году OLE 2.0 была переименована в ActiveX, которая включала элементы управления ActiveX и ActiveX документы.

- **COM** и **DCOM**: OLE 2.0 стала основой для COM и DCOM (Distributed COM), которые обеспечивают взаимодействие между компонентами программного обеспечения.

OLE была важной технологией для интеграции данных из различных приложений, но в настоящее время в основном считается устаревшей и замененной более современными технологиями.

### Базовая технология доступа к данным СОМ
Технология доступа к удаленным данным Component Object Model (COM) – компонентная модель объектов, разработанная фирмой Microsoft как средство взаимодействия приложений (в том числе составных частей ОС Windows), функционирующих на одном ПК. На технологии СОМ построены такие методы управления удаленными объектами, как OLE, Автоматизация, ActiveX.

Стандарт COM был разработан в 1993 году корпорацией Microsoft как основа для развития технологии OLE. <dfn title="объектная модель компонентов">Объектная Модель Компонентов</dfn> (Component Object Model, COM) — это технологический стандарт от компании Microsoft, предназначенный для создания программного обеспечения на основе взаимодействующих распределённых компонентов, каждый из которых может использоваться во многих программах одновременно. Стандарт COM воплощает в себе идеи полиморфизма[^полиморфизм] и инкапсуляции[^инкапсуляция] объектно-ориентированного программирования.

[^полиморфизм]: <dfn title="полиморфизм">Полиморфизм</dfn> — взаимозаменяемость объектов с одинаковым интерфейсом.

[^инкапсуляция]: <dfn title="инкапсуляция">Инкапсуляция</dfn> — свойство языка программирования, позволяющее объединить данные и код в объект и скрыть реализацию объекта от пользователя.

*[IDL]: Interface Definition Language
Основные особенности COM:
1. **Независимость от платформы и языка**: COM-компоненты могут быть написаны на разных языках программирования (например, C++, Visual Basic) и работать в различных средах, хотя в основном используются в операционных системах Windows.

2. **Объектно-ориентированная модель**: COM реализует принципы объектно-ориентированного программирования, такие как полиморфизм и инкапсуляция. Это позволяет компонентам взаимодействовать через стандартизированные интерфейсы.

3. **Распределенная архитектура**: COM поддерживает распределенные системы, где компоненты могут находиться в разных процессах или даже на разных компьютерах. Для этого используется технология DCOM (Distributed COM).

4. **Интерфейсы**: COM-интерфейсы определяют набор методов и свойств, которые могут быть вызваны другими компонентами. Эти интерфейсы объявляются на языке IDL (Interface Definition Language) и служат контрактами для взаимодействия между компонентами.

Применение COM:
- **OLE** и **ActiveX**: COM является базовой технологией для OLE (составные документы) и ActiveX (компоненты с поддержкой Интернета).

- **Автоматизация**: COM используется для автоматизации приложений, таких как Microsoft Office, позволяя программно управлять документами и задачами.

- **Системные компоненты**: COM широко используется в операционных системах Windows для взаимодействия между системными компонентами и приложениями.

Преимущества:

- **Переиспользуемость кода**: Компоненты могут быть использованы в различных приложениях.

- **Независимость от языка**: Компоненты могут быть написаны на разных языках программирования.

- **Распределенная архитектура**: Поддерживает работу в распределенных системах.

Недостатки:

- **Сложность**: COM требует глубокого понимания интерфейсов и механизмов взаимодействия.

- **Устаревшая технология**: COM в основном используется в старых приложениях и системах, а в новых проектах часто предпочитают более современные технологии.

Таким образом, **Component Object Model** (COM) — это технологический стандарт от Microsoft, предназначенный для создания программных компонентов, которые могут взаимодействовать друг с другом независимо от языка программирования и среды выполнения. COM позволяет разработчикам создавать переиспользуемые двоичные компоненты, которые могут быть интегрированы в различные приложения. При этом им не нужно знать внутреннее устройство данных компонентов, заниматься их совместимостью на разных языках программирования и повторной компиляцией.

За понятием <dfn title="COM-объект">COM-объекта</dfn> кроется определение объекта, в котором указаны данные о нем и о наборе интерфейсов для обеспечения его функциональности. COM-объект реализуется в форматах DLL или EXE. На основе стандарта COM выполняется очень много процессов в Windows. В целом, COM — это мощная технология для создания взаимодействующих компонентов, но она считается устаревшей и в основном используется для поддержки старых систем.

### Технология ODBC

*[ODBC]: Open Database Connectivity
<dfn title="ODBC">ODBC</dfn> (<dfn title="Open Database Connectivity">Open Database Connectivity</dfn> – открытый доступ к базам данных) – разработанный компанией Microsoft универсальный интерфейс программирования приложений для доступа к базам данных.

В большинстве систем проектирования баз данных приложения основываются на одном типе баз данных. В таких простых схемах разработчик приложения может программировать напрямую, используя системный интерфейс базы данных. Хотя подобный подход обеспечивает быстрый и эффективный доступ к данным, могут возникать проблемы, когда задача расширяется, и разработчику приходится дорабатывать программу. При данном подходе это означает, что каждая готовая программа должна иметь различные версии с поддержкой всевозможных типов баз данных. Если компании расширяются или объединяются одна с другой, приложение должно получить доступ к базам данных, основанным на различных платформах.

Технология ODBC обеспечивает общий интерфейс для доступа к разнородным базам данных стандарта SQL. ODBC использует язык SQL как стандарт для доступа к данным. Этот интерфейс очень удобен: одно приложение может обращаться к различным базам данных SQL через общий набор команд. Таким образом, разработчик может создавать и распространять приложения, не привязываясь к конкретной базе данных.

Можно также добавить драйвер базы данных, чтобы приложение могло работать с базой данных по выбору пользователя. Менеджер драйверов является промежуточным звеном между приложением и базами данных. Интерфейс ODBC содержит набор функций, который управляет каждым инструментом базы данных. Если приложению нужно сменить используемую базу, разработчик просто заменяет один драйвер другим, и приложение может работать как обычно, без необходимости модификации кода программы.

Основной целью разработки протокола ODBC считается стандартизация механизмов взаимодействия с различными СУБД. Основная проблема, связанная с разработкой приложений, взаимодействующих с базами данных на основе специальных SQL API, состояла в том, что каждая СУБД имела собственный программный интерфейс доступа, каждый из них имел свои особенности и функционировал не совсем так, как другие. В связи с этим разработка приложения существенно зависела от используемой СУБД. Компания Microsoft сделала важный шаг для решения этой проблемы. Основная идея заключалась в разработке универсального интерфейса на уровне семейства операционных систем Windows, который мог бы быть поддержан в разных СУБД.

**Технология ODBC** (от англ. Open Database Connectivity – открытый механизм доступа к базам данных) – это компонент операционной системы Windows, предназначенный для унификации доступа к информации, хранящейся в базах данных различных видов. ODBC состоит из набора драйверов, осуществляющих операции обмена с определенными базами данных, и менеджера драйверов, осуществляющего передачу запросов от приложения к драйверу и передачу информации от драйвера к приложению.

Для получения и изменения данных используется язык запросов SQL, вне зависимости от того, поддерживается ли он базой данных, к которой обращается приложение. Если база данных не поддерживает язык SQL, то доступ к ней не отличается от доступа к БД, поддерживающим SQL. В этом и заключается унификация доступа к базам данных системой ODBC – приложение указывает название драйвера, который должен использоваться для подключения к базе данных, и передает запрос, в котором описан состав требуемой информации. Далее механизм ODBC выполняет все необходимые операции по получению информации, скрывая от приложения специфику работы с конкретной базой данных. Доступ приложений к ODBC осуществляется через API-функции, реализованные в динамических библиотеках.

Основные компоненты ODBC:
1. **ODBC API**: Это набор функций, которые обеспечивают взаимодействие с базами данных. ODBC API включает в себя вызовы функций, стандартный синтаксис SQL, типы данных и протокол соединения с базой данных.

2. **Диспетчер драйверов ODBC**: Это библиотека, которая загружает драйверы базы данных ODBC от имени приложения. Она прозрачна для приложения и обеспечивает взаимодействие между приложением и драйвером.

3. **Драйверы базы данных ODBC**: Это библиотеки DLL, которые обрабатывают вызовы ODBC для конкретных систем управления базами данных (СУБД). Драйверы реализуют стандартные функции ODBC с учетом особенностей каждой СУБД.

Преимущества ODBC:
- **Независимость от базы данных**: ODBC позволяет приложениям работать с различными базами данных, не требуя изменения кода для каждого типа базы данных.

- **Унифицированный интерфейс**: Использует стандартный синтаксис SQL и набор функций, что упрощает разработку приложений.

- **Поддержка различных источников данных**: Может подключаться к реляционным базам данных, электронным таблицам, текстовым файлам и другим источникам данны

Недостатки ODBC:
- Стандарт ODBC предназначен для реляционных баз данных, но в электронном мире существует достаточно много не реляционной информации, такой как сообщения электронной почты, документы, Web-страницы,  картинки, аудиофайлы и т.д. Эти данные не могут хранится в формате реляционных СУБД.

- Для выполнения самых простых задач программисту приходится вызывать десятки сложных функций, т.к. доступ к драйверам ODBC осуществлялся посредством API.

<dfn title="интерфейс прикладного программирования">Интерфейс прикладного программирования</dfn> (Application Programming Interface, API) — набор готовых констант, структур и функций, используемых при программировании пользовательских приложений и обеспечивающих правильное взаимодействие между пользовательским приложением и операционной системой.

То есть для доступа к данным при помощи ODBC любая программа вызывает API-функции, причем в определённой последовательности:
- подключение к источнику данных;
- инициализация и настройка параметров SQL-запроса/оператора;
- формирование и выполнение запроса/оператора;
- получение результатов;
- отключение от источника данных.

ODBC широко используется в приложениях, которые требуют доступа к нескольким источникам данных. Он поддерживает подключение к таким базам данных, как Microsoft SQL Server, Oracle, MySQL, PostgreSQL и многие другие. ODBC также используется для интеграции с различными системами, включая электронные таблицы Microsoft Excel и текстовые файлы.

Типы драйверов ODBC:
- **Одноуровневые драйверы**: Обрабатывают вызовы ODBC и операторы SQL.

- **Многоуровневые драйверы**: Обрабатывают только вызовы ODBC, оставляя СУБД обработку SQL-запросов.

Итак, ODBC (Open Database Connectivity) — это стандартизированный программный интерфейс (API) для доступа к различным базам данных. Он позволяет разработчикам создавать приложения, которые могут взаимодействовать с несколькими источниками данных, используя единый интерфейс, независимо от типа базы данных или поставщика. В целом, ODBC является важным инструментом для обеспечения взаимодействия между приложениями и различными источниками данных, что упрощает разработку и поддержку программного обеспечения.

### DAO и RDO

*[VB]: Visual Basic
*[DAO]: Data Access Object
ODBC использует низкоуровневый интерфейс, поэтому программисты на С и С++ реально задействуют все преимущества технологии ODBC. Программисты на Visual Basic (VB) не имеют простого доступа к интерфейсу ODBC. До появления VB 6.0 разработчики применяли высокоуровневый доступ к данным.

<dfn title="DAO">DAO</dfn> (<dfn title="Data Access Objects">Data Access Objects</dfn>) — это технология, разработанная компанией Microsoft для доступа и управления данными в базах данных. Она позволяет приложениям взаимодействовать с различными источниками данных, включая базы данных Microsoft Access, ODBC-источники и другие.

DAO возникла как часть Visual Basic 2.0 под названием «VT Objects» и была представлена в 1992 году как API для работы с СУБД Jet. DAO базируется на технологии баз данных Microsoft Jet — процессоре баз данных, предназначенном для Microsoft Access. JET был первым объектно-ориентированным интерфейсом для связи с Access. Приложения, использующие Access, могут задействовать DAO для прямого доступа к данным. Поскольку DAO создавалась сразу же вслед за Access, применение этой технологии — самый быстрый и наиболее эффективный способ доступа к базам данных Access.

Основные компоненты DAO:
- **Объекты DAO**: Представляют собой различные элементы базы данных, такие как таблицы (`TableDef`), поля (`Field`), запросы (`QueryDef`) и базы данных (`Database`).

- **Методы и свойства**: Позволяют управлять структурой и данными базы данных, включая создание, изменение и удаление объектов.

Применение DAO:
- **Microsoft Access**: DAO тесно связана с Microsoft Access и используется для управления базами данных Access.

- **Visual Basic**: DAO широко используется в приложениях, написанных на Visual Basic, для доступа к данным.

- **ODBC** и **ISAM**: DAO поддерживает подключение к различным источникам данных через ODBC и ISAM (Indexed Sequential Access Method).

Преимущества:

- **Удобство использования**: DAO предоставляет простой и интуитивно понятный интерфейс для работы с данными.

- **Поддержка различных источников данных**: Позволяет работать с разными типами баз данных.

Недостатки:

- **Устаревшая технология**: DAO считается устаревшей и не рекомендуется для новых проектов.

- **Ограниченная поддержка**: DAO в основном используется для баз данных Microsoft Access и не поддерживает все современные функции.

DAO может работать и с отличными от Access базами данных, такими, как SQL Server и Oracle. DAO использует ODBC, но, поскольку метод DAO спроектирован специально для взаимодействия с JET, JET транслирует запросы между DAO и ODBC. Этот дополнительный шаг трансляции и является причиной замедления работы с базами данных, отличными от Access.

*[RDO]: Remote Data Objects
Чтобы преодолеть это ограничение, разработчики Microsoft создали RDO. DAO развивалась до версии 3.6, которая считается окончательной и устаревшей. DAO поддерживалась до Office 2013, но в настоящее время рекомендуется использовать более современные технологии, такие как ADO.NET и OLE DB/ADO. В целом, DAO — это зрелая технология, которая была широко использована в прошлом, но в настоящее время рекомендуется использовать более современные и эффективные технологии для доступа к данным.

<dfn title="RDO">RDO</dfn> (<dfn title="Remote Data Objects">Remote Data Objects</dfn>) — это технология доступа к базам данных, разработанная компанией Microsoft. Она была представлена в 1995 году вместе с Visual Basic 4.0 и позиционировалась как более простая и эффективная альтернатива прямому использованию ODBC API, а также как более мощная, чем DAO (Data Access Objects), которая была ориентирована на локальные базы данных.

RDO обращается к ODBС API напрямую, минуя JET.

Основные особенности RDO:
- **COM-объекты**: RDO представляет собой набор COM-объектов, которые инкапсулируют ODBC API и клиентскую курсорную библиотеку. Это позволяет разработчикам работать с базами данных на стороне сервера, такими как MS SQL Server и Oracle.

- **Простота использования**: RDO была разработана для того, чтобы быть более простой в использовании, чем прямое обращение к ODBC, и более эффективной, чем DAO, которая была ориентирована на локальные базы данных.

- **Поддержка ODBC**: RDO использует ODBC для подключения к различным источникам данных, что позволяет работать с различными типами баз данных через единый интерфейс

Преимущества:

- **Упрощенный доступ**: RDO предлагает более простой интерфейс для работы с базами данных по сравнению с прямым использованием ODBC.

- **Эффективность**: Была разработана для обработки данных на стороне сервера, что делало ее более эффективной для удаленных баз данных.

Недостатки:

- **Устаревшая технология**: RDO в настоящее время считается устаревшей и не рекомендуется для новых проектов.

- **Ограниченная поддержка**: Последняя версия RDO была выпущена в 1997 году, и с тех пор технология не развивается.

Фактически, последняя версия RDO — это RDO 2.0, также известная как «ODBC Direct», которая была выпущена в 1997 году в составе Microsoft Office 97. ODBCDirect, стала расширением DAO, которое отодвигает RDO на задний план. На DAO-приложение, используя ODBCDirect, обращается к базе данных, минуя проблемы, которые вызывает JET.

С 1996 года Microsoft начала продвигать новую технологию ADO (ActiveX Data Objects), которая стала более перспективной и универсальной для доступа к данным. Это привело к снижению популярности RDO. В целом, RDO была важной технологией в свое время, но в настоящее время заменена более современными и эффективными решениями, такими как ADO и ADO.NET.

### Технология OLE DB
Спустя несколько лет ODBC становится стандартом для клиент-серверного доступа к базам данных. ODBC обеспечивает стандартный интерфейс, который требует функций SQL и оптимизирован под методы SQL. Однако что произойдет, если нужно будет обратиться к нереляционной базе данных, в которой не используются принципы SQL (например, Microsoft Exchange Server, хранилище которого не содержит данные реляционно)?

В начале 1990-x корпорация Microsoft представила OLE DB – объектно-ориентированный интерфейс для доступа к базам данных. Технология OLE DB пришла на смену ODBC, с тем, чтобы устранить её недостатки.

<dfn title="OLE DB">OLE DB</dfn> — это набор интерфейсов на основе технологии COM (Component Object Model), разработанный компанией Microsoft для обеспечения унифицированного доступа к различным источникам данных. Он позволяет приложениям работать с данными из различных хранилищ, включая реляционные базы данных (например, SQL Server, Oracle), нереляционные базы данных, электронные таблицы (например, Excel), файловые системы и электронную почту

**Технология OLE DB** (от англ. Object Linking and Embedding DataBase – механизм доступа к базам данных с помощью технологии OLE) представляет собой набор СОМ-интерфейсов, обеспечивающих универсальный доступ приложений к базам данных и другим хранилищам информации (в том числе и нереляционным —  файловым системам, системам электронной почты и др.), в которых результатом запросов является информация, представленная в табличной форме.

Цели создания OLE DB:

*[VSAM]: Virtual Storage Access Method
1. Создание объектных интерфейсов для элементов функциональности СУБД – запрос, обновление, управление транзакциями.

2. Увеличение гибкости:
   - дать потребителям данных возможность использовать только те объекты, которые им нужны.
   - дать поставщикам данных возможность открывать доступ к элементам функциональности СУБД.
   - обеспечить возможность доступа к функциональности с помощью множества различных интерфейсов.
   - сделать эти интерфейсы стандартизированными и расширяемыми.

3. Создание объектных интерфейсов для любых типов данных: реляционных баз данных (через ODBC или собственные интерфейсы СУБД), нереляционных баз данных, систем обработки файлов (VSAM и др.),  электронной почты и т.п.

4. Реализация стратегии, при которой данные не должны преобразовываться в другие форматы или перемещаться из того места, где они находятся.

Основные компоненты OLE DB:
- **Поставщики данных**: Это компоненты, которые реализуют интерфейсы OLE DB для конкретных источников данных. Они обеспечивают доступ к данным и форматируют их в виде наборов строк.

- **Потребители данных**: Это приложения, которые используют OLE DB для доступа к данным. Потребители взаимодействуют с поставщиками через стандартизированные COM-интерфейсы.

- **Объекты OLE DB**: Включают источник данных (`DataSource`), сессию (`Session`), команду (`Command`) и набор строк (`Rowset`). Эти объекты обеспечивают абстракцию для взаимодействия с различными хранилищами данных

Преимущества OLE DB:
- **Универсальный доступ**: Позволяет работать с различными типами данных, включая реляционные и нереляционные базы данных, электронные таблицы и файловые системы.

- **Расширяемость**: Поставщики OLE DB могут реализовывать дополнительные интерфейсы и функции, не описанные в стандартной спецификации.

- **Высокая производительность**: OLE DB обеспечивает эффективный доступ к данным, особенно для нереляционных источнико

Применение OLE DB:

*[ETL]: Extract, Transform, Load
- **Корпоративные приложения**: Используется для доступа к различным источникам данных в корпоративных системах.

- **Системы ETL**: Используется для извлечения и экспорта данных в различные базы данных. ETL — это общий термин для процессов, которые происходят, когда данные переносят из нескольких систем в одно хранилище. Аббревиатура расшифровывается как Extract, Transform, Load, или «извлечение, преобразование, загрузка». Именно это происходит с файлами в процессе переноса.

Сравнение с ODBC:
- **Поддержка источников данных**: OLE DB поддерживает более широкий круг источников данных, включая нереляционные базы данных и файловые системы.

- **Интерфейсы**: OLE DB использует COM-интерфейсы, в то время как ODBC основан на стандартизированном API.

В целом, OLE DB — это мощная технология для обеспечения унифицированного доступа к различным источникам данных, но в настоящее время считается устаревшей и замененной более современными решениями, такими как ADO.NET и OLE DB для .NET.

#### Суть OLE DB
Рассмотрим OLE DB. Технология OLE DB построена на ODBC и расширяет ее до компонентной архитектуры, которая обеспечивает высокоуровневый интерфейс доступа к данным. Эта архитектура предоставляет постоянный доступ к SQL-данным, не SQL-данным и неструктурированным источникам данных по локальным сетям и Internet. В действительности для доступа к SQL-данным OLE DB использует ODBC, потому что это самая подходящая архитектура для работы с SQL. На Рисунке 5 показано, что OLE DB состоит из трех компонентов: потребителя данных (например, приложения); поставщика (провайдера) данных, который содержит и предоставляет данные; служебного компонента, который обрабатывает и транспортирует данные (в частности, процессоры запросов, процессоры курсоров). OLE DB — это единый API, который обрабатывает как совместимые с SQL источники данных, так и несовместимые, такие, как почта и каталоги.

#### Основные понятия OLE DB
OLE DB представляет собой набор COM-интерфейсов, которые предоставляют приложению-клиенту унифицированный доступ к различным  источникам данных. А именно: OLE DB разбивает всю совокупность возможностей и функций СУБД на отдельные фрагменты – COM-объекты с узкой специализацией. Одни объекты выполняют запросы, другие производят обновление, третьи создают структурные  элементы базы данных – таблицы, индексы и представления, четвёртые занимаются управлением транзакциями – например, устанавливают оптимистическую блокировку.

OLE DB – это метод доступа к любым данным, вне зависимости от типа данных и места их расположения. В качестве данных могут выступать реляционные и не реляционные базы данных, картинки, аудиофайлы, электронная почта и другие источники данных.

Средства, предоставляющие доступ к источнику данных с использованием технологии OLE DB, называются OLE DB **провайдерами**. Программы-клиенты, использующие для доступа OLE DB провайдеры, называются **потребителями данных**. В случае, если существует только ODBC-драйвер для доступа к конкретному источнику данных, то для применения технологии OLE DB можно использовать OLE DB провайдер, предназначенный для доступа к ODBC-источнику данных.

Характерной особенностью механизма OLE DB является то, что данные, возвращаемые OLE DB приложению, представляют собой не просто массив информации, а СОМ-объект, обладающий, помимо самой информации, методами управления этой информацией (например, фильтрация и сортировка). Логическая схема доступа к данным с помощью OLE DB представлена на рис. 3.

Приложение, называемое потребителем данных, обращается к поставщику данных, который перенаправляет запрос от приложения к базе данных, либо обрабатывает запрос самостоятельно. Таким образом, поставщик данных аналогичен драйверам ODBC. Механизм OLE DB имеет доступ к ODBC, поддерживая, таким образом, большое количество драйверов, реализованных для ODBC.

#### Объектная модель OLE DB
Спецификация OLE DB определяет набор интерфейсов базового уровня, которые должны реализовываться любыми OLE DB провайдерами. В базовую модель OLE DB входят следующие объекты:
- объект `DataSource` (источник данных), используемый для соединения с источником данных и создания одного или нескольких сеансов. Этот объект управляет соединением, использует информацию о полномочиях и аутентификациях[^аутентификация] пользователя.

- объект `Session` (сеанс) управляет взаимодействием с источником данных – выполняет запросы и создаёт результирующие наборы. Сеанс также может возвращать метаданные[^метаданные]. В сеансе может создаваться одна или несколько команд.

- Спецификация OLE DB определяет объект `Command` (команда), предназначенный для выполнения текстовой команды. В качестве такой команды может выступать и SQL-оператор. При  этом выполнение команды может создавать результирующий набор (в случае SQL-оператора – это оператор SELECT).
- Представление (`View`) определяет группу столбцов из набора данных, но само не содержит их. Представления не могут объединять данные из нескольких наборов таблиц, подмножество строк.

[^аутентификация]: <dfn title="аутентификация">Аутентификация</dfn> (Authentication) — процедура проверки соответствия некоего лица и его учетной записи в компьютерной системе. В простейшем случае проверка происходит с помощью пароля.

[^метаданные]: <dfn title="метаданные">Метаданные</dfn>: <ul><li>информация о данных.</li><li>информация об информации.</li><li>структурированные данные, представляющие собой характеристики описываемых сущностей для целей их идентификации, поиска, оценки, управления ими.</li><li>данные из более общей формальной системы, описывающей заданную систему данных.</li></ul>

OLE DB провайдеры, как и все COM-компоненты, регистрируются в реестре Windows. Для поиска информации о зарегистрированных источниках данных используются специальные объекты, называемые нумераторами. <dfn title="нумератор">Нумератор</dfn> — это обычный СОМ-сервер, позволяющий получить информацию об источниках данных в виде результирующего набора. Для создания такого результирующего набора в объектном типе `DataSource` специфицирован интерфейс `IDBEnumerateSources`.

Для каждого объектного типа спецификация OLE DB определяет набор интерфейсов, который должен обязательно быть реализован для данного объекта. Такие интерфейсы отмечаются как `[mandatory]`. Интерфейсы, которые могут отсутствовать, отмечаются как `[optional]`.

#### Доступ к OLE DB
Будучи COM-интерфейсом, OLE DB непосредственно доступен из C++, C# и Java, но недоступен из Visual Basic и сценарных языков. Поэтому, чтобы использовать OLE DB из любых языков программирования, необходимо использовать объектный интерфейс ADO.

### Технология ADO
OLE DB обеспечивает связывание для программистов на С и C++, а также программистов, использующих языки с С-подобными вызовами функций. Такие языки, как VB и VBScript, не поддерживают тип данных «указатель» (адресных переменных). Следовательно, они не могут использовать связывание в стиле С и прямое обращение к OLE DB.

*[ADO]: ActiveX Database Objects
Вероятно, для большей путаницы разработчики Microsoft ввели еще одну объектную модель доступа к данным: ADO. <dfn title="ADO">ADO</dfn> (<dfn title="ActiveX Data Objects">ActiveX Data Objects</dfn>) — это технология, разработанная компанией Microsoft для обеспечения доступа к различным источникам данных. Она является частью архитектуры MDAC (Microsoft Data Access Components) и предоставляет высокоуровневый интерфейс для работы с данными на основе технологии COM (Component Object Model).

ADO работает с объектами DAO и RDO, а также поддерживает более простые модели, чем DAO и RDO (хотя с избыточной функциональностью, так что можно выполнить операцию несколькими способами). Объектная иерархия в ADO более однородная, чем в DAO. ADO содержит несколько встроенных объектов, которые упрощают доступ к данным из информационных хранилищ.

<dfn title="ActiveX">ActiveX</dfn> – это фреймворк от Microsoft, используемый для создания программных компонентов, которые могут применяться в различных языках программирования. Технология позволяет интегрировать интерактивные функции на веб-страницы для улучшения взаимодействия с пользователем. ActiveX – технология, на основе которой создаются компоненты для программирования сайтов под Internet Explorer. К настоящему времени ActiveX считается устаревшей технологией, которую не следует использовать для новых разработок. Многие возможности элементов activeX можно выполнять проще и более безопасно с помощью современных технологий, таких как HTML5 и JavaScript, современные расширения браузера или модули WebAssembly.

<dfn title="Технология ADO">Технология ADO</dfn> (от англ. ActiveX Database Objects – механизм доступа к базам данных через объекты ActiveX) – технология доступа к данным, разработанная Microsoft, является надстройкой над механизмом доступа OLE DB и предназначена для унификации работы с поставщиками данных OLE DB. Обеспечивает удобный и надежный доступ к данным, хотя и несколько более медленный, чем в технологиях BDE и dbExpress. Хорошо подходит для работы с системами управления базами данных (СУБД) от фирмы Microsoft (MS Access, MS SQL Server), поскольку не требует дополнительных компонентов (библиотек, драйверов), так как они уже есть на компьютере пользователя.

Механизм ADO предоставляет несколько основных СОМ-объектов, используемых для получения и управления информацией (имеются дополнительные СОМ-объекты, расширяющие функциональность ADO):

- **`Connection`**: Представляет подключение к источнику данных для управления соединением с базой данных и передачи запросов поставщику данных.

- **`Recordset`**: Представляет набор строк, полученный от источника данных. Объект, содержащий таблицу, которая является результатом запроса к базе данных.

- **`Command`**: Используется для выполнения команд и SQL-запросов с параметрами, для управления информацией о запросе к базе данных или команде.

- **`Record`**: Может представлять одну запись объекта `Recordset` или иерархическую структуру текстовых данных.

- **`Stream`**: Используется для чтения и записи потоковых данных.

- **`Field`**: Объект, содержащий описание поля в таблице, возвращенной поставщиком данных. Список всех полей таблицы содержится в подобъекте `Fields` объекта `RecordSet`

- **`Fields`**: Представляет столбцы таблицы базы данных.

- **`Error`**: Объект, содержащий расширенную информацию об ошибке, о которой сообщил поставщик данных. Если ошибок несколько, доступ к ним можно получить с помощью объекта `Errors`.

- **`Errors`**: Представляет ошибки.

- **`Parameters`**: Представляет набор параметров SQL-инструкции.

- **`Properties`**: Представляет набор свойств объекта.

Существует несколько способов, с помощью которых приложение связывается с базой данных. Например, VB-программист может использовать ADO для соединения приложения с провайдером OLE DB. Если база данных не поддерживает OLE DB, приложение может задействовать ODBC. Программист на Visual C++ может применять ADO или соединяться напрямую через OLE DB.

Преимущества ADO:
- **Универсальность**: Позволяет работать с различными источниками данных, включая реляционные базы данных, текстовые файлы и другие.

- **Простота использования**: Предоставляет простой и интуитивно понятный интерфейс для доступа к данным, что делает его удобным для разработчиков на языках высокого уровня, таких как Visual Basic.

- **Независимость от источника данных**: Использует провайдеры данных для подключения к различным базам данных, что упрощает разработку приложений.

Применение ADO:
- **Microsoft Access** и **SQL Server**: Часто используется для доступа к этим базам данных.

- **ASP** и **VBScript**: Используется в веб-приложениях и скриптах.

- **Delphi**: Поддерживается в среде Delphi для доступа к данным.

ADO в основном используется в старых приложениях и системах. В рамках платформы .NET он заменен на ADO.NET, который обеспечивает более современный и эффективный интерфейс для работы с данными. ADO.NET поддерживает как реляционные, так и нереляционные базы данных и обеспечивает лучшую производительность и масштабируемость.

### Платформа .NET
Платформа .NET была создана компанией Microsoft в начале 2000-х годов в ответ на набирающую популярность платформу Java от Sun Microsystems. Основные причины и предпосылки создания .NET включают:

- **Унификация сред разработки**: В то время у Microsoft было множество различных сред разработки для разных языков программирования (например, Visual Basic и C++). .NET была призвана объединить эти среды в одну платформу, обеспечивая унифицированный набор инструментов и библиотек для различных языков, таких как C#, Visual Basic и C++.

- **Объектно-ориентированность и безопасность**: .NET была разработана с учетом современных тенденций в программировании, включая поддержку объектно-ориентированного программирования, безопасность типов, сборку мусора и структурную обработку исключений.

- **Конкуренция с Java**: .NET была создана как ответ на платформу Java, которая набирала популярность в то время. Microsoft хотела предложить альтернативу, ориентированную на операционные системы Windows.

- **Поддержка веб-служб и распределенных приложений**: .NET была задумана как платформа для создания и выполнения веб-служб и приложений Windows, с учетом распределенных систем и Интернета.

- **Упрощение разработки и развертывания**: .NET обеспечивает среду, в которой минимизирована вероятность конфликтов при развертывании программного обеспечения и управлении его версиями. Это упрощает разработку и поддержку приложений.

В целом, создание .NET было обусловлено необходимостью унифицировать среды разработки, обеспечить современные возможности программирования и конкурировать с другими платформами, такими как Java.

**.NET** – это кросплатформенная среда выполнения приложений. Проще говоря – это то, что позволяет запускаться нашим приложениям в системе.

**.Net Framework** – это набор уже скомпилированных библиотек, откуда берутся методы и функции для запуска и разработки приложений. В разработке нам придётся просто вызвать уже готовую функцию для того чтобы она заработала.

Язык C# используется всего лишь для описания команд и инструкций, но используя возможности .Net Framework позволяет создавать приложения разного типа.

Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире.

#### Особенности .NET
Фреймворк .NET представляет мощную платформу для создания приложений. Можно выделить следующие ее основные черты:

*[CLR]: Common Language Runtime
*[CIL]: Common Intermediate Language
- **Поддержка нескольких языков** – C#, C++, F# и др. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), благодаря чему .NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы .NET. Поэтому при определенных условиях мы можем сделать отдельные модули одного приложения на отдельных языках.

- **Кроссплатформенность** – можно разрабатывать приложения на языке C# для самых разных платформ - Windows, MacOS, Linux, Android, iOS. .NET является переносимой платформой (с некоторыми ограничениями). Например, последняя версия платформы на данный момент — .NET 7 поддерживается на большинстве современных ОС Windows, MacOS, Linux. Используя различные технологии на платформе .NET, можно разрабатывать приложения на языке C# для самых разных платформ — Windows, MacOS, Linux, Android, iOS, Tizen. Стоит также упомянуть аппаратную кроссплатформенность (x86, x64, arm).

- **Мощная библиотека классов** – позволяет создавать приложения разного типа. .NET представляет единую для всех поддерживаемых языков библиотеку классов. И какое бы приложение мы не собирались писать на C# — текстовый редактор, чат или сложный веб-сайт — так или иначе мы задействуем библиотеку классов .NET.

- **Разнообразие технологий**. Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, для работы с базами данных в этом стеке технологий предназначена технология ADO.NET и Entity Framework Core. Для построения графических приложений с богатым насыщенным интерфейсом — технология WPF и WinUI, для создания более простых графических приложений — Windows Forms. Для разработки кроссплатформенных мобильных и десктопных приложений — Xamarin/MAUI. Для создания веб-сайтов и веб-приложений — ASP.NET и т.д.

- **Производительность**. Согласно ряду тестов веб-приложения на .NET 7 в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий. Приложения на .NET 7 в принципе отличаются высокой производительностью.

Также еще следует отметить такую особенность языка C# и фреймворка .NET, как автоматическая сборка мусора. А это значит, что нам в большинстве случаев не придется, в отличие от С++, заботиться об освобождении памяти. Вышеупомянутая общеязыковая среда CLR сама вызовет сборщик мусора и очистит память.

##### CIL и CLR

*[CIL]: Common Intermediate Language
*[CLR]: Common Language Runtime

В программировании на .Net компиляция и запуск приложений происходит следующим образом:
- Код из любого языка преобразовывается в код, написанный на общем языке (Common Intermediate Language или CIL). Этот язык является языком низшего уровня, похожего по синтаксису на язык ассемблер.
- После, этот код передаётся так называемой исполняющей среде (Common Language Runtime или CLR), которая берёт функции и методы из .Net Framework и управляет нашим приложением.
- После этого конечный результат передаётся на процессор и выполняется программа.

![CIL и CLR](./img/CIL-CLR.png "CIL и CLR")

*[JIT]: Just In Time
*[IL]: Intermediate Language
CLR идёт вместе с .Net и является его частью. Используется для выполнения кода, написанного на платформе .Net. Код, сформированный компилятором в CIL (IL) выполняется CRL. В процессе работы происходит JIT (just in time) компиляция, которая компилирует IL код, в код, понятный компьютеру.

Кроме того, CRL отвечает за работу с потоками, осуществляет оптимизацию кода и многое другое.

При этом CRL не привязан строго к процессу разработки. Это о том, что CRL в целом используется для запуска .Net приложений.

##### .NET Framework и .NET
Стоит отметить, что .NET долгое время развивался премущественно как платформа для Windows под названием .NET Framework. В 2019 вышла последняя версия этой платформы — .NET Framework 4.8. Она больше не развивается

С 2014 Microsoft стал развивать альтернативную платформу — .NET Core, которая уже предназначалась для разных платформ и должна была вобрать в себя все возможности устаревшего .NET Framework и добавить новую функциональность. Затем Microsoft последовательно выпустил ряд версий этой платформы: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. И текущей версией является расматриваемая в этом руководстве платформа .NET 9. Поэтому следует различать .NET Framework, который предназначен преимущественно для Windows, и кросплатформенный .NET 9.

##### Управляемый и неуправляемый код
Нередко приложение, созданное на C#, называют <dfn title="управляемый код">управляемым кодом</dfn> (managed code). Что это значит? А это значит, что данное приложение создано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память. Но есть также приложения, например, созданные на языке С++, которые компилируются не в общий язык CIL, как C#, VB.NET или F#, а в обычный машинный код. В этом случае .NET не управляет приложением.

В то же время платформа .NET предоставляет возможности для взаимодействия с неуправляемым кодом.

##### JIT-компиляция
Код, написанный на C# (или других языках) обрабатывается компилятором, который идёт вместе с .Net. Хотя таких компиляторов может быть много. Кроме стандартного компилятора, есть Roslyn, например.

Как выше писалось, код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения происходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и содержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если мы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения работы программы. В итоге это повышает производительность.

#### Работа с базами данных в .NET Framework
Работа с базами данных повсеместно встречается в современных приложениях, будь то настольное приложение, веб-сайт или веб-служба. Естественно платформа .NET Framework предлагает множество способов взаимодействия с базами данных из управляемого кода, которые и описываются в данном разделе. Основной системой управления базами данных для Windows являтся SQL Server.

Как и следовало ожидать, платформа .NET определяет ряд пространств имен, которые позволяют непосредственно взаимодействовать с локальными и удаленными базами данных. Вместе эти пространства имен известны как ADO.NET. Существует два базовых уровня работы с ADO.NET: ***подключенный уровень*** (***connected layer***) — позволяет взаимодействовать с базой данных с помощью объектов подключения, чтения данных и команд конкретного поставщика данных; ***отключенный уровень*** (***disconnected layer***) — позволяет смоделировать в памяти данные из базы данных с помощью многочисленных классов из пространства имен `System.Data` (`DataSet`, `DataTable` и т.д.). Кроме того, существует возможность взаимодействия с базой данных через объектную модель C#, с помощью ORM-фреймворка ***Entity Framework***.

- **ADO.NET**

    Платформа .NET Framework включает собственную технологию доступа к данным — ADO.NET. Эта технология состоит из управляемых классов, позволяющих приложениям .NET подключаться к источникам данных (обычно реляционным базам данных), выполнять команды и управлять автономными данными. Маленькое чудо ADO.NET заключается в том, что эта технология позволяет писать более-менее одинаковый код для доступа к данным — как в веб-приложениях, так и в клиент-серверных настольных приложениях, и даже в однопользовательских приложениях, подключаемых к локальной базе данных.

- **Entity Framework 6**

    API-интерфейс Entity Framework спроектирован для работы с любыми базами данных, поддерживающими ADO (а не только с SQL Server), и даже включает собственный диалект независимого от поставщика языка SQL, который можно применять в качестве альтернативы LINQ.

- **SQL Server 2012 и язык T-SQL**

    Система управления базами данных SQL Server является наилучшим выбором для широкого диапазона конечных пользователей и программистов баз данных, работающих над созданием бизнес-приложений. В целом, SQL Server является больше, чем просто системой управления реляционными базами данных. Это платформа, которая не только позволяет управлять структурированными, полуструктурированными и неструктурированными данными, но также предоставляет комплексное, интегрированное системное программное обеспечение и программное обеспечение для аналитических исследований, которые позволяют организациям надежно управлять критически важными данными.

- **Оконные функции T-SQL**

    Одним из самых фундаментальных расширений языка SQL в Microsoft SQL Server 2005 стало добавление оконных функций с такими синтаксическими конструкциями, как предложение `OVER` и набор новых функций, известных как функции ранжирования (`ROW_NUMBER`, `RANK`, и других). В отличие от обычных агрегатных функций, оконные функции не группируют строки в одну выходную строку, а добавляют результаты вычислений к каждой строке результирующей выборки как новое поле. Это позволяет сохранить уникальные идентификаторы строк и упростить выполнение аналитических расчетов. Это добавление позволило решать стандартные проблемы более простым, интуитивно понятным и отличающимся более высокой производительностью способом, чем раньше.

### Технология ADO.NET
Когда Microsoft начала разрабатывать .NET Framework, она имела хорошую возможность пересмотреть модель доступа к данным. Решив не продолжать разработку технологии ADO, специалисты Microsoft приступили к созданию новой структуры доступа к данным, при этом сохранив акроним. Microsoft разрабатывает ADO.NET на базе уже зарекомендовавшей себя объектной технологии ADO. Но ADO.NET ориентируется на три важные возможности, которые не поддерживаются ADO: 
- поддержка модели доступа к несвязанным данным, что является ключевым элементом для работы в Web;
- поддержка тесной интеграции с XML;
- интеграция с .NET Framework (например, совместимость с базовой библиотекой классов типичной системы).

<dfn title="ADO.NET">ADO.NET</dfn> — это технология, входящая в состав платформы .NET Framework, предназначенная для управления данными, хранящимися в различных источниках, включая базы данных и файлы. Она позволяет разработчикам создавать приложения, которые могут получать доступ к реляционным базам данных, обновлять и обрабатывать хранящуюся там информацию.

<dfn title="ADO.NET">ADO.NET</dfn> — это набор классов в платформе .NET Framework, предназначенный для доступа и управления данными из различных источников, включая реляционные базы данных, XML-файлы и другие. Он обеспечивает унифицированный интерфейс для работы с различными системами управления базами данных (СУБД).

Основные компоненты ADO.NET:
- **Поставщик данных** (**.NET Data Provider**): Это библиотека, которая подключается к конкретному источнику данных и обеспечивает доступ к нему. Примеры поставщиков данных включают SqlClient для SQL Server и OracleClient для Oracle.

- **Автономная модель** (**`DataSet`**): Представляет собой локальную копию данных, которая может быть изменена и синхронизирована с базой данных через `DataAdapter`. `DataSet` включает в себя `DataTable`, `DataRow`, `DataColumn` и `DataRelation`, что позволяет хранить и обрабатывать данные на стороне клиента.

- **`DataAdapter`**: Объект, который облегчает синхронизацию данных между `DataSet` и базой данных. Он используется для извлечения данных из базы данных и обновления базы данных с учетом изменений в `DataSet`.

Основные объекты ADO.NET:
- **`Connection`**: Устанавливает подключение к базе данных.

- **`Command`**: Выполняет SQL-запросы или хранимые процедуры.

- **`DataReader`**: Используется для чтения данных из базы данных построчно.

- **`DataSet`**: Хранит данные локально и позволяет обрабатывать их независимо от базы данных.

ADO.NET является преемником Microsoft ActiveX Data Objects (ADO). Это стандартизированная модель программирования для создания распределенных прикладных программ, нацеленных на совместное использование данных. Подобно ADO, ADO.NET является программным интерфейсом (API) для прикладного программного обеспечения, позволяющим обращаться к данным и другой информации. ADO.NET поддерживает такие современные требования, как создание клиентского интерфейса к базам данных на фронтальном уровне и на уровне промежуточного слоя объектов клиентских приложений, инструментальных средств, языков программирования или Internet браузера.

Технология ADO.NET разработана на основе промышленных стандартов. ADO.NET, подобно ADO, обеспечивает интерфейс доступа к OLE DB — совместимым источникам данных, таким, как Microsoft SQL Server. Прикладные программы, позволяющие пользователям совместно использовать данные, могут использовать ADO.NET для подключения к источниками данных, а также для поиска, управления, и модификации этих данных. Также, прикладные программы (далее ПП) могут использовать OLE DB для управления данными, хранящимися в не относительных форматах, таких, как Microsoft Excel.

В решениях, требующих офлайнового или удаленного доступа к данным, ADO.NET использует XML для обмена данными между программами или с Веб страницами. Любой компонент, который обслуживает XML, также может использовать и компоненты ADO.NET. Если передача пакетов компонентом ADO.NET подразумевает поставку набора данных в файле XML, компонентом, способным обеспечить его получение, может быть только компонент ADO.NET. Передача данных в XML-формате даёт возможность программистам легко отделить обработку данных от компонент пользовательского интерфейса data-sharing ПП, разместив их на отдельных серверах. Это может существенно повысить эффективность и надёжность многопользовательских систем.

Для распределенных ПП, использование наборов данных XML в ADO.NET обеспечивает лучшую эффективность, чем использование COM для офлайнового обслуживания данных в ADO. Поскольку передача наборов данных происходит через файлы XML, описанные в очень простом, принятом повсюду стандарте и являющиеся (по сути) обычными текстовыми файлами, компоненты ADO.NET не имеют ни одного из архитектурных ограничений COM. Наборы данных XML, используемые в ADO.NET избавлены также от необходимости конвертации данных в рекордсете для получения типов данных, применимых в COM. Фактически, любые два компонента могут совместно использовать наборы данных XML при условии, что они оба используют ту же самую схему форматирования набора данных XML.

ADO.NET обладает хорошей масштабируемостью, что требуется для совместно использующих данные ПП, работающих на основе Веб. Такие Веб-программы могут обслужить десятки, сотни, а то и тысячи пользователей. ADO.NET не применяет длительные блокировки баз данных или такие активные подключения, которые на долгое время монополизируют ресурсы сервера, являющимися (как правило) весьма ограниченными. Это позволяет увеличивать число пользователей без значительного увеличения утилизации ресурсов системы.

Преимущества ADO.NET:
- **Универсальность**: Поддерживает различные источники данных.

- **Отсоединенная модель**: Позволяет работать с данными локально, не требуя постоянного подключения к базе данных.

- **Управляемый код**: Использует протокол управления памятью CLR, что делает его безопасным и эффективным.

ADO.NET широко используется в различных типах приложений, включая веб-приложения ASP.NET, консольные приложения и настольные приложения Windows. Он обеспечивает гибкий и эффективный способ работы с данными в приложениях .NET.

В целом, ADO.NET является важной частью платформы .NET и позволяет разработчикам создавать приложения, которые могут взаимодействовать с различными источниками данных, используя единый и удобный интерфейс.

#### Обзор ADO.NET
***ADO.NET*** — нечто большее, чем надстройка над каким-нибудь существующим API-интерфейсом. Сходство с ADO минимально; классы и методы доступа к данным довольно существенно отличаются.

*[ADO]: ActiveX Data Objects
<dfn title="ADO">ADO</dfn> (<dfn title="ActiveX Data Objects">ActiveX Data Objects</dfn>) — это библиотека компонентов СОМ, получившая в последние несколько лет множество воплощений. ADO состоит, прежде всего, из объектов Connection, Command, Recordset и Field. С помощью ADO открывается соединение с базой данных, после чего некоторые данные извлекаются и помещаются в набор записей, состоящих из полей; эти данные затем претерпевают манипуляции и обновления на сервере, после чего соединение закрывается. Кроме того, ADO предлагает так называемый *отключенный набор записей* (*disconnected record set*), который используется, когда соединение с базой нежелательно удерживать открытым в течение длительного времени.

Существует несколько проблем, которые ADO не решает удовлетворительным образом. Наиболее заметная из них — громоздкость (в плане физического размера) отключенного набора записей. Потребность в этом средстве возрастает по мере развития веб-ориентированных вычислений, поэтому в данном случае понадобился свежий подход. Переход от ADO к ADO.NET не должен быть слишком трудным, поскольку между этими технологиями все же имеется некоторое сходство.

Более того, если вы используете SQL Server, существует замечательный набор управляемых классов, которые настроены на обеспечение максимальной производительности базы данных. Одного этого достаточно для перехода на ADO.NET.

*[ODBC]: Open Database Connectivity
ADO.NET поставляется с тремя пространствами имен клиента базы данных: одно для **SQL Server**, другое для источников данных **Open Database Connectivity** (**ODBC**) и третье для любой базы данных, доступной через **OLE DB**. Если выбрана база данных, отличная от SQL Server, отдавайте предпочтение OLE DB, если только не окажется, что нет другого выбора кроме ODBC. Если в качестве базы данных используется Oracle, можете посетить сайт Oracle .NET Developer и получить там их поставщика .NET — ODP.NET на странице www.oracle.com/technology/tech/windows/odpnet/index.html.

С точки зрения программиста, тело ADO.NET составляет базовая сборка с именем **`System.Data.dll`**. В этом двоичном файле находится значительное количество пространств имен, многие из которых представляют типы конкретного поставщика данных ADO.NET.

Большинство шаблонов проектов Visual Studio 2010 автоматически ссылаются на эту ключевую библиотеку доступа к данным. Однако для импортирования нужных пространств имен необходимо изменить кодовые файлы, например:
```cs
using System;
using System.Data;
using System.Data.SqlClient;
```

Учтите также, что кроме `System.Data.dll`, существуют и другие ориентированные на ADO.NET сборки (например, `System.Data.OracleClient.dll` и `System.Data.Entity.dll`), которые необходимо вручную указывать в текущем проекте с помощью диалогового окна *Add Reference* (Добавление ссылки).

##### Три стороны ADO.NET
Библиотеки ADO.NET можно применять тремя концептуально различными способами: в подключенном режиме, в автономном режиме и с помощью технологии Entity Framework. При использовании **подключенного уровня** (**connected layer**), кодовая база явно подключается к соответствующему хранилищу данных и отключается от него. При таком способе использования ADO.NET обычно происходит взаимодействие с хранилищем данных с помощью объектов подключения, объектов команд и объектов чтения данных.

**Автономный уровень** (**disconnected layer**), позволяет работать с набором объектов `DataTable` (содержащихся в `DataSet`), который представляет на стороне клиента копию внешних данных. При получении `DataSet` с помощью соответствующего объекта адаптера данных подключение открывается и закрывается автоматически. Понятно, что этот подход помогает быстро освобождать подключения для других вызовов и повышает масштабируемость систем.

Получив объект `DataSet`, вызывающий код может просматривать и обрабатывать данные без затрат на сетевой трафик. А если нужно занести изменения в хранилище данных, то адаптер данных (вместе с набором операторов SQL) задействуется для обновления данных — при этом подключение открывается заново для проведения обновлений в базе, а затем сразу же закрывается.

*[EF]: Entity Framework
После выпуска .NET 3.5 SP1 в ADO.NET появилась поддержка нового API, которая называется **Entity Framework** (сокращенно EF). Технология EF показывает, что многие низкоуровневые детали работы с базами данных (например, сложные SQL-запросы) скрыты от программиста и отрабатываются за него при генерации соответствующего LINQ-запроса (например, LINQ с Entities).

#### Архитектура и принцип работы ADO.NET
В ADO.NET используется многоуровневая архитектура, которая обращается вокруг небольшого числа ключевых концепций, таких как объекты `Connection`, `Command` и `DataSet`. Однако архитектура ADO.NET серьезно отличается от классической архитектуры ADO.

Объект `Recordset`, который выполняет так много функций в ADO, здесь отсутствует. Вместо него в ADO.NET предусмотрено несколько особых объектов, выполняющих специфические задачи. Три важнейших из них: `DataAdapter`, `DataReader` и `DataSet`.

Очень важный компонент ADO.NET, поставщик (провайдер) данных .NET, реализует интерфейсы ADO.NET. В частности, он реализует объект `DataReader` так, что его могут использовать и приложение, и объект `DataSet`.

Поставщик данных .NET состоит из четырех основных компонентов: `Connection` — для связи с источником данных; `Command` выполняет команды над источником данных; `DataReader` читает данные из источника данных в однонаправленном режиме «только чтение», и `DataAdapter`, который читает данные из источника данных и использует их для заполнения объекта `DataSet`.

Visual Studio .NET содержит два поставщика данных .NET.
*[TDS]: Tabular Data Stream

- *Поставщик данных SQL Server .NET* обеспечивает связь с SQL Server 7.0 и более поздними версиями. Этот метод доступа наиболее эффективен для SQL Server 7.0 и выше, потому что поставщик данных SQL Server .NET связывается напрямую с SQL Server через протокол Tabular Data Stream (TDS).
- *Поставщик данных OLE DB .NET* необходим для соединения с отличными от SQL Server базами данных, такими, как Oracle или IBM DB2. Этот поставщик данных использует OLE DB для соответствующих баз данных.

Существуют различные пути, по которым приложение может связываться с базой данных через ADO.NET. При выборе пути сначала определяется, какой поставщик данных .NET будет использоваться. Если это SQL Server 7.0 или более поздняя версия, то подключается поставщик данных SQL Server.NET. Если база данных SQL Server 6.5 или отличная от SQL Server (например, Oracle), понадобится поставщик данных OLE DB .NET. Заметим, что можно задействовать поставщик данных OLE DB .NET для баз данных SQL 7.0 и выше, но тогда потеряется выигрыш в производительности, который дает прямое подключение к SQL Server через протокол TDS. Однако в этом неспецифическом способе есть свой плюс — мобильность, т. е. можно менять базы данных без модификации кода.

Далее необходимо определить, какую задачу требуется выполнить. Если надо просто прочитать и отобразить данные из источника данных, объекта Data Reader вполне достаточно. Но если предстоит манипулировать данными (например, редактировать или удалять), нужно использовать объект Data Set. Хотя задействовать этот объект следует только в случае необходимости, потому что он работает медленнее, чем Data Reader (Data Set использует Data Reader для заполнения таблиц).

##### Поставщики данных в ADO.NET
<dfn title="поставщик данных">Поставщик данных</dfn> (<dfn title="data provider">data provider</dfn>) — это набор классов ADO.NET, которые позволяют получать доступ к определенной базе данных, выполнять команды SQL и извлекать данные. По сути, поставщик данных — это мост между вашим приложением и источником данных.

В первом приближении поставщик данных можно рассматривать как набор типов, определенных в данном пространстве имен, который предназначен для взаимодействия с конкретным источником данных. Однако независимо от используемого поставщика данных, каждый из них определяет набор классов, обеспечивающих основную функциональность. В таблице ниже приведены некоторые общие основные объекты, их базовые классы (определенные в пространстве имен `System.Data.Common`) и основные интерфейсы (определенные в пространстве имен `System.Data`), которые они реализуют:

*Основные объекты поставщиков данных ADO.NET*

| Тип объекта | Базовый класс | Соответствующие интерфейсы       | Назначение                                                                                                                                                                                                                                 |
| ----------- | ------------- | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`Connection`**  | `DbConnection`  | `IDbConnection`                    | Позволяет подключаться к хранилищу данных и отключаться от него. Кроме того, объекты подключения обеспечивают доступ к соответствующим объектам транзакций                                                                                 |
| **`Command`**     | `DbCommand`     | `IDbCommand`                       | Представляет SQL-запрос или хранимую процедуру. Кроме того, объекты команд предоставляют доступ к объекту чтения данных конкретного поставщика данных                                                                                      |
| **`DataReader`**  | `DbDataReader`  | `IDataReader`, `IDataRecord`         | Предоставляет доступ к данным только для чтения в прямом направлении с помощью курсора на стороне сервера                                                                                                                                  |
| **`DataAdapter`** | `DbDataAdapter` | `IDataAdapter`, `IDbDataAdapter`     | Пересылает наборы данных из хранилища данных к вызывающему процессу и обратно. Адаптеры данных содержат подключение и набор из четырех внутренних объектов команд для выборки, вставки, изменения и удаления информации в хранилище данных |
| **`Parameter`**   | `DbParameter`   | `IDataParameter`, `IDbDataParameter` | Представляет именованный параметр в параметризованном запросе                                                                                                                                                                              |
| **`Transaction`** | `DbTransaction` | `IDbTransaction`                   | Инкапсулирует транзакцию в базе данных                                                                                                                                                                                                     |

Конкретные имена этих основных классов различаются у различных поставщиков (например, `SqlConnection`, `OracleConnection`, `OdbcConnection` и `MySqlConnection`), но все эти объекты порождены от одного и того же базового класса (в случае объектов подключения это `DbConnection`), который реализует идентичные интерфейсы (вроде `IDbConnection`). Поэтому если вы научитесь работать с одним поставщиком данных, то легко справитесь и с остальными.

В ADO.NET термин "объект подключения" на самом деле относится к конкретному типу, порожденному от `DbConnection`; объекта подключения "вообще" нет. То же можно сказать и об "объекте команды", "объекте адаптера данных" и т.д. По соглашению имена объектов в конкретном поставщике данных имеют префиксы соответствующей СУБД (например, `SqlConnection`, `OracleConnection`, `SqlDataReader` и т.д.).

Одной из ключевых идей, лежащих в основе модели поставщиков ADO.NET, является расширяемость. Другими словами, разработчики могут создавать собственные поставщики для патентованных источников данных. В действительности доступно множество подтверждающих это примеров, которые демонстрируют, как создавать настраиваемые поставщики ADO.NET, служащие оболочками для нереляционных хранилищ данных, таких как файловая система или служба каталогов. Некоторые независимые производители также продают собственные поставщики данных для .NET.

В рамках .NET Framework поставляется небольшой набор из четырех поставщиков:

- **SQL Server**

    Предоставляет оптимизированный доступ к базам данных SQL Server (версии 7.0 и выше).

- **OLE DB**

    Предоставляет доступ к любому источнику данных, который имеет драйвер OLE DB. Это включает базы данных SQL Server версий, предшествующих 7.0.

- **Oracle**

    Предоставляет оптимизированный доступ к базам данных Oracle (версии 8i и выше).

- **ODBC**

    Предоставляет доступ к любому источнику данных, имеющему драйвер ODBC.

*[ODP]: Oracle Data Provider
В версии .NET 4 поставщик Oracle объявлен устаревшим. И хотя он по-прежнему работает, в Microsoft рекомендуют применять вместо него для доступа к базам данных Oracle поставщик от стороннего производителя, такой как ODP.NET (Oracle Data Provider для .NET) производства Oracle, который доступен на веб-сайте http://www.oracle.com. Этот поставщик обеспечивает расширенную поддержку для специализированных типов данных Oracle, вроде LOB, временных меток и данных XML, а также обладает несколькими дополнительными средствами.

При выборе поставщика сначала пытайтесь найти встроенный поставщик .NET, который предназначен для имеющегося источника данных. Если таковой не найден, можно воспользоваться OLE DB при наличии драйвера OLE DB для источника данных.

Технология OLE DB существует уже много лет как часть ADO, поэтому для большинства источников данных предусмотрены драйверы OLE DB (включая SQL Server, Oracle, Access, MySQL и многие другие). В тех редких случаях, когда найти специализированный поставщик .NET или драйвер OLE DB не удается, можно обратиться к поставщику ODBC, который работает в сочетании с драйвером ODBC.

##### Стандартизация в ADO.NET
На первый взгляд может показаться, что ADO.NET предлагает фрагментированную модель, поскольку не включает обобщенного набора объектов, которые работали бы с множеством типов баз данных. В результате, когда вы переходите от одной реляционной СУБД к другой, приходится модифицировать код доступа к данным для использования другого набора классов.

Но даже несмотря на то, что разные поставщики данных .NET используют различные классы, все они некоторым образом стандартизированы. Точнее говоря, каждый поставщик основан на одном и том же наборе интерфейсов и базовых классов. Так, например, объект `Connection` реализует интерфейс `IDbConnection`, который определяет такие ключевые методы, как `Open()` и `Close()`. Подобная стандартизация гарантирует, что каждый класс `Connection` будет работать одинаковым образом и предоставит один и тот же набор ключевых свойств и методов.

*[TDS]: Tabular Data Stream
"За кулисами" различные поставщики используют совершенно разные низкоуровневые вызовы и API-интерфейсы. Например, поставщик данных SQL Server применяет патентованный протокол ***TDS*** (***Tabular Data Stream — поток табличных данных***) для взаимодействия с сервером. Преимущества этой модели не сразу очевидны, но весьма существенны:

- Поскольку каждый поставщик использует одни и те же интерфейсы и базовые классы, можно писать обобщенный код доступа к данным (с приложением небольших дополнительных усилий), работая с интерфейсами, а не классами поставщиков.

- Поскольку каждый поставщик реализован отдельно, он может использовать соответствующую оптимизацию (это отличается от модели ADO, где каждый вызов базы данных должен проходить через общий уровень, прежде чем достигнет лежащего в основе драйвера базы данных). Кроме того, специализированные поставщики могут добавлять нестандартные средства, которых не имеют другие поставщики (например, возможность SQL Sever выполнять XML-запросы).

ADO.NET также имеет другой уровень стандартизации — **`DataSet`**. Класс `DataSet` — это контейнер данных общего назначения, которые извлекаются из одной или более таблиц источника данных. `DataSet` полностью обобщен; другими словами, специализированные поставщики не определяют собственных специализированных версий класса `DataSet`.

Независимо от того, какой поставщик данных применяется, можно извлекать данные и помещать их в полностью автономный `DataSet` одинаковым образом. Это облегчает отделение кода, извлекающего данные, от кода, обрабатывающего их. В случае смены лежащей в основе базы данных придется изменить только код, извлекающий данные, но если используется `DataSet`, а информация имеет одну и ту же структуру, модифицировать способ ее обработки не понадобится.

##### Фундаментальные классы ADO.NET
Классы ADO.NET группируются в несколько пространств имен. Каждый поставщик имеет свое собственное пространство имен, а обобщенные классы вроде `DataSet` находятся в пространстве имен `System.Data`. Ниже описаны наиболее важные пространства имен для базовой поддержки ADO.NET:

- **`System.Data`**

    Содержит ключевые классы контейнеров данных, которые моделируют столбцы, отношения, таблицы, наборы данных, строки, представления и ограничения. Дополнительно содержит ключевые интерфейсы, которые реализованы объектами данных, основанными на соединениях

- **`System.Data.Common`**

    Содержит базовые, наиболее абстрактные классы, которые реализуют некоторые из интерфейсов из `System.Data` и определяют ядро функциональности ADO.NET. Поставщики данных наследуются от этих классов (`DbConnection`, `DbCommand` и т.п.), создавая собственные специализированные версии

- **`System.Data.OleDb`**

    Содержит классы, используемые для подключения к поставщику OLE DB, включая `OleDbCommand`, `OleDbConnection` и `OleDbDataAdapter`. Эти классы поддерживают большинство поставщиков OLE DB, но не те, что требуют интерфейсов OLE DB версии 2.5

- **`System.Data.SqlClient`**

    Содержит классы, используемые для подключения к базе данных Microsoft SQL Server, в том числе `SqlDbCommand`, `SqlDbConnection` и `SqlDbDataAdapter`. Эти классы оптимизированы для использования интерфейса TDS к SQL Server

- **`System.Data.OracleClient`**

    *[OCI]: Oracle Call Interface
    Содержит классы, необходимые для подключения к базе данных Oracle (версии 8.1.7 и выше), в том числе `OracleCommand`, `OracleConnection` и `OracleDataAdapter`. Эти классы используют оптимизированный интерфейс *OCI* (*Oracle Call Interface — Интерфейс вызовов Oracle*)

- **`System.Data.Odbc`**

    Содержит классы, необходимые для подключения к большинству драйверов ODBC, такие как `OdbcCommand`, `OdbcConnection`, `OdbcDataReader` и `OdbcDataAdapter`. Драйверы ODBC поставляются для всех видов источников данных и конфигурируются через значок *Data Sources* (*Источники данных*) панели управления

- **`System.Data.SqlTypes`**

    Содержит структуры, соответствующие встроенным типам данных SQL Server. Эти классы не являются необходимыми, но предоставляют альтернативу применению стандартных типов данных .NET, требующих автоматического преобразования

##### Автономный уровень
Работа с подключенным уровнем позволяет взаимодействовать с базой данных с помощью первичных объектов подключения, команд и чтения данных. Этот небольшой набор типов позволяет выбирать, вставлять, изменять и удалять записи (а также вызывать хранимые процедуры или выполнять другие операции над данными — например, операторы DDL для создания таблицы и DCL для назначения полномочий). Но вы увидели лишь половину ADO.NET, поскольку с помощью объектной модели ADO.NET можно работать и в *автономном режиме*.

Автономные типы позволяют эмулировать реляционные данные с помощью модели объектов, находящихся в памяти. Кроме простого моделирования табличных данных, состоящих из строк и столбцов, типы из `System.Data` позволяют воспроизводить отношения между таблицами, ограничения столбцов, первичные ключи, представления и другие примитивы баз данных. К смоделированным данным можно применять фильтры, отправлять запросы и сохранять (или загружать) данные в формате XML и двоичном формате. И все это можно делать, даже не подключаясь к СУБД (откуда и термин "автономный уровень") — достаточно загрузить данные из локального XML-файла или программным образом создать объект `DataSet`.

Автономные типы действительно можно использовать без подключения к базе данных, но все-таки обычно применяются подключения и объекты команд. Кроме того, используется и особый объект — <dfn title="адаптер данных">адаптер данных</dfn> (расширяющий абстрактный тип `DbDataAdapter`), который как раз поставляет и обновляет данные. Но в отличие от подключенного уровня, данные, полученные через адаптер данных, не обрабатываются с помощью объектов чтения данных. Вместо этого объекты адаптеров пересылают данные между вызывающим процессом и источником данных с помощью объектов `DataSet`.

Тип `DataSet` представляет собой контейнер для любого количества объектов `DataTable`, каждый из которых содержит коллекцию объектов `DataRow` и `DataColumn`. Объект адаптера данных конкретного поставщика данных автоматически обслуживает подключение к базе данных. Для повышения масштабируемости адаптеры данных держат подключение открытым минимально возможное время. Как только вызывающий процесс получит объект `DataSet`, вызывающий уровень полностью отключается от базы данных и остается с локальной копией удаленных данных.

Теперь в нем можно вставлять, удалять или изменять строки различных объектов `DataTable`, но физическая база данных не обновляется, пока вызывающий процесс явно не передаст `DataSet` адаптеру данных для обновления. По сути, объекты `DataSet` имитируют постоянное подключение клиентов, хотя на самом деле они работают с находящейся в памяти базой данных.

#### Сравнение ADO и ADO.NET
ADO.NET — эволюционное развитие ADO. Самый простой путь быстрого понимания преимуществ ADO.NET состоит в сравнении с ADO.

| Термин  | ADO  | ADO.NET |
-- | -- | --
Резидентное представление данных в памяти | Использует объект RecordSet, который напоминает отдельную таблицу. | Использует объект DataSet, который может содержать одну или более таблиц, представленных объектами DataTable
Отношения между множеством таблицами | Требует, чтобы запрос JOIN транслировал данные из объединяемых таблиц базы данных в отдельную, результирующую таблицу. | Поддерживает объект DataRelation, чтобы сопоставить строки в одном объекте DataTable со строками в другом объекте DataTable.
Инспектирование данных | Последовательное сканирование данных DataSet | Использует навигационную парадигму для непоследовательного доступа к строкам в таблице. Следует за отношениями, чтобы передвигаться от строк в одной таблице к соответствующим строкам в другой таблице.
Офлайновый доступ | Использует RecordSet, для которого типична поддержка соединения, представленная объектом Connection. Вы подключаетесь к базе данных посредством запросов к OLE DB провайдеру. | Подключается к базе данных посредством стандартизированных запросов к объекту DataSetCommand, который подключается к OLE DB провайдеру (а иногда, непосредственно к API, обеспечивающемуся СУБД).
Программируемость | Использует объект Connection, чтобы передать команды, адресуемые источникам данных, лежащим в основе конструкции данных. | Использует строгий формат программирования характеристик XML. Данные включают в себя собственные описатели, поэтому, имена элементов кода отражают реальные проблемы, решаемые кодом. Лежащие в основе конструкций данных типы таблиц, строки, и таблицы, делают код проще для понимания и написания.
Совместное использование офлайновый данных между уровнями или компонентами | Использует COM для передачи RecordSet в офлайне. Поддерживаются только те типы данных, которыми располагает стандарт COM. Требуется преобразование типов, которое отнимает системные ресурсы. | Передает DataSet с XML файлом. Формат XML не имеет никаких ограничений на типы данных и не требует никаких преобразований типов.
Передача данных через межсетевые экраны (firewalls) | Проблематично, потому что межсетевые экраны обычно конфигурируются так, чтобы предотвратить запросы системного уровня, которые используются в COM. | Поддерживается, потому что объекты DataSet, используемые ADO.NET, передают XML, разработанный на основе HTML, который может проходить через межсетевые экраны.
Масштабируемость | Блокировки баз данных и длительные, активные подключения к базам данных могут стать причиной коллизий и сильно ограничивать ресурсы базы данных. | Офлайновый доступ к базам данных без накладывания длительных блокировок или применения длительных, активных подключений к базе данных, существенно разгружает ресурсы базы данных.

### ADO.NET Entity Framework

<dfn title="Entity Framework">Entity Framework</dfn> (<dfn title="EF">EF</dfn>) — это набор технологий в ADO.NET, предназначенных для разработки приложений, ориентированных на данные. Он позволяет разработчикам работать с данными на более высоком уровне абстракции, используя объектно-реляционное сопоставление (ORM) для преобразования данных между объектами .NET и таблицами базы данных.

<dfn title="Entity Framework">Entity Framework</dfn> является продолжением технологии Microsoft ActiveX Data и предоставляет возможность работы с базами данных через объектно-ориентированный код C#. Этот подход предоставляет ряд существенных преимуществ: вам не нужно беспокоиться о коде доступа к данным, вам не нужно знать деталей работы СУБД SQL Server и синтаксиса языка запросов T-SQL, вместо этого вы работаете с таблицами базы данных как с классами C#, с полями этих таблиц — как со свойствами классов, а синтаксис SQL-запросов, который в ADO.NET раньше нужно было вставлять в код C# в виде команд, заменен на более удобный подход с LINQ. Entity Framework берет на себя обязанности по преобразованию кода C# в SQL-инструкции.

Основные компоненты и функции
- **Entity Data Model** (**EDM**): Это концептуальная модель, которая сопоставляет классы сущностей с реальными таблицами в базе данных. EDM состоит из трех уровней: концептуального, уровня хранилища и уровня сопоставления (маппинга).

- **Сущности и свойства**: Сущности представляют собой наборы данных, ассоциированных с определенным объектом. Каждая сущность имеет свойства, которые могут быть простыми типами данных или более сложными структурами.

- **Связи между сущностями**: Сущности могут быть связаны ассоциативными связями один-ко-многим, один-ко-одному и многие-ко-многим, подобно связям через внешние ключи в базе данных.

- **Запросы LINQ**: Entity Framework позволяет использовать LINQ для запросов данных из базы данных, что упрощает выборку и обработку данных.

При работе с Entity Framework вам предоставляются огромные возможности по созданию модели базы данных с помощью интегрированной среды разработки (IDE) Visual Studio. Начиная с версии Entity Framework 4.1 вам предоставляется три подхода по проектированию базы данных, из которых вы можете выбрать для себя подходящий:

- **Database-First**: Entity Framework создает набор классов на основе существующей базы данных.

    Подходит для проектировщиков баз данных — сначала вы создаете базу данных с помощью различных инструментов (например, SQL Server Management Studio), а затем генерируете EDMX-модель базы данных (предоставляет удобный графический интерфейс для взаимодействия с базой данных в виде диаграмм и объектную модель в виде классов C#). В данном случае вам нужно работать с SQL Server и хорошо знать синтаксис T-SQL, но при этом не нужно разбираться в C#.

- **Model-First**: Разработчик создает модель базы данных, а затем Entity Framework создает реальную базу данных на сервере.

    Подходит для архитекторов — сначала вы создаете графическую модель EDMX в Visual Studio (в фоновом режиме создаются классы C# модели), а затем генерируете на основе диаграммы EDMX базу данных. При данном подходе не нужно знать ни деталей T-SQL ни синтаксиса C#.

- **Code-First**: Разработчик создает классы моделей данных, и Entity Framework генерирует базу данных и ее таблицы на основе этих классов.

    Подходит для программистов — при данном подходе модель EDMX вообще не используется и вы вручную настраиваете классы C# объектной модели (данный подход поддерживает как генерацию сущностных классов из существующей базы данных, так и создание базы данных из созданной вручную модели объектов C#). Очевидно, что это подходит для программистов, хорошо знакомых с синтаксисом C#.

Преимущества:
- **Высокий уровень абстракции**: Разработчики могут сосредоточиться на логике приложения, не беспокоясь о деталях базы данных.

- **Сокращение кода**: Entity Framework автоматизирует многие операции, такие как создание подключений и выполнение запросов.

- **Поддержка различных баз данных**: Entity Framework может работать с различными системами управления базами данных

#### Предыстория возникновения
Подключенный и автономный уровни ADO.NET снабжают фабрикой, которая позволяет выбирать, вставлять, обновлять и удалять данные с помощью объектов соединений, команд, чтения данных, адаптеров данных и `DataSet`. Хотя все это замечательно, эти аспекты ADO.NET заставляют трактовать полученные данные в манере, которая тесно связана с физической схемой данных.

Вспомните, например, что при использовании подключенного уровня обычно производится итерация по каждой записи за счет указания имен столбцов объекту чтения данных. С другой стороны, в случае работы с автономным уровнем придется иметь дело с коллекциями строк и столбцов объекта `DataTable` внутри контейнера `DataSet`.

При использовании подключенного и автономного уровней ADO.NET всегда приходится помнить о физической структуре лежащей в основе базы данных. Необходимо знать схему каждой таблицы данных, писать сложные SQL-запросы для взаимодействия с данными таблиц и т.д. Это вынуждает писать довольно громоздкий код C#, поскольку C# существенно отличается от языка самой базы данных.

Вдобавок способ конструирования физической базы данных (администратором баз данных) полностью сосредоточен на таких конструкциях базы, как внешние ключи, представления и хранимые процедуры. Сложность баз данных, спроектированных администратором, может еще более возрастать, если администратор при этом заботится о безопасности и масштабируемости. Это также усложняет код C#, который приходится писать для взаимодействия с хранилищем данных.

Платформа <dfn title="Entity Framework">ADO.NET Entity Framework</dfn> (<dfn title="EF">EF</dfn>) — это программная модель, которая пытается заполнить пробел между конструкциями базы данных и объектно-ориентированными конструкциями. Используя EF, можно взаимодействовать с реляционными базами данных, не имея дело с кодом SQL (при желании). Исполняющая среда EF генерирует подходящие операторы SQL, когда вы применяете запросы LINQ к строго типизированным классам.

<dfn title="LINQ to Entities">LINQ to Entities</dfn> — это термин, описывающий применение запросов LINQ к сущностным объектам ADO.NET.

Другой возможный подход состоит в том, чтобы вместо обновления базы данных посредством нахождения строки, обновления строки и отправки строки обратно на обработку в пакете запросов SQL, просто изменять свойства объекта и сохранять его состояние. И в этом случае исполняющая среда EF обновляет базу данных автоматически.

В Microsoft считают ADO.NET Entity Framework новым членом семейства технологий доступа к данным, и не намерены заменять им подключенный и автономный уровни. Однако после недолгого использования EF часто отдается предпочтение этой развитой объектной модели перед относительно примитивным миром SQL-запросов и коллекций строк/столбцов.

Тем не менее, иногда в проектах .NET используются все три подхода, поскольку одна только модель EF чрезмерно усложняет код. Например, при построении внутреннего приложения, которому нужно взаимодействовать с единственной таблицей базы данных, подключенный уровень может применяться для запуска пакета хранимых процедур. Существенно выиграть от использования EF могут более крупные приложения, особенно если команда разработчиков уверенно работает с LINQ. Как с любой новой технологией, следует знать, как (и когда) имеет смысл применять ADO.NET EF.

#### ORM / Объектно-реляционное отображение
При работе с реляционными базами данных мы используем таблицы со строками и столбцами, такая инфраструктура устройства баз данных является очень структурированной. Перед широким внедрением объектно-ориентированного программирования мы работали в рамках “процедурного” программирования – для решения проблем использовался структурный код и функции. Устройство баз данных в виде таблиц, строк и столбцов было в какой-то степени похоже на структурные и процедурные шаблоны программирования, которые мы использовали в нашем коде. Жизнь была хороша ...

После этого произошла эволюция на стороне кода – сейчас мы уже не используем функции, а думаем в терминах объектов, классов и моделей. Процесс разработки программного обеспечения значительно повзрослел за эти годы и обрел концептуальный уровень – изменилось все, начиная от кода (появились ООП, различные фреймворки и шаблоны облегчающие жизнь) и заканчивая командами разработчиков (современный крупный проект трудно представить без архитекторов, дизайнеров, оптимизаторов и т.д.)

При этом эти изменения практически не затронули базы данных. Данные все также остаются заперты в таблицах, строках и столбцах. Это создает большую пропасть в работе между иерархическим объектно-ориентированным кодом и высоко-нормализованной структурой баз данных. Чтобы справиться с этой проблемой, разработчики предложили внести в программные проекты “объектный слой базы данных”, в котором таблицы баз данных представлялись в виде классов, столбцы в виде свойств, а вся работа с базой данных строилась на программном коде без использования SQL. Такой подход получил название <dfn title="объектно-реляционное отображение">объектно-реляционного отображения</dfn> (<dfn title="object-relational mapping">object-relational mapping</dfn> — <dfn title="ORM">ORM</dfn>).

Различные программные платформы предлагают множество систем, реализующих модель ORM. ***Entity Framework*** в сочетании с [LINQ (Language-Integrated Query)](https://professorweb.ru/my/LINQ/base/level1/info_linq.php) представляет собой реализацию ORM для платформы .NET Framework от компании Microsoft. Entity Framework содержит механизмы создания и работы с сущностями базы данных через объектно-ориентированный код на языке, совместимым с CLR (в наших примерах мы будем использовать C#). LINQ представляет собой библиотеку, расширяющую возможности C#, и облегчающую создание запросов (благодаря LINQ можно создавать SQL-подобные запросы в коде C#).

Entity Framework является продолжением другого API-интерфейса для работы с базами данных в .NET – [ADO.NET](https://professorweb.ru/my/ADO_NET/base/level1/ado_net_index.php), в котором для работы с базами данных приходилось писать запросы на SQL и вставлять их в команды. Думаю как вы поняли, Entity Framework значительно облегчает жизнь программистам C#, слабо разбирающимся в SQL и в деталях работы с базами данных.

#### История развития Entity Framework
Entity Framework представляет стратегический подход Microsoft к технологии доступа к данным для построения приложений. В отличие от предыдущих технологий доступа к данным, Entity Framework, в сочетании с Visual Studio, обеспечивает широкие возможности работы с базами данных и может использоваться в любых приложениях, будь это веб-сайт, настольное приложение или веб-служба. Давайте кратко рассмотрим хронологию развития Entity Framework.

Впервые Entity Framework появился в 2007 году, а его первая поддержка была обеспечена в Visual Studio 2008, после чего этот API-интерфейс проделал долгий путь и оброс новыми возможностями.

*[POCO]: Plain Old CLR Object
В первой версии Entity Framework был достаточно ограничен и обеспечивал только базовую реализацию модели ORM на основе подхода Database-First (рассмотрим чуть позже). Версия 4.0 появилась вместе с .NET Framework 4 и Visual Studio 2010 и принесла нам новый подход — Model-First и поддержку *POCO-объектов* (POCO — Plain Old CLR Object). Вскоре после этого, команда разработчиков Entity Framework выпустила три версии (4.1 – 4.3), в которых поддерживался еще один подход к реализации ORM – Code-First.

Версия 5 Entity Framework вышла вместе с выпуском .NET 4.5 и Visual Studio 2012. Эта версия обеспечивает значительное повышение производительности наряду с поддержкой перечислений, табличных функций, пространственных типов Transact SQL, импорта хранимых процедур, и глубокой интеграцией с ASP.NET MVC.

Текущей версией Entity Framework является 6, в которой появилась поддержка асинхронных запросов и возможность работы с хранимыми процедурами через подход Code-First. Более подробный список изменений в версиях Entity Framework вы можете увидеть на сайте MSDN в статье [Entity Framework Version History](https://msdn.microsoft.com/en-us/data/jj574253.aspx).

#### Архитектура Entity Framework
Давайте рассмотрим архитектуру EF. Составные части архитектуры ADO.NET Entity Framework не столь сложны, как могут показаться на первый взгляд. Давайте рассмотрим их более подробно.

##### Роль сущностей
Строго типизированные классы, упомянутые ранее, называются <dfn title="сущность">сущностями</dfn> (***entities***). Сущности — это концептуальная модель физической базы данных, которая отображается на предметную область. Формально говоря, эта модель называется <dfn title="модель сущностных данных">моделью сущностных данных</dfn> (<dfn title="Entity Data Model">Entity Data Model</dfn> — <dfn title="EDM">EDM</dfn>). Модель EDM представляет собой набор классов клиентской стороны, которые отображаются на физическую базу данных.

Тем не менее, нужно понимать, что сущности вовсе не обязаны напрямую отображаться на схему базы данных, как может показаться, исходя из названия. Сущностные классы можно реструктурировать для соответствия существующим потребностям, и исполняющая среда EF отобразит эти уникальные имена на корректную схему базы данных.

Во многих случаях сущностный класс клиентской стороны называется по имени связанной с ним таблицы базы данных. Однако помните, что вы всегда можете изменить сущность для лучшего соответствия конкретной ситуации.

API-интерфейс EF находится на вершине существующей инфраструктуры ADO.NET. Подобно любому взаимодействию ADO.NET, сущностная платформа использует поставщик данных ADO.NET для взаимодействия с хранилищем данных. Однако поставщик данных должен быть обновлен, чтобы поддерживать новый набор служб, прежде чем он сможет взаимодействовать с API-интерфейсом ЕF. И как можно было ожидать, поставщик данных Microsoft SQL Server уже обновлен соответствующей инфраструктурой, которая полагается на использование сборки `System.Data.Entity.dll`.

Многие сторонние базы данных (например, Oracle и MySQL) предлагают EF-совместимые поставщики данных. Детальную информацию можно узнать у поставщика системы управления базами данных или просмотреть список известных поставщиков данных ADO.NET.

В дополнение к добавлению необходимых компонентов к поставщику данных Microsoft SQL Server, сборка `System.Data.Entity.dll` содержит различные пространства имен, которые сами полагаются на службы EF. Две ключевых части API-интерфейса EF, на которые следует обратить внимание сейчас — это **службы объектов** (object services) и **клиент сущности** (entity client).

##### Роль служб объектов
Под <dfn title="служба объектов">службами объектов</dfn> (***object services***) подразумевается часть EF, которая управляет сущностями клиентской стороны при работе с ними в коде. Службы объектов отслеживают изменения, внесенные в сущность (например, смена цвета автомобиля с зеленого на синий), управляют отношениями между сущностями (скажем, просмотр всех заказов для клиента с заданным именем), а также обеспечивают возможности сохранения изменений в базе данных и сохранение состояния сущности с помощью сериализации (XML и двоичной).

<details>
<summary><em>Сериализация в десериализация</em></summary>

<dfn title="сериализация">Сериализация</dfn> (в программировании) — процесс перевода структуры данных в битовую последовательность. Обратной к операции сериализации является операция <dfn title="десериализация">десериализации</dfn> (структуризации) — создание структуры данных из битовой последовательности.

<dfn title="сериализация">Сериализация</dfn> — это преобразование объекта или дерева объектов в какой-либо формат (обычно текстовый или в набор байт) с тем, чтобы потом исходные объекты можно было восстановить из этого формата. Используется, например, для сохранения состояния программы (то есть, некоторых её объектов) между запусками. Или для передачи данных между различными экземплярами программы (или различными программами), например, по сети.

Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другому процессу (возможно, находящемуся на другом хосте), в отличие от самого объекта. А значит, задача сохранения/передачи объекта (или группы объектов) при этом сводится к простой задаче сохранения/передачи набора байт или строки.

JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком. Является альтернативой более громоздкому XML.

Сериализация используется для передачи объектов по сети и для сохранения их в файлы. Например, нужно создать распределённое приложение, разные части которого должны обмениваться данными со сложной структурой. В таком случае для типов данных, которые предполагается передавать, пишется код, который осуществляет сериализацию и десериализацию. Объект заполняется нужными данными, затем вызывается код сериализации, в результате получается, например, XML-документ. Результат сериализации передаётся принимающей стороне по, скажем, электронной почте или HTTP. Приложение-получатель создаёт объект того же типа и вызывает код десериализации, в результате получая объект с теми же данными, что были в объекте приложения-отправителя. По такой схеме работает, например, сериализация объектов через SOAP в Microsoft .NET.

</details>

С точки зрения программирования, уровень службы объектов управляет любым классом, расширяющим базовый класс `EntityObject`. Как и ожидалось, `EntityObject` представляет цепочку наследования для любых сущностных классов в программной модели EF.

##### Роль клиента сущности
Вторым важным аспектом API-интерфейса EF является уровень <dfn title="клиент сущности">клиента сущности</dfn> (***entity client***). Эта часть API-интерфейса EF отвечает за работу с поставщиком данных ADO.NET для установки соединений с базой данных, генерации необходимых SQL-операторов на основе состояния сущностей и запросов LINQ, отображения извлеченных данных на корректные формы сущностей, а также управления прочими деталями, которые обычно приходится делать вручную, если не используется Entity Framework.

Функциональность уровня клиента сущности определена в пространстве имен `System.Data.EntityClient`. Это пространство имен включает набор классов, которые отображают концепции EF (такие как запросы LINQ to Entity) на лежащий в основе поставщик данных ADO.NET. Эти классы (т.е. `EntityCommand` и `EntityConnection`) очень похожи на классы, которые можно найти в составе поставщика данных ADO.NET.

Уровень клиента сущности обычно работает "за кулисами", но вполне может взаимодействовать с клиентом сущности напрямую, если нужен полный контроль над его действиями (прежде всего, над генерацией запросов SQL и обработкой возвращенных данных из базы).

Если требуется более тонкий контроль над тем, как сущностный клиент строит SQL-оператор на основе входящего запроса LINQ, можно использовать Entity SQL. Это независимый от базы данных диалект SQL, который работает непосредственно с сущностями. Построенный запрос Entity SQL может быть отправлен непосредственно службам клиента сущности (или, при желании, объектным службам), где он будет сформатирован в правильный SQL-оператор для лежащего в основе поставщика данных.

Если требуется более высокая степень контроля над манипуляциями извлеченными результатами, можно отказаться от автоматического отображения результатов базы данных на сущностные объекты и вручную обрабатывать записи с помощью класса `EntityDataReader`. Как и можно было ожидать, `EntityDataReader` позволяет обрабатывать извлеченные данные с использованием однонаправленного, доступного только для чтения потока данных, как это делает `SqlDataReader`.

##### Роль файла *.edmx
Подводя итог сказанному: **сущности** — это классы клиентской стороны, которые функционируют, как модель сущностных данных (Entity Data Model). Хотя сущности клиентской стороны в конечном итоге отображаются на таблицу базы данных, жесткая связь между именами свойств сущностных классов и именами столбцов таблиц с данными отсутствует.

В контексте API-интерфейса Entity Framework, чтобы данные сущностных классов отображались на данные таблиц корректно, требуется правильное определение логики отображения. В любой системе, управляемой моделью данных, уровни сущностей, реальной базы данных и отображения разделены на отдельные части: *концептуальная модель*, *логическая модель* и *физическая модель*:

- <dfn title="концептуальная модель">Концептуальная модель</dfn> определяет сущности и отношения между ними (если есть).

- <dfn title="логическая модель">Логическая модель</dfn> отображает сущности и отношения на таблицы с любыми необходимыми ограничениями внешних ключей.

- <dfn title="физическая модель">Физическая модель</dfn> представляет возможности конкретного механизма данных, указывая детали хранилища, такие как табличная схема, разбиение на разделы и индексация.

В мире EF каждый из этих трех уровней фиксируется в XML-файле. В результате использования интегрированных визуальных конструкторов Entity Framework из Visual Studio 2010 получается файл с расширением **.edmx*. Этот файл содержит XML-описания сущностей, физической базы данных и инструкции относительно того, как отображать эту информацию между концептуальной и физической моделями.

##### Роль классов ObjectContext и ObjectSet<T>
Последним фрагментом мозаики EF является класс `ObjectContext`, определенный в пространстве имен `System.Data.Objects`. Генерация файла **.edmx* дает в результате сущностные классы, которые отображаются на таблицы базы данных, и класс, расширяющий `ObjectContext`. Обычно этот класс используется для непрямого взаимодействия со службами объектов и функциональностью клиента сущности.

Класс `ObjectContext` предлагает набор базовых служб для дочерних классов, включая возможность сохранения всех изменений (которые в конечном итоге превращаются в обновление базы данных), настройку строки соединения, удаление объектов, вызов хранимых процедур, а также обработку других фундаментальных деталей.

#### Модель EDM
Понимая предназначение платформы ADO.NET Entity Framewrok, а также имея общее представление о ее работе, можно приступать к рассмотрению модели Entity Framework.

*[EDM]: Entity Data Model
Entity Framework акцентирует свое внимание на моделировании, в котором вы увидите много знакомых вещей – здесь используются *диаграммы ER* (*entity-relationship*, *“сущность-отношение”*), подход с использованием логического и физического проектирования слоев и многое другое. Ядром Entity Framework является <dfn title="модель EDM">модель EDM</dfn> (<dfn title="Entity Data Model">Entity Data Model</dfn>), суть которой заключается в хранении сущностей (entity) в виде строго типизированных классов, а не в виде объектов схемы базы данных. Модель EDM позволяет обеспечить связь между сущностными классами в коде и таблицами базы данных.

Обратите внимание, что таблицы базы данных непосредственно не отображаются на классы сущностей, вместо этого у разработчика есть возможность управлять процессом отображения и он может, например, разбить таблицу на несколько сущностей или наоборот, объединить несколько таблиц в одной сущности (хотя зачастую программисты не используют эту возможность и используют отображение “1 таблица – 1 сущность”).

<dfn title="Модель EDM">Модель EDM</dfn> (Entity Data Model) — это расширенная версия модели «сущность-связь», используемая в Entity Framework для описания структуры данных независимо от их формы хранения. Она состоит из трех основных частей:

- **Концептуальная модель** (CSDL): Описывает структуру данных в виде сущностей и связей, используемых в приложении. Это уровень, на котором разработчики взаимодействуют с данными, не заботясь о схеме хранения.

- **Модель хранилища** (SSDL): Представляет собой схематическое описание внутреннего хранилища данных, обычно соответствующее структуре реляционной базы данных.

- **Картографическая модель** (MSL): Определяет отображение между концептуальной моделью и моделью хранилища, позволяя преобразовывать запросы и данные между этими двумя уровнями.

Модель EDM позволяет разработчикам сосредоточиться на логической структуре данных, не беспокоясь о физической реализации в базе данных. Это упрощает проектирование и сопровождение приложений, работающих с различными источниками данных.

##### Слои
Архитектура Entity Framework в абстрактном смысле основана на слоях (layers): рабочий, удаленный и связующий.

*[CSDL]: Conceptual Schema Definition Language
Классы с кодом сущностей содержатся в *рабочем слое*, в котором работают программисты. В зависимости от того, какой подход вы используете (Code-First или DB-First), рабочий слой может быть смоделирован либо с помощью графического дизайнера Visual Studio, либо с помощью кода. После этого у программистов появляется широкий инструментарий для работы с Entity Framework. Синтаксис рабочего слоя описывается с помощью языка **Conceptual Schema Definition Language** (**CSDL**).

*[SSDL]: Store Schema Definition Language
*Удаленный слой* определяет таблицы, столбцы, строки, отношения между таблицами базы данных. Синтаксис удаленного слоя описывается с помощью языка **Store Schema Definition Language** (**SSDL**).

*[MSL]: Mapping Specification Language
*Связующий слой* определяет соответствие между рабочим и удаленным слоями, он связывает свойства сущностного класса в рабочем слое со столбцами таблицы базы данных в удаленном слое. Управлять этим слоем (т.е деталями привязки) можно из окна Mapping Details находящегося в инструментах дизайнера Visual Studio или с помощью аннотаций Fluent API, если вы работаете с подходом Code-First. Язык **Mapping Specification Language** (**MSL**) определяет синтаксис связующего слоя.

Важно отметить, что языки CSDL, SSDL и MSL имеют синтаксис XML, но при этом используют разную семантику.

##### Генерация файла *.edmx
Когда планируется использование Entity Framework, первый шаг состоит в генерации необходимой концептуальной, логической и физической модели данных, определенной в файле *\*.edmx*.

Выберите пункт меню *Project* --> *Add New Item* (*Проект* --> *Добавить новый элемент*) и вставьте новый элемент ADO.NET Entity Data Model (по умолчанию присваивается именя *Model1.edmx*).

Щелчок на кнопке *Add* (*Добавить*) приводит к запуску мастера создания *модели сущностных данных* (*Entity Data Model Wizard*). На первом шаге мастер позволяет выбрать, нужно генерировать EDM из существующей базы данных либо определить пустую модель (для разработки в стиле "сначала модель"). Выберите опцию *Generate from database* (*Генерировать из базы данных*) и щелкните на кнопке *Next* (*Далее*).

На втором шаге мастера выбирается база данных. Если соединение с базой данных внутри проводника сервера Visual Studio уже существует, оно будет присутствовать в раскрывающемся списке. Если же нет, щелкните на кнопке *New Connection* (*Создать соединение*). В любом случае выберите базу данных и отметьте флажок *Save entity connection settings in App.config as* (*Сохранить настройки соединения в файле App.config как*).

Прежде чем щелкать на кнопке *Next*, взгляните на формат строки соединения:
```cs
metadata=res://*/AppData.Model1.csdl|res://*/AppData.Model1.ssdl|res://*/AppData.Model1.msl;provider=System.Data.SqlClient;provider connection string="data source=(localdb)\mssqllocaldb;initial catalog=Users;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework"
```

Основной интерес в ней представляет *флаг `metadata`*, который используется для указания имен встроенных данных XML-ресурсов концептуального, физического и файла отображений (вспомните, что во время компиляции файл *.edmx будет разделен на отдельные файлы, и данные этих файлов примут вид двоичных ресурсов, встраиваемых в сборку).

На последнем шаге мастера можно выбрать элементы из базы данных, для которой необходимо сгенерировать модель EDM. В рассматриваемом примере ограничимся только таблицей. Щелкните на кнопке *Finish* для генерации модели EDM.

###### Файлы Entity Framework
Все файлы, используемые в Entity Framework основаны на синтаксисе XML. Использование XML делает файлы простыми и универсальными для других приложений. Также XML-файлы читабельны для человека – вы можете в любой момент открыть и просмотреть содержимое этих файлов. Тем не менее, каждый элемент Entity Framework использует различные файлы XML с различным расширением.

После того как вы создадите новое приложение, которое опирается на Entity Framework и добавите сущностные классы базы данных, вы сможете увидеть результирующие файлы в основной папке проекта. В среде Visual Studio вы найдете единственный файл Entity Data Model XML (.EDMX), хотя в более старых версиях Visual Studio возможно будет создано несколько файлов (один для каждой сущности).

Теперь давайте посмотрим, что именно мастер EDM Wizard сгенерировал. Щелкните правой кнопкой мыши на файле (*Model1.edmx*) в проводнике решения и выберите в контекстном меню пункт *Open With...* (*Открыть с помощью*). В открывшемся диалоговом окне выберите опцию *XML Editor* (*Редактор XML*). Это позволит просмотреть XML-данные, лежащие в основе представления в визуальном конструкторе EDM. Структура этого XML-документа разделена на четыре части: все они находятся в корневом элементе `<edms:Edmx>`.

Файл EDMX содержит в себе несколько секций, написанных на языках CSDL, SSDL и MSL, представляющих разные слои в архитектуре Entity Framework. Чтобы открыть исходный код этого файла в Visual Studio, щелкните по нему правой кнопкой мыши и выберите в контекстном меню *Open With…*, после чего в диалоговом окне выберите вариант *XML Editor*.

Подэлемент `<edmx:Runtime>` определяет XML-данные для концептуальной, физической и модели уровня отображения.

Секция с кодом SSDL описывает структуру таблиц базы данных, их структуру, хранимые процедуры и т.д. Разделы `EntityContainer` и `EntityType` аналогичны секции CSDL, но записи опираются на типы данных T-SQL, а не .NET. В примере ниже показана часть секции с кодом SSDL:
```xml
<!-- SSDL content -->
    <edmx:StorageModels>
      <Schema Namespace="UsersModel.Store" Provider="System.Data.SqlClient" ProviderManifestToken="2012" Alias="Self" xmlns:store="http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator" xmlns:customannotation="http://schemas.microsoft.com/ado/2013/11/edm/customannotation" xmlns="http://schemas.microsoft.com/ado/2009/11/edm/ssdl">
        <EntityType Name="Roles">
          <Key>
            <PropertyRef Name="Id" />
          </Key>
          <Property Name="Id" Type="int" StoreGeneratedPattern="Identity" Nullable="false" />
          <Property Name="Title" Type="nvarchar" MaxLength="50" Nullable="false" />
        </EntityType>
        <EntityType Name="sysdiagrams">
          <Key>
            <PropertyRef Name="diagram_id" />
          </Key>
          <Property Name="name" Type="nvarchar" MaxLength="128" Nullable="false" />
          <Property Name="principal_id" Type="int" Nullable="false" />
          <Property Name="diagram_id" Type="int" StoreGeneratedPattern="Identity" Nullable="false" />
          <Property Name="version" Type="int" />
          <Property Name="definition" Type="varbinary(max)" />
        </EntityType>
        <EntityType Name="Users">
          <Key>
            <PropertyRef Name="Id" />
          </Key>
          <Property Name="Id" Type="int" StoreGeneratedPattern="Identity" Nullable="false" />
          <Property Name="Name" Type="nvarchar" MaxLength="50" />
          <Property Name="RoleId" Type="int" Nullable="false" />
        </EntityType>
        <Association Name="FK_Users_Roles">
          <End Role="Roles" Type="Self.Roles" Multiplicity="1" />
          <End Role="Users" Type="Self.Users" Multiplicity="*" />
          <ReferentialConstraint>
            <Principal Role="Roles">
              <PropertyRef Name="Id" />
            </Principal>
            <Dependent Role="Users">
              <PropertyRef Name="RoleId" />
            </Dependent>
          </ReferentialConstraint>
        </Association>
        <EntityContainer Name="UsersModelStoreContainer">
          <EntitySet Name="Roles" EntityType="Self.Roles" Schema="dbo" store:Type="Tables" />
          <EntitySet Name="sysdiagrams" EntityType="Self.sysdiagrams" Schema="dbo" store:Type="Tables" />
          <EntitySet Name="Users" EntityType="Self.Users" Schema="dbo" store:Type="Tables" />
          <AssociationSet Name="FK_Users_Roles" Association="Self.FK_Users_Roles">
            <End Role="Roles" EntitySet="Roles" />
            <End Role="Users" EntitySet="Users" />
          </AssociationSet>
        </EntityContainer>
      </Schema>
    </edmx:StorageModels>
```

Обратите внимание, что узел `<Schema>` определяет имя поставщика данных ADO.NET, который использует эту информацию при взаимодействии с базой данных (`System.Data.SqlClient`). Узлами `<EntityType>` помечается имя физической таблицы базы данных, а также каждый столбец в таблице.

Следующая важная часть файла *.edmx — элемент `<edmx:ConceptualModels>`. который определяет измененные сущности клиентской стороны.

Раздел CSDL содержит XML-код, необходимый для построения рабочего слоя:
```xml
<!-- CSDL content -->
    <edmx:ConceptualModels>
      <Schema Namespace="UsersModel" Alias="Self" annotation:UseStrongSpatialTypes="false" xmlns:annotation="http://schemas.microsoft.com/ado/2009/02/edm/annotation" xmlns:customannotation="http://schemas.microsoft.com/ado/2013/11/edm/customannotation" xmlns="http://schemas.microsoft.com/ado/2009/11/edm">
        <EntityType Name="Role">
          <Key>
            <PropertyRef Name="Id" />
          </Key>
          <Property Name="Id" Type="Int32" Nullable="false" annotation:StoreGeneratedPattern="Identity" />
          <Property Name="Title" Type="String" MaxLength="50" FixedLength="false" Unicode="true" Nullable="false" />
          <NavigationProperty Name="Users" Relationship="Self.FK_Users_Roles" FromRole="Roles" ToRole="Users" />
        </EntityType>
        <EntityType Name="sysdiagram">
          <Key>
            <PropertyRef Name="diagram_id" />
          </Key>
          <Property Name="name" Type="String" MaxLength="128" FixedLength="false" Unicode="true" Nullable="false" />
          <Property Name="principal_id" Type="Int32" Nullable="false" />
          <Property Name="diagram_id" Type="Int32" Nullable="false" annotation:StoreGeneratedPattern="Identity" />
          <Property Name="version" Type="Int32" />
          <Property Name="definition" Type="Binary" MaxLength="Max" FixedLength="false" />
        </EntityType>
        <EntityType Name="User">
          <Key>
            <PropertyRef Name="Id" />
          </Key>
          <Property Name="Id" Type="Int32" Nullable="false" annotation:StoreGeneratedPattern="Identity" />
          <Property Name="Name" Type="String" MaxLength="50" FixedLength="false" Unicode="true" />
          <Property Name="RoleId" Type="Int32" Nullable="false" />
          <NavigationProperty Name="Role" Relationship="Self.FK_Users_Roles" FromRole="Users" ToRole="Roles" />
        </EntityType>
        <Association Name="FK_Users_Roles">
          <End Role="Roles" Type="Self.Role" Multiplicity="1" />
          <End Role="Users" Type="Self.User" Multiplicity="*" />
          <ReferentialConstraint>
            <Principal Role="Roles">
              <PropertyRef Name="Id" />
            </Principal>
            <Dependent Role="Users">
              <PropertyRef Name="RoleId" />
            </Dependent>
          </ReferentialConstraint>
        </Association>
        <EntityContainer Name="UsersEntities" annotation:LazyLoadingEnabled="true">
          <EntitySet Name="Roles" EntityType="Self.Role" />
          <EntitySet Name="sysdiagrams" EntityType="Self.sysdiagram" />
          <EntitySet Name="Users" EntityType="Self.User" />
          <AssociationSet Name="FK_Users_Roles" Association="Self.FK_Users_Roles">
            <End Role="Roles" EntitySet="Roles" />
            <End Role="Users" EntitySet="Users" />
          </AssociationSet>
        </EntityContainer>
      </Schema>
    </edmx:ConceptualModels>
```

Обратите внимание, что в CSDL описываются сгенерированные сущности и связи между ними в разделе **`EntityContainer`**. В элементах `EntityType` описывается структура сущностей – имена столбцов и первичные ключи. Обратите внимание на атрибут `Type`, в котором указывается тип сущности – в данном случае используются .NET-совместимые типы, а не типы T-SQL.

Далее переместимся на уровень отображения, который окно *Mapping Details* и исполняющая среда EF используют для подключения имен в концептуальной модели к физической модели:

Код MDL связывает сущности, указанные в разделах SSDL и CSDL, и определяет как будут отображаться данные из базы данных на классы .NET. В примере ниже показана часть секции с кодом MDL:
```xml
<!-- C-S mapping content -->
    <edmx:Mappings>
      <Mapping Space="C-S" xmlns="http://schemas.microsoft.com/ado/2009/11/mapping/cs">
        <EntityContainerMapping StorageEntityContainer="UsersModelStoreContainer" CdmEntityContainer="UsersEntities">
          <EntitySetMapping Name="Roles">
            <EntityTypeMapping TypeName="UsersModel.Role">
              <MappingFragment StoreEntitySet="Roles">
                <ScalarProperty Name="Id" ColumnName="Id" />
                <ScalarProperty Name="Title" ColumnName="Title" />
              </MappingFragment>
            </EntityTypeMapping>
          </EntitySetMapping>
          <EntitySetMapping Name="sysdiagrams">
            <EntityTypeMapping TypeName="UsersModel.sysdiagram">
              <MappingFragment StoreEntitySet="sysdiagrams">
                <ScalarProperty Name="name" ColumnName="name" />
                <ScalarProperty Name="principal_id" ColumnName="principal_id" />
                <ScalarProperty Name="diagram_id" ColumnName="diagram_id" />
                <ScalarProperty Name="version" ColumnName="version" />
                <ScalarProperty Name="definition" ColumnName="definition" />
              </MappingFragment>
            </EntityTypeMapping>
          </EntitySetMapping>
          <EntitySetMapping Name="Users">
            <EntityTypeMapping TypeName="UsersModel.User">
              <MappingFragment StoreEntitySet="Users">
                <ScalarProperty Name="Id" ColumnName="Id" />
                <ScalarProperty Name="Name" ColumnName="Name" />
                <ScalarProperty Name="RoleId" ColumnName="RoleId" />
              </MappingFragment>
            </EntityTypeMapping>
          </EntitySetMapping>
        </EntityContainerMapping>
      </Mapping>
    </edmx:Mappings>
  </edmx:Runtime>
```

Последней частью файла *.edmx является элемент `<Designer>`. который исполняющей средой EF не используется. Он содержит инструкции, используемые Visual Studio для отображения сущностей на поверхности визуального конструктора.

```xml
<!-- EF Designer content (DO NOT EDIT MANUALLY BELOW HERE) -->
<Designer xmlns="http://schemas.microsoft.com/ado/2009/11/edmx">
  <Connection>
    <DesignerInfoPropertySet>
      <DesignerProperty Name="MetadataArtifactProcessing" Value="EmbedInOutputAssembly" />
    </DesignerInfoPropertySet>
  </Connection>
  <Options>
    <DesignerInfoPropertySet>
      <DesignerProperty Name="ValidateOnBuild" Value="true" />
      <DesignerProperty Name="EnablePluralization" Value="true" />
      <DesignerProperty Name="IncludeForeignKeysInModel" Value="true" />
      <DesignerProperty Name="UseLegacyProvider" Value="false" />
      <DesignerProperty Name="CodeGenerationStrategy" Value="None" />
    </DesignerInfoPropertySet>
  </Options>
  <!-- Diagram content (shape and connector positions) -->
  <Diagrams></Diagrams>
</Designer>
```

Удостоверьтесь, что проект скомпилирован, по крайней мере, однажды, и щелкните на кнопке *Show All Files* (*Показать все файлы*) в проводнике решений. Затем зайдите в папку *obj\Debug*, а после этого — в *edmxResourcesToEmbed*. Здесь находятся три XML-файла, основанные на содержимом файла *.edmx.

Данные в этих файлах будут встроены в сборку как двоичные ресурсы. Таким образом, приложение .NET обладает всей информацией, необходимой для понимания концептуального, физического и уровня отображения модели EDM.

#### Entity Client
Низкоуровневый API-интерфейс для доступа к Entity Framework находится в пространстве имен **`System.Data.SqlClient`**. Это пространство имен содержит поставщика ADO.NET, который обращается к базе данных, используя сущностную модель данных — Entity Data Model (EDM). Этот поставщик ADO.NET, определяет классы, унаследованные от базовых классов `DbConnection`, `DbCommand`, `DbParameter` и `DbDataReader`. Здесь классы называются **`EntityConnection`**, **`EntityCommand`**, **`EntityParameter`** и **`EntityDataReader`**.

Упомянутые классы можно использовать таким же образом, как описывалось ранее, за исключением того, что требуется специальная строка соединения, и для доступа к модели EDM Entity вместо T-SQL применяется SQL.

Подключение к базе данных осуществляется через класс `EntityConnection`, что требует специальной сущностной строки соединения. Эта строка читается из конфигурационного файла с помощью класса **`ConfigurationManager`** из пространства имен `System.Configuration`. Метод `CreateCommand` класса `EntityConnection` возвращает `EntityCommand`. Текст команды для `EntityCommand` присваивается свойству `CommandText` и требует команды Entity SQL.

Строка соединения необходима для EDM и отличается от нормальной строки соединения ADO.NET, потому что требуется информация об отображении. Отображение определено ключевым словом **`metadata`**. В отображении должны быть указаны три вещи: список с разделителями файлов отображения, Provider — для инвариантного имени поставщика для доступа к источнику данных, и Provider connection string для присваивания зависящей от поставщика строки соединения.

*[CSDL]: Conceptual schema definition language
*[SSDL]: Store schema definition language
*[MSL]: Mapping specification language
Список с разделителями файлов отображения включает файлы *InventoryEDM.csdl*, *InventoryEDM.ssdl* и *InventoryEDM.msl*, которые содержатся внутри ресурсов в сборке, как определено префиксом `res:`. Внутри Visual Studio визуальный конструктор использует только один файл — *InventoryEDM.edmx*, который содержит код CSDL, SSDL и MSL. Установка свойства *Custom Tool* (*Специальный инструмент*) в `EntityModelCodeGenerator` создает три файла, которые содержатся внутри ресурсов.

В настройке `connectionString` можно найти строку соединения с базой данных. Эта часть — такая же, как простая строка соединения ADO.NET, и зависит от поставщика, который устанавливается в настройке `provider`:
```xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <connectionStrings>
    <add name="AutoLotEntities" connectionString="metadata=res://*/InventoryEDM.csdl|res://*/InventoryEDM.ssdl|res://*/InventoryEDM.msl;
         provider=System.Data.SqlClient;provider connection string="
         Data Source=MICROSOF-1EA29E\SQLEXPRESS;Initial Catalog=AutoLot;
         Integrated Security=True;Pooling=False;MultipleActiveResultSets=True"" providerName="System.Data.EntityClient" />
  </connectionStrings>
</configuration>
```

В строке соединения можно также указывать файлы, CSDL, SSDL и MSL, которые не включены в сборку в виде ресурсов. Это полезно, если необходимо изменить содержимое этих файлов после развертывания проекта.

Для запросов данных с помощью Entity Client используется **Entity SQL**. Язык Entity SQL расширяет T-SQL добавлением типов. Этот синтаксис не требует соединений, поскольку вместо них могут использоваться ассоциации сущностей.

В Entity SQL нет оператора `SELECT *`. Все столбцы извлекаются ранее запросом `EntitySet`. С помощью `SELECT VALUE` можно также получить все столбцы, как показано в следующем фрагменте. В нем также применяется фильтр с `WHERE`, который позволяет получить в запросе только определенных издателей. Обратите внимание, что в `CommandText` параметр указывается с символом однако при добавлении параметра в коллекцию `Parameters` символ `@` не используется:
```cs
command.CommandText = "SELECT VALUE it FROM AutoLotEntities.AutoLot AS it WHERE " +
   "it.Carname = @BMW";
command.Parameters.AddWithValue("Carname", "Audi");
```

#### Сущности и класс ObjectContext

##### Сущности
Сущностные классы создаются в визуальном конструкторе посредством CSDL. Они определяют свойства для своих данных, такие как `CarID` и `Color`. Средства доступа `set` этих свойств инициируют изменение информации двумя разными способами. Один способ состоит в вызове методов **`ReportPropertyChanging()`** и **`ReportPropertyChanged()`** базового класса `EntityObject`. Вызов этих методов использует интерфейсы `INotifyPropertyChanging` и `INotifyPropertyChanged` для информирования каждого клиента, который зарегистрирован на получение событий об этих интерфейсах.

Другой способ предусматривает применение частичных методов, таких как `OnCarIDChanging()` и `OnCarIDChanged()`, которые не имеют реализаций по умолчанию, но могут быть реализованы в специальных расширениях этого класса:
```cs
[EdmScalarPropertyAttribute(EntityKeyProperty=true, IsNullable=false)]
[DataMemberAttribute()]
public global::System.Int32 CarID
{
    get
    {
        return _CarID;
    }
    set
    {
        if (_CarID != value)
        {
            OnCarIDChanging(value);
            ReportPropertyChanging("CarID");
            _CarID = StructuralObject.SetValidValue(value);
            ReportPropertyChanged("CarID");
            OnCarIDChanged();
        }
    }
}
private global::System.Int32 _CarID;
partial void OnCarIDChanging(global::System.Int32 value);
partial void OnCarIDChanged();
...
```

Классы и интерфейсы, важные в контексте сущностных классов, описаны в таблице. За исключением `INotifyPropertyChanging` и `INotifyPropertyChanged`, эти типы определены в пространстве имен `System.Data.Objects.DataClasses`:

| | |
-- | --
**`StructuralObject`** | `StructuralObject` — базовый класс для классов `EntityObject` и `ComplexObject`. Этот класс реализует интерфейсы `INotifyPropertyChanging` и `INotifyPropertyChanged`.
**`INotifyPropertyChanging`**, **`INotifyPropertyChanged`** | Эти интерфейсы определяют события `PropertyChanging` и `PropertyChanged`, позволяющие подписываться на информацию об изменении состояния объекта. В отличие от прочих классов и интерфейсов, которые перечислены здесь, эти интерфейсы находятся в пространстве имен `System.ComponentModel`.
**`IEntityWithRelationships`** | Этот интерфейс определяет свойство только для чтения `RelationshipManager`, которое возвращает объект `RelationshipManager`, используемый для навигации между объектами.
**`EntityObject`** | Этот класс наследуется от `StructuralObject` и реализует интерфейсы `IEntityWithKey`, `IEntityWithChangeTracker` и `IEntityWithRelationships`. Часто используется в качестве базового класса для объектов, отображаемых на таблицы базы данных, которые содержат ключи и отношения с другими объектами.
**`ComplexObject`** | Этот класс может служить в качестве базового для сущностных объектов, которые не имеют ключа. Он наследуется от `StructuralObject`, но не реализует других интерфейсов, как это делает класс `EntityObject`.
**`IEntityWithKey`** | Этот интерфейс определяет свойство `EntityKey`, которое позволяет быстрый доступ к объекту.
**`IEntityWithChangeTracker`** | Этот интерфейс определяет метод `SetChangeTracker()`, в котором может быть назначен монитор изменений, реализующий `IChangeTracker` для получения информации об изменении состояния объекта.

Для сущностного класса не обязательно быть наследником базового класса `EntityObject` или `ComplexObject`. Вместо этого сущностный класс может реализовать необходимые интерфейсы.

##### ObjectContext
Чтобы извлечь информацию из базы данных, необходим класс `ObjectContext`. Этот класс определяет отображение сущностных объектов на базу данных. Этот класс можно сравнить с адаптером данных из основного ADO.NET, который наполняет `DataSet`.

Класс `AutoLotEntities`, созданный визуальным конструктором, наследуется от базового класса `ObjectContext`. Этот класс добавляет конструкторы, принимающие строку соединения. В конструкторе по умолчанию строка соединения читается из конфигурационного файла. Можно также передать конструктору уже открытое соединение в виде экземпляра `EntityConnection`. Если передать конструктору неоткрытое соединение, объект `ObjectContext` откроет и закроет соединение. В случае передачи открытого соединения его понадобится впоследствии закрыть. Созданный класс определяет свойства `Books` и `Authors`, которые возвращают `ObjectSet<TEntity>`. Это новый класс в .NET 4, унаследованный от класса `ObjectQuery<TEntity>`:
```cs
public partial class AutoLotEntities : ObjectContext
{
    #region Конструкторы

    /// <summary>
    /// Инициализирует новый объект AutoLotEntities, используя строку соединения из раздела "AutoLotEntities" файла конфигурации приложения.
    /// </summary>
    public AutoLotEntities() : base("name=AutoLotEntities", "AutoLotEntities")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }

    /// <summary>
    /// Инициализация нового объекта AutoLotEntities.
    /// </summary>
    public AutoLotEntities(string connectionString) : base(connectionString, "AutoLotEntities")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }

    /// <summary>
    /// Инициализация нового объекта AutoLotEntities.
    /// </summary>
    public AutoLotEntities(EntityConnection connection) : base(connection, "AutoLotEntities")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }

    #endregion

    #region Разделяемые методы

    partial void OnContextCreated();

    #endregion

    #region Свойства ObjectSet

    /// <summary>
    /// Нет доступной документации по метаданным.
    /// </summary>
    public ObjectSet<Car> Cars
    {
        get
        {
            if ((_Cars == null))
            {
                _Cars = base.CreateObjectSet<Car>("Cars");
            }
            return _Cars;
        }
    }
    private ObjectSet<Car> _Cars;

    #endregion
    #region Методы AddTo

    /// <summary>
    /// Устаревший метод для добавления новых объектов в набор EntitySet Cars. Взамен можно использовать метод .Add связанного свойства ObjectSet<T>.
    /// </summary>
    public void AddToCars(Car car)
    {
        base.AddObject("Cars", car);
    }

    #endregion
}
```

Класс `ObjectContext` предоставляет вызывающему коду несколько услуг:

- Он отслеживает сущностные объекты, которые уже извлечены. Если объект запрашивается вновь, он берется из объектного контекста.

- Он хранит информацию о сущностях. Из него можно получить информацию о добавленных, модифицированных и удаленных объектах.

- Можно обновлять сущности из объектного контекста, чтобы записывать изменения в лежащее в его основе хранилище.

Методы и свойства класса `ObjectContext` перечислены ниже:

- **`Connection`**

    Возвращает объект `DbConnection`, присвоенный объектному контексту.

- **`MetadataWorkspace`**

    Возвращает объект `MetadataWorkspace`, который может быть использован для чтения метаданных и информации об отображении.

- **`QueryTimeout`**

    С помощью этого свойства можно получать и устанавливать значение таймаута для запросов объектного контекста.

- **`ObjectStateManager`**

    Это свойство возвращает `ObjectStateManager`. Диспетчер `ObjectStateManager` следит за извлеченными сущностными объектами и изменениями объектов из объектного контекста.

- **`CreateQuery()`**

    Этот метод возвращает `ObjectQuery` для получения данных из хранилища.

- **`GetObjectByKey()`**, **`TryGetObjectByKey()`**

    Эти методы возвращают объект по ключу — либо от диспетчера состояния объектов, либо из лежащего в основе хранилища. Если ключ отсутствует, `GetObjectByKey()` генерирует исключение типа `ObjectNotFoundException`. Метод `TryGetObjectByKey()` возвращает `false`.

- **`AddObject()`**

    Этот метод добавляет новый сущностный объект к объектному контексту.

- **`DeleteObject()`**

    Этот метод удаляет объект из объектного контекста.

- **`Detach()`**

    Этот метод отсоединяет сущностный объект от объектного контекста, так что его изменения больше не отслеживаются.

- **`Attach()`**, **`AttachTo()`**

    Метод `Attach()` присоединяет отсоединенный объект к хранилищу. Присоединение объектов обратно к объектному контексту требует, чтобы сущностный объект реализовывал интерфейс `IEntityWithKey`. Метод `AttachTo()` не предъявляет требования наличия ключа у объекта, но требует установки имени сущности, когда объект нуждается в присоединении.

- **`ApplyPropertyChanges()`**

    Если объект отключен от объектного контекста, то если отключенный объект модифицируется, и затем эти изменения должны быть применены внутри объектного контекста, можно вызвать метод `ApplyPropertyChanges()` для применения изменений. Это удобно в тех сценариях, когда отсоединенный объект возвращается веб-службой, изменяется на клиенте и передается веб-службе в модифицированном виде.

- **`Refresh()`**

    Пока сущностные объекты находятся внутри объектного контекста, данные в хранилище могут изменяться. Чтобы выполнить обновление данных из хранилища, можно использовать метод `Refresh()`. Этому методу можно передавать значение перечисления `RefreshMode`. Если значения объекта отличаются между хранилищем и объектным контекстом, передача значения `Clientwins` изменяет данные в хранилище. Значение `storewins` изменяет данные в объектном контексте.

- **`SaveChanges()`**

    Добавление, модификация и удаление объектов из объектного контекста не изменяет объект в хранилище. С помощью метода `SaveChanges()` изменения записываются в хранилище.

- **`AcceptAllChanges()`**

    Этот метод изменяет состояние объектов в контексте на немодифицированное. `SaveChanges()` неявно вызывает этот метод.

#### Подходы для работы
При использовании Entity Framework в приложении существует три подхода для организации взаимодействия Entity Framework с базой данных: Code-First, Model-First и Database-First. В этой статье мы кратко рассмотрим эти подходы и проведем их сравнительный анализ, а более подробное описание каждого из подходов с использованием примеров будет приведено в следующих статьях.

##### Подход Code-First
***Подход Code-First***, который впервые появился в Entity Framework 4.1, обычно используется, когда у вас есть уже существующее приложение, содержащее модель данных. Эта модель, как правило, описывается с помощью нескольких классов и кода взаимодействия между этими классами. Например, вы можете создать класс по имени `Customer`, который будет содержать данные покупателя в интернет-магазине:
```cs
public class Customer
{
    // Определить поля, которые используются в базе данных
    public int CustomerId { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string City { get; set; }
    public int Age { get; set; }
    public DateTime BirthDate { get; set; }
}
```

Вы можете использовать этот класс модели в своем приложении без создания базы данных. Добавив дополнительный код, вы могли бы хранить объекты этого класса, например, на диске в формате XML или в памяти рабочего процесса программы. Однако когда ваше приложение расширяется и становится крупным, эти данные необходимо будет хранить в базе данных. Эта та точка, в которой и начинает работать подход Code-First – вы можете использовать существующий код для создания базы данных не беспокоясь о деталях реализации базы данных (этим займется Entity Framework), а вы можете сфокусировать свое внимание на коде.

Важно отметить, что класс, представляющий модель данных, должен иметь поле `Id`, которое будет использоваться в таблице базы данных в качестве первичного ключа. Entity Framework автоматически находит такое поле с помощью механизма рефлексии (в его имени должна содержаться строка “Id”, поэтому поле `CustomerId` в примере выше будет автоматически использоваться в качестве первичного ключа.) Это ограничение можно обойти, использовав свойство с произвольным именем и помеченное специальными атрибутами метаданных C#, которые используются в Entity Framework. Здесь мы их описывать не будем, я лишь заострил свое внимание на этом моменте, потому что он показывает, что любые настройки первичных и внешних ключей, ограничения между таблицами и т.д. при подходе Code-First указываются в модели (т.е. в управляемом коде C#), а потом проецируются на базу данных.

Подход Code-First появился позже подходов Model-First и Database-First и, как вы уже поняли, больше всего подходит для разработчиков, которые хотят писать код, а не работать с дизайнером модели EDM или средствами работы с базами данных (SQL Server Management Studio и T-SQL). Вы можете создать модель для вашего приложения, используя **объекты CLR** (**Common Language Runtime**) и **специальные объекты POCO** (**Plain Old CLR Object**).

При проектировании приложений с подходом Code-First, вы сначала создаете классы модели данных не обращая никакого внимания на Entity Framework. После того, как вам понадобилось работать с базой данных, вы используете различные инструменты, которые проецируют структуру базы данных из созданной модели классов. После этого вы можете вернуться к этой модели в коде и, например, изменить ее. Эти изменения затем можно будет отразить в базе данных используя все те же инструменты.

Важным нововведением версии Entity Framework 5 в плане подхода Code-First, является то, что созданная модель классов теперь сразу является *сущностной моделью данных EDM* (*Entity Data Model*), поэтому отпала необходимость использовать файл EDMX. В более ранних версиях разработчику, использующему подход Code-First, приходилось добавлять отношения между моделью классов и файлом EDMX, т.е. отображать любые изменения модели сразу в двух местах. Очевидно, что этот подход приводил к появлению кучи ошибок, если разработчик забывал синхронизировать эти изменения в обоих файлах.

Чтобы указать среде Visual Studio, что модель классов является моделью EDM, нужно во-первых установить сборки Entity Framework в проект, а во-вторых добавить класс контекста базы данных, унаследованный от класса **`DbContext`**, находящегося в пространстве имен `System.Data.Entity`, как показано в примере ниже (установку Entity Framework и настройку класса контекста мы более подробно будем рассматривать позже):
```cs
using System;
using System.Data.Entity;

namespace ProfessorWeb.EntityFramework
{
    public class PwContext : DbContext
    {
        // Это свойство ссылается на таблицу в базе данных
        public DbSet<Customer> Customer { get; set; }
    }
}
```

Вам не нужно беспокоится о способах взаимодействия с базой данных, Entity Framework определяет ряд вспомогательных методов. Вам не нужно знать деталей подключения и даже имени базы данных. Ниже показан пример вставки данных в таблицу с использованием тестового класса `Customer`, показанного выше:
```cs
public void InsertCustomer()
{
    // Создать объект для записи в БД
    Customer customer = new Customer
    {
        FirstName = "Вася",
        LastName = "Пупкин",
        Age = 27,
        City = "Москва",
        BirthDate = DateTime.Now.AddYears(-27)
    };

    // Создать объект контекста
    PwContext context = new PwContext();

    // Вставить объект в БД и сохранить изменения
    context.Customer.Add(customer);
    context.SaveChanges();
}
```

Этот код является немного упрощенным, но все же показывает суть работы с Entity Framework. Конечно, вы можете глубже контролировать каждую операцию с базой данных. Этот пример использует максимальную автоматизацию и дает приемлемые результаты, по крайней мере в небольшом приложении. В последующих статьях мы рассмотрим более подробно настройки подхода Code-First, которые можно использовать для удовлетворения конкретных потребностей.

##### Подход Model-First
***Подход Model-First***, впервые появившийся в версии Entity Framework 4, применяется разработчиками, которые не хотят использовать инструменты СУБД для создания и управления базами данных, а также не хотят вручную настраивать классы модели EDM. Фактически это самый простой подход при работе с Entity Framework. Проектирование модели происходит в графическом дизайнере EDM среды Visual Studio. Вы могли наблюдать использование Model-First в предыдущей статье, где мы создали простое приложение ASP.NET.

Рабочий процесс создания модели при подходе Model-First начинается в тот момент, когда вы проектируете базу данных. При этом вам необходимы минимальные знания устройства баз данных, например, для настройки отношений между таблицами в графическом дизайнере или указания типов данных SQL полей таблицы.

Как и в случае подхода Code-First, вся работа строится вокруг класса контекста базы данных. Фактически, взаимодействие с базой данных в этих подходах одинаковое. Например, для вставки объекта, используется следующая последовательность действий:

1. Создать объект модели и наполнить его данными.

2. Создать класс контекста, унаследованный от `DbContext` (в подходе Code-First это делается вручную, в Model-First этот класс генерируется автоматически вместе с сущностными классами).

3. Добавить объект в базу данных, используя класс контекста.

4. Сохранить изменения.

##### Подход Database-First
***Подход Database-First***, появившийся вместе c Entity Framework, позволяет писать приложения для существующих баз данных. Базы данных в реальных приложениях довольно быстро становятся сложными и пытаться создать модель для существующей базы данных, которую могут понять разработчики, довольно трудно. Еще тяжелее написать код использования модели, в котором происходит взаимодействие с базой данных. Во многих отношениях, подход Database-First является противоположностью подходу Model-First. При подходе Database-First база данных уже существует, поэтому разработчик должен знать, где расположена база данных, а также иметь информацию об имени базы данных. Тем не менее, разработчик не должен понимать внутреннюю работу базы данных — Entity Framework по-прежнему скрывает внутреннюю реализацию из поля зрения.

При этом подходе, рабочий процесс создания модели начинается с создания и проектирования базы данных. После генерации сущностных классов модели из существующей базы данных, работа с Entity Framework аналогична подходам Code-First и Model-First. Это означает создание объекта класса контекста и использование этого объекта для выполнения необходимых задач.

##### Совместимые с Entity Framework поставщики данных
Для того, чтобы получить доступ к базе данных с помощью Entity Framework, нужно использовать поставщики данных, совместимые с Entity Framework. <dfn title="поставщик данных">Поставщики данных</dfn> (<dfn title="data provider">data providers</dfn>) организуют взаимодействие между сущностными классами и системой управления базами данных (СУБД). Фактически они отвечают за то, например, какой код C# нужно сгенерировать из базы данных при использовании подхода Database-First, или какой код SQL нужно создать, при отображении графической модели EDMX на базу данных.

Visual Studio по умолчанию поставляется поставщиком данных **SqlClient**, что позволяет получить доступ к большинству версий СУБД SQL Server: 2005, 2008, 2010, 2012, 2014. Начиная с версии Visual Studio 2010, Microsoft отказалась от поддержки SQL Server 2000. Можно также создать приложение, обращающееся к SQL Server Compact. Тем не менее, этот провайдер имеет некоторые строгие ограничения, такие как неспособность поддерживать схемы с одинаковыми именами ограничений.

Вы также можете получить доступ к ряду сторонних поставщиков данных для других СУБД. В настоящее время поставщики данных Entity Framework поддерживаются следующими СУБД: MySQL, Oracle, Progress, VistaDB, Devart, OpenLink, SQL Anywhere, Sybase, SQLite, Synergex, Firebird и PostgreSQL (через поставщик Npgsql).

В списке провайдеров отсутствует поддержка базы данных Access Microsoft. Также Entity Framework не поддерживает старые технологии и методы доступа, такие как Open Database Connectivity (ODBC). Для того, чтобы получить поддержку Entity Framework для конкретной базы данных, вы можете создать EF-совместимый провайдер для нее. Более подробно об этом можно прочитать в статье "[EF5 Sample Provider](http://blogs.msdn.com/b/adonet/archive/tags/sample+provider/)".

##### Как выбрать нужный подход?
Данный вопрос задает себе каждый разработчик, который планирует работать с Entity Framework. В данном случае можно посоветовать придерживаться целей каждого из подходов. Например, если вы запускаете приложение с нуля и у вас нет базы данных, то удобнее использовать подход Model-First. Если база данных есть, то можно использовать Database-First. Если нужно добавить поддержку Entity Framework в уже существующее приложение, где определена модель данных, логичнее всего использовать подход Code-First.

Однако, можно посоветовать использовать подход, удобный для разработчика. Очевидно, что подход Database-First удобен для разработчиков, которые хорошо разбираются в проектировании баз данных и знают основы T-SQL, т.к. этот подход подразумевает создание базы данных вручную. Model-First больше подходит для архитекторов приложений, т.к. использует удобную графическую среду и абстрагируется от реализации базы данных и создания классов модели. Code-First более удобен для программистов C#, т.к. позволяет настраивать детали базы данных из кода.

В следующей таблице показана сводка различных подходов для работы с Entity Framework:

*Типы подходов для работы с Entity Framework*
Использование БД | Ориентация подхода | Подход | Описание
-- | -- | -- | --
Новая БД | На графическую модель | Model-First | Если вам необходимо создать новую базу данных и вы хотите увидеть дизайн базы в графическом виде, подход Model-First работает лучше всего. Model-First использует следующий рабочий процесс:<ul><li>Вы можете создать модель, используя графический конструктор EDMX.</li><li>Вы генерируете базу данных на основе этой модели.</li><li>Entity Framework автоматически генерирует классы, необходимые для взаимодействия с базой данных.</li></ul>
Существующая БД | На графическую модель | Database-First | Если у вас уже есть база данных и вы хотите манипулировать ею используя графический редактор, то подход Database-First работает лучше всего. Database-First использует следующий рабочий процесс:<ul><li>Вы генерируете модель EDMX из существующей базы данных.</li><li>Entity Framework автоматически генерирует классы, необходимые для взаимодействия с базой данных.</li></ul>
Новая БД | На код | Code-First | Если вам необходимо создать новую базу данных и вы предпочитаете работать с кодом, то лучшим подходом будет Code-First, использующий следующий рабочий процесс:<ul><li>Вы вручную создаете классы, которые определяют данные в каждой таблице базы данных.</li><li>Вы определяете отношения между таблицами с помощью различных атрибутов и виртуальных методов.</li><li>При необходимости, вы также настраиваете детали подключения (например, строку подключения).</li><li>Entity Framework автоматически формирует базу данных во время выполнения.</li></ul>
Существующая БД | На код | Code-First (Code-Second) | Если для существующей базы данных вы хотите вручную создать модель в коде, то нужно использовать подход Code-First, который некоторые разработчики также называют Code-Second, т.к. он применяется к уже существующей базе данных. Рабочий процесс выглядит следующим образом:<ul><li>Вы перепроектируете классы, которые определяют данные для каждой таблицы в базе данных с помощью кода.</li><li>Вы отображаете отношения между таблицами в базе данных на код модели.</li></ul>

##### Класс контекста данных
Сами по себе классы модели не имеют ничего общего с Entity Framework. На данном этапе они просто описывают структуру бизнес-модели, которая используется в приложении. Чтобы Entity Framework был в курсе, что эти классы служат также для управления данными в базе данных, нужно использовать класс контекста. EF имеет два базовых класса контекста:

- **`ObjectContext`**

    Этот класс является более общим классом контекста данных, и используется начиная с самых ранних версий Entity Framework.

- **`DbContext`**

    Этот класс контекста данных появился в Entity Framework 4.1 и он обеспечивает поддержку подхода Code-First (`ObjectContext` также обеспечивает работу подхода Code-First, но он труднее в использовании). Далее мы будем использовать `DbContext`.

Для создания класса контекста можно добавить следующий новый класс `SampleContext` в проект:
```cs
using System.Data.Entity;

namespace CodeFirst
{
    public class SampleContext : DbContext
    {
        // Имя будущей базы данных можно указать через
        // вызов конструктора базового класса
        public SampleContext() : base("MyShop")
        { }

        // Отражение таблиц базы данных на свойства с типом DbSet
        public DbSet<Customer> Customers { get; set; }
        public DbSet<Order> Orders { get; set; }
    }
}
```

Этот небольшой класс контекста представляет полный слой данных, который можно использовать в приложениях. Благодаря `DbContext`, вы сможете запросить, изменить, удалить или вставить значения в базу данных. Обратите внимание на использование конструктора в этом классе с вызовом конструктора базового класса `DbContext` и передачей ему строкового параметра. В этом параметре указывается либо имя базы данных либо строка подключения к базе данных (Entity Framework достаточно интеллектуален чтобы отличить тип параметра). В данном случае мы указываем явно имя базы данных, т.к. по умолчанию, при генерации базы данных Entity Framework использует имя приложения и контекста данных (например `CodeFirst.SampleContext`), которое нам не подходит.

### Entity Framework Core

#### Обзор EF Core
*[ORM]: Object-Relational Mapping
Entity Framework представляет ORM-технологию (object-relational mapping — отображения данных на реальные объекты) от компании Microsoft для доступа к данным. Entity Framework Core позволяет абстрагироваться от самой базы данных и ее таблиц и работать с данными как с объектами классом независимо от типа хранилища. Если на физическом уровне мы оперируем таблицами, индексами, первичными и внешними ключами, но на концептуальном уровне, который нам предлагает Entity Framework, мы уже работаем с объектами.

Как технология доступа к данным Entity Framework Core работает поверх платформы .NET и поэтому может использоваться на различных платформах стека .NET. Это и стандартные платформы типа Windows Forms, консольные приложения, WPF, UWP и ASP.NET Core. При этом кроссплатформенная природа EF Core позволяет задействовать ее не только на ОС Windows, но и на Linux и Mac OS X.

Поскольку Entity Framework Core работает на основе платформы .NET, то он развивается вместе с данной платформой. Текущая версия EF Core — 9.0 была выпущена в ноябре 2024 года вместе с .NET 8. И технология продолжает развиваться.

Entity Framework Core поддерживает множество различных систем баз данных. Таким образом, мы можем через EF Core работать с любой СУБД, если для нее имеется нужный провайдер. По умолчанию на данный момент Microsoft предоставляет ряд встроенных провайдеров: для работы с MS SQL Server, для SQLite, для PostgreSQL. Также имеются провайдеры от сторонних поставщиков, например, для MySQL.

Стоит отметить, что Entity Framework Core развивается как opensourse-проект, все файлы которого можно найти в репозитории на github по адресу https://github.com/dotnet/efcore.

Также стоит отметить, что EF Core предоставляет универсальный API для работы с данными. И если, к примеру, мы решим сменить целевую СУБД, то основные изменения в проекте будут касаться прежде всего конфигурации и настройки подключения к соответствующим провайдерам. А код, который непосредственно работает с данными, получает данные, добавляет их в БД и т.д., останется прежним.

Центральной концепцией Entity Framework является понятие сущности или entity. <dfn title="сущность">Сущность</dfn> определяет набор данных, которые связаны с определенным объектом. Поэтому данная технология предполагает работу не с таблицами, а с объектами и их коллекциями.

Любая сущность, как и любой объект из реального мира, обладает рядом свойств. Например, если сущность описывает человека, то мы можем выделить такие свойства, как имя, фамилия, рост, возраст. Свойства необязательно представляют простые данные типа `int` или `string`, но могут также представлять и более комплексные типы данных. И у каждой сущности может быть одно или несколько свойств, которые будут отличать эту сущность от других и будут уникально определять эту сущность. Подобные свойства называют ключами.

При этом сущности могут быть связаны ассоциативной связью один-ко-многим, один-ко-одному и многие-ко-многим, подобно тому, как в реальной базе данных происходит связь через внешние ключи.

Отличительной чертой Entity Framework Core, как технологии ORM, является использование запросов LINQ для выборки данных из БД. С помощью LINQ мы можем создавать различные запросы на выборку объектов, в том числе связанных различными ассоциативными связями. А Entity Framework при выполнение запроса транслирует выражения LINQ в выражения, понятные для конкретной СУБД (как правило, в выражения SQL).

Основная функциональность Entity Framework Core сосредоточена в следующих пакетах:

- `Microsoft.EntityFrameworkCore`: основной пакет EF Core

- `Microsoft.EntityFrameworkCore.SqlServer`: представляет функциональность провайдера для Microsoft SQL Server и SQL Azure

- `Microsoft.EntityFrameworkCore.SqlServer.NetTopologySuite`: предоставляет поддержку географических типов (spatial types) для SQL Server

- `Microsoft.EntityFrameworkCore.Sqlite`: представляет функциональность провайдера для SQLite и включает нативные бинарные файлы для движка базы данных

- `Microsoft.EntityFrameworkCore.Sqlite.Core`: представляет функциональность провайдера для SQLite, но в отличие от предыдущего пакета не содержит нативные бинарные файлы для движка базы данных

- `Microsoft.EntityFrameworkCore.Sqlite.NetTopologySuite`: предоставляет поддержку географических типов (spatial types) для SQLite

- `Microsoft.EntityFrameworkCore.Cosmos`: представляет функциональность провайдера для Azure Cosmos DB

- `Microsoft.EntityFrameworkCore.InMemory`: представляет функциональность провайдера базы данных в памяти

- `Microsoft.EntityFrameworkCore.Tools`: содержит команды EF Core PowerShell для Visual Studio Package Manager Console; применяется в Visual Studio для миграций и генерации классов по готовой бд

- `Microsoft.EntityFrameworkCore.Design`: содержит вспомогательные компоненты EF Core, применяемые в процессе разработки

- `Microsoft.EntityFrameworkCore.Proxies`: хранит функциональность для так называемой "ленивой загрузки" (lazy-loading) и прокси отслеживания изменений

- `Microsoft.EntityFrameworkCore.Abstractions`: содержит набор абстракций EF Core, которые не зависят от конкретной СУБД

- `Microsoft.EntityFrameworkCore.Relational`: хранит компоненты EF Core для провайдеров реляционных СУБД

- `Microsoft.EntityFrameworkCore.Analyzers`: содержит функционал анализаторов C# для EF Core

Платформу Entity Framework Core можно применять в различных технологиях стека .NET — консольных приложениях, программах на WinForms, WPF, UWP, веб-приложения ASP.NET и так далее.

Кроме того, EF Core может работать с различными системами баз данных. поскольку Entity Framework позволяет в большой степени писать универсальный код для подключения к разным СУБД, этот код можно будет применять и к другим СУБД.

#### EF6 vs. EF Core
Entity Framework (EF) и Entity Framework Core (EF Core) — это две версии технологии объектно-реляционного сопоставления (ORM) от Microsoft, используемые для взаимодействия с базами данных в приложениях .NET.

<dfn title="Entity Framework 6">Entity Framework 6</dfn> (EF6) — это объектно-реляционный модуль сопоставления, предназначенный для .NET Framework, но с поддержкой для .NET Core. Впервые выпущен в 2008 вместе с .NET Framework 3.5 SP1. EF6 — это стабильный, поддерживаемый продукт, который больше не разрабатывается.

Особенности:

- **Платформа**: EF6 предназначен для .NET Framework, хотя может использоваться и в .NET Core при определенных условиях.

- **Функциональность**: Это стабильная и поддерживаемая версия, но она больше не разрабатывается. В ней реализованы многие функции, которые отсутствуют в EF Core, такие как некоторые типы запросов и поддержка определенных баз данных.

- **Подходы**: Database First, Model First и Code First.

- **Ограничения**: Не кроссплатформенна и менее модульна по сравнению с EF Core. Может быть менее эффективным для очень больших таблиц и сложных запросов.

Преимущества:

- **Высокий уровень абстракции**: Разработчики могут сосредоточиться на логике приложения, не беспокоясь о базовых таблицах и столбцах базы данных.

- **Поддержка различных источников данных**: SQL Server, Oracle, PostgreSQL и другие.

<dfn title="Entity Framework Core">Entity Framework Core</dfn> (EF Core) — это современный модуль сопоставления "объект — база данных" для .NET. Впервые выпущен в 2016 одновременно с релизом .NET Core 1.0. Он поддерживает запросы LINQ, отслеживание изменений, обновления и миграции схемы.

EF Core работает с SQL Server/Базой данных SQL Azure, SQLite, Azure Cosmos DB, MySQL, PostgreSQL и многими другими базами по модели подключаемых модулей поставщика базы данных.

Особенности:

- **Платформа**: EF Core — это кроссплатформенная версия, которая может работать на .NET Core и .NET 5+, что позволяет использовать ее на Windows, Linux и macOS.

- **Функциональность**: Это более легковесная и модульная версия, поддерживающая запросы LINQ, отслеживание изменений, обновления и миграции схемы базы данных. EF Core активно развивается и включает новые функции, такие как альтернативные ключи и пакетные обновления.

- **Ограничения**: Может иметь меньше функций по сравнению с полной версией EF, но активно развивается и улучшается.

Преимущества:

- **Открытый код**: Благодаря открытому исходному коду и расширяемому ядру, EF Core позволяет легко добавлять новые функции и оптимизировать производительность

- **Лучшая производительность**: Оптимизирована для .NET Core и .NET 5+, что делает ее более быстрой и эффективной.

- **Кроссплатформенность**: Может работать на нескольких операционных системах, включая Windows, Linux и macOS.

- **Упрощение разработки**: Позволяет быстро создавать прототипы и приложения, не заботясь о низкоуровневых деталях базы данных.

EF Core предлагает новые функции, которые не будут реализованы в EF6. Однако в настоящее время в EF Core реализованы не все функции EF6.

*Сравнение EF и EF Core*
Характеристика | EF6 | EF Core
-- | -- | --
Платформа |	.NET Framework | .NET Core, .NET 5+
Кроссплатформенность |	Нет |	Да
Активное развитие |	Нет | Да
Модульность |	Меньше | Больше
Производительность | Менее оптимизирована |	Оптимизирована

В целом, Entity Framework и Entity Framework Core — это мощные инструменты для работы с данными в приложениях .NET, позволяющие разработчикам сосредоточиться на логике приложения, а не на низкоуровневых деталях базы данных. EF имеет больше функций и поддерживает больше источников данных, но EF Core активно развивается и догоняет по функционалу. EF Core рекомендуется для новых проектов из-за своей кроссплатформенности, модульности и активного развития.[^efcore-and-ef6]

[^efcore-and-ef6]: [Сравнение EF Core и EF6](https://learn.microsoft.com/ru-ru/ef/efcore-and-ef6/)

### Работа с данными

#### Описание DbContext API
С момента своего появления, наиболее важным классом Entity Framework являлся класс **`ObjectContext`**. Именно этот класс позволял взаимодействовать с базой данных используя сущностную модель классов. Класс контекста позволяет вам создавать и выполнять запросы, отслеживать изменения в объектах и отображать эти изменения на базу данных. Класс `ObjectContext` взаимодействует с другими важными классами платформы Entity Framework, например, с классом **`ObjectSet`** — его объекты можно использовать в качестве коллекций данных из таблиц, **`ObjectQuery`** – является ядром создания запроса и т.д.

После двух выпусков Entity Framework (в версиях .NET 3.5 и 4) стало понятно, что разработчики обычно используют множество функций для работы с данными и некоторые из задач, которые мы должны были делать наиболее часто, трудно было реализовать в коде. Напомню, что в этих версиях Entity Framework поддерживался только подход Database-First, при котором модель сущностных классов генерируется автоматически и вы не можете просто настраивать код в этой модели.

Чтобы решить эту проблему, разработчики Entity Framework решили сделать более простой интерфейс для работы с данными, заключив в него все возможности `ObjectContext`, но при этом облегчив решение различных задач для работы с данными, для которых теперь вы можете использовать стандартные шаблоны. Новый набор классов был добавлен в версии Entity Framework 4.1 (EF 4.1). Главными классами новой упрощенной платформы являются `DbContext`, `DbSet` и `DbQuery`, а интерфейс для работы с этими новыми классами называют ***DbContext API***.

Фактически, после выпуска EF 4.1, платформа Entity Framework больше не была привязана к платформе .NET Framework, т.е. новые версии EF выходят отдельно от новых версий .NET Framework и доступны через *менеджер пакетов NuGet*. При этом следует отметить, что ядро платформы Entity Framework с выходом новых версий не изменилось (`сборка System.Data.Entity.dll`), при этом в каждой новой версии меняется сборка `EntityFramework.dll`.

Новые классы контекста, как и старые, обеспечивают взаимодействие между сущностными классами модели и базой данных. Классы модели, в свою очередь, обеспечивают доступ к свойствам, настройкам отношений между таблицами и другим особенностям модели. Благодаря новым классам контекста и подходу Code-First, вы можете изменять структуру базы данных, добавлять, обновлять и удалять данные используя только код. Ниже описано назначение основных классов DbContext API:

- **`DbContext`**

    Является базовым классом Entity Framework и предоставляет широкие возможности по работе с базой данных: создание запросов, отслеживание изменений и сохранение данных в базе.

- **`DbSet`**

    Описывает набор сущностных классов, который затем можно использовать в коде для создания запросов CRUD (create, read, update, delete) к данным. С помощью экземпляров этого класса описываются различные объекты базы данных (таблицы, представления, хранимые процедуры и т.д.)

- **`DbQuery`**

    Обеспечивает возможность создания запросов, при этом взаимодействовать с этим классом напрямую вам не понадобится, благодаря использованию возможностей класса `DbSet`.

- **`DbModelBuilder`**

    Этот класс является связывателем модели – он создает связь между классами модели и схемой базы данных. `DbContext` позволяет взаимодействовать с этим классом благодаря методу `OnModelCreating()`, в котором вы можете внести настройки привязки модели, перед ее построением. Напомню, такой подход к настройке модели называют Fluent API.

- **`Database`**

    Предоставляет доступ к базе данных, лежащей в основе классов модели Entity Framework. Вы можете использовать методы этого класса для создания или удаления базы данных, проверки ее существования или выполнения произвольной команды SQL. Вы также можете использовать статические методы этого класса, чтобы удалить базу данных или проверить ее существование, используя строку подключения. Этот класс доступен в классе контекста через одноименное свойство `Database`.

- **`DbExtensions`**

    Этот класс определяет несколько полезных статических методов, с помощью которых можно настроить запросы, например, отключить кэширование для запросов.

Ранее мы уже рассмотрели как создается модель данных в подходе Code-First и рассмотрели настройки этой модели с использованием Fluent API и аннотаций данных. При использовании подходов Database-First и Model-First беспокоиться о настройке модели сущностных классов не нужно, т.к. она генерируется автоматически. При этом мы не рассмотрели работу с данными (как можно добавлять, изменять или удалять данные в таблицах базы данных).

Если вы знакомы с общими концепциями реляционных баз данных, то должны знать, что инструкции языка для работы с данными (такого, например, как T-SQL) разделяются на два вида: DDL (Data Description Language) – язык описания данных и DML (Data Manipulation Language) – язык изменения данных. Фактически, до сих пор, мы рассмотрели как использовать инструкции DDL в Entity Framework, в последующих статьях мы рассмотрим работу с данными DML в Entity Framework.

#### Создание запросов
В приложениях, работающих с базами данными, возникает две задачи при работе с данными: как получить данные из базы данных и как сохранить изменения. В Entity Framework работа с данными строится на создании запросов к базе данных, используя средства языка C# (LINQ) и специальные методы класса контекста `DbContext`. В этой статье мы кратко рассмотрим синтаксические особенности запросов, а в следующих статьях увидим, как с помощью запросов можно извлекать, сохранять, изменять и удалять данные в базе.

##### Исходный проект
В качестве примера проекта, на котором мы будем тестировать наши запросы, мы будем использовать проект консольного приложения C#. Создайте новый проект, используя шаблон *Console Application*.

После этого нужно будет установить библиотеку Entity Framework в этот проект. Стоит отметить, что DbContext API является частью сборки `EntityFramework.dll`, поэтому он автоматически добавляется при установке Entity Framework в ваш проект. Для установки Entity Framework используется диспетчер пакетов NuGet, как говорилось ранее. Этот диспетчер позволяет быстро загружать нужные сборки из интернета в проект Visual Studio. Для вызова этого диспетчера можно использовать команду меню *Tools* --> *Library Package Manager* --> *Manage Nuget Packages*. В открывшемся диалоговом окне вы можете найти расширение Entity Framework и установить его в свой проект.

Теперь добавьте в проект папку *Model*, в которую добавьте новый класс *Model.cs*, содержащий модель данных. Модель сущностных классов должна выглядеть следующим образом:
```cs
using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace ExamplesEF
{
    public class Customer
    {
        public int CustomerId { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Email { get; set; }
        public int Age { get; set; }

        [Column(TypeName = "Image")]
        public byte[] Photo { get; set; }

        // Ссылка на заказы
        public List<Order> Orders { get; set; }
    }

    public class Order
    {
        public int OrderId { get; set; }
        public string ProductName { get; set; }
        public string Description { get; set; }
        public int Quantity { get; set; }
        public DateTime PurchaseDate { get; set; }

        // Ссылка на покупателя
        public Customer Customer { get; set; }
    }
}
```

Здесь используется простая модель с двумя классами, описывающими покупателя и его заказы.

Стоит отметить, что мы будем использовать подход Code-First при рассмотрении работы с данными в Entity Framework, хотя эта работа не зависит от конкретного подхода. При любом подходе модель данных использует класс контекста, унаследованный от `DbContext`, соответственно запросы для использования данных будут одинаковыми. Я использую подход Code-First, т.к. он обеспечивает настройку структуры базы данных из управляемого кода C#. Вы можете использовать подходы Model-First или Database-First при работе с примерами.

Далее необходимо будет добавить класс контекста, связывающий сущностные классы с базой данных. Для этого добавьте новый файл *SampleContext.cs* в папку *Model*, имеющий следующее содержимое:
```cs
using System.Data.Entity;

namespace ExamplesEF
{
    public class SampleContext : DbContext
    {
        public SampleContext() : base("MyShop")
        {
            // Указывает EF, что если модель изменилась,
            // нужно воссоздать базу данных с новой структурой
            Database.SetInitializer(
                new DropCreateDatabaseIfModelChanges<SampleContext>());
        }

        public DbSet<Customer> Customers { get; set; }
        public DbSet<Order> Orders { get; set; }
    }
}
```

После этого вы можете добавить следующий код в программу:
```cs
static void Main()
{
    SampleContext context = new SampleContext();
    context.Customers.Add(new Customer()
    {
        FirstName = "Вася",
        Age = 20
    });

    context.SaveChanges();
}
```

В этом примере добавляется новый покупатель в таблицу `Customers`. Теперь, если вы запустите программу Entity Framework создаст базу данных `MyShop` на локальном сервере SQLEXPRESS (если эта база данных еще не была создана). В последующих статьях мы будем показывать примеры, которые используются в этом консольном приложении. Далее мы опишем некоторые особенности запросов, которые используются в Entity Framework.

##### Использование запросов Entity SQL
<dfn title="Entity SQL">Entity SQL</dfn> — это язык запросов, используемый в Entity Framework для выполнения запросов к данным сущностей. Он является независимым от хранилища, что означает, что запросы можно выполнять без знания конкретной базы данных или ее схемы.

Основные особенности Entity SQL:
- **Независимость от хранилища**: Entity SQL позволяет писать запросы, которые не зависят от конкретной базы данных или ее схемы. Это упрощает разработку приложений, работающих с различными источниками данных.

- **Синтаксис, аналогичный SQL**: Entity SQL имеет синтаксис, похожий на SQL, что делает его более понятным для разработчиков, знакомых с SQL.

- **Поддержка динамических запросов**: Entity SQL позволяет создавать запросы динамически во время выполнения, что полезно в ситуациях, когда структура запроса определяется на основе пользовательского ввода или других динамических факторов.

Entity SQL используется в Entity Framework для выполнения запросов к данным сущностей. Он может быть применен в следующих случаях:

- **Динамические запросы**: Когда запрос должен быть сформирован во время выполнения.

- **Определение запросов в модели**: Entity SQL используется для определения запросов в модели данных.

- **Работа с `EntityClient`**: Для возврата данных сущностей в виде наборов строк с использованием `EntityDataReader`.

Запросы Entity SQL используют SQL-подобный синтаксис, при этом взаимодействие с базой данных происходит с помощью вызова SQL-команд. Фактически такой подход к созданию запросов в Entity Framework идентичен использованию ADO.NET, поэтому в последующих примерах мы не будем никогда его использовать. Но давайте рассмотрим простой пример использования такого запроса в Entity Framework:
```cs
using System;
using System.Linq;
using System.Data.Common;
using System.Data.SqlClient;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Core.Objects;

namespace ExamplesEF
{
    class Program
    {
        static void Main()
        {
            // Получить объект ObjectContext из DbContext
            ObjectContext context =
                (new UsersEntities() as IObjectContextAdapter).ObjectContext;

            // Создать объект подключения и команду
            SqlConnection connection = new SqlConnection(
                @"Data Source=.\SQLEXPRESS;Initial Catalog=Users");

            // Создать запрос
            ObjectQuery<DbDataRecord> Users =
                context.CreateQuery<DbDataRecord>("SELECT c.FirstName FROM Users AS c");

            // Отобразить имя первого пользователя в таблице Users
            Console.WriteLine(Users != null ?
                Users.First()["FirstName"].ToString()
                : "Таблица пустая");

            // Отобразить имя первого покупателя
            if (Customers != null && Customers.Any())
            {
                Console.WriteLine(Customers.First()["FirstName"].ToString());
            }
            else
            {
                Console.WriteLine("Таблица пустая");
            }
        }
    }
}
```

Как видите, Entity SQL напрямую не поддерживается в современных версиях Entity Framework, т.к. нам нужно использовать старый класс контекста `ObjectContext`. Мы получили экземпляр этого класса из объекта `SampleContext`, путем приведения его к интерфейсу `IObjectContextAdapter`. Затем мы использовали SQL-команды для загрузки данных из таблицы базы данных. Очевидно, что данный подход не использует одно из главных преимуществ Entity Framework – использование объектной модели базы данных, поэтому мы не будем его использовать далее.

Стоит отметить, что в DbContext API есть способ выполнять произвольные SQL-инструкции. Для этого служит метод `ExecuteSqlCommand()` класса `Database`, объект которого доступен через одноименное свойство класса контекста. Но при этом, этот метод был создан для того, чтобы вы могли выполнить произвольную SQL-инструкцию для обращения к базе данных (например, вы можете изменить кодировку таблицы или добавить триггер), но этот метод не стоит использовать для извлечения или работы с данными.

##### Использование LINQ
Базовым подходом к написанию запросов в Entity Framework является использование расширения языка C# — LINQ, которое предоставляет набор методов для работы с коллекциями. До появления версии EF 4.1 при использовании LINQ в Entity Framework задействовался класс контекста `ObjectContext`. Далее мы будем рассматривать запросы LINQ to Entities при использовании класса контекста, унаследованного от `DbContext`.

LINQ тесно интегрирован с различными шаблонами программирования .NET и обеспечивает строго типизированный язык запросов для обращения к объектам модели. Запрос определяется с помощью классов и их свойств, которые составляют модель (в отличие от Entity SQL, где мы использовали запросы SQL). Это обеспечивает ряд преимуществ:

- уменьшается время компиляции, т.к. не нужно создавать кучу дополнительных объектов, как при использовании Entity SQL;

- снижается риск допустить ошибку в запросе, который довольно высок при использовании запросов SQL;

- удобные подсказки IntelliSense IDE-среды Visual Studio позволяют довольно быстро набирать нужные запросы;

- строго-типизированные методы LINQ позволяют легко находить нужный объект сущностной модели в запросе.

Стоит отметить, что расширение LINQ не является чем-то специфическим для Entity Framework и может повсеместно использоваться в коде приложения для работы с коллекциями. В контексте Entity Framework, коллекции являются множеством строк таблицы, с которыми можно работать посредством LINQ. Давайте реализуем функциональность предыдущего примера с использованием LINQ-запроса:
```cs
using System;
using System.Linq;

namespace ExamplesEF
{
    class Program
    {
        static void Main()
        {
            // Создаем экземпляр класса контекста
            SampleContext context = new SampleContext();

            // Используем LINQ-запрос для извлечения первого заказчика
            var name = context.Customers
                              .Select(c => c.FirstName)
                              .FirstOrDefault();

            Console.WriteLine(name);
        }
    }
}
```

Этот пример гораздо проще и понятней, чем тот, что мы использовали при демонстрации Entity SQL. Здесь мы использовали метод расширения LINQ – `FirstOrDefault()`, который выбирает первую запись из коллекции (она же таблица, в понимании EF) `Users`. Стоит отметить, что базовые методы расширения LINQ находятся в пространстве имен `System.Linq`, при этом Entity Framework также предлагает некоторые методы расширения, которые находятся в пространстве имен `System.Data.Entity`.

Стоит отметить также, что LINQ поддерживает использования синтаксиса SQL в запросах (синтаксис с вызовом цепочки методов, как в предыдущем примере, называется синтаксисом точечной нотации). Эта возможность удобна для программистов, тесно работающих с базами данных и хорошо знающих языки запросов, например T-SQL. Ниже показан пример использования синтаксиса SQL, которые работает также, как и показанные выше примеры:
```cs
string name = (from customer in context.Customers
               select customer.FirstName)
               .FirstOrDefault();

Console.WriteLine(name);
```

Стоит отметить что этот синтаксис довольно ограничен, поэтому в этом примере нам пришлось вызвать метод `FirstOrDefault()` с использованием синтаксиса точечной нотации, т.к. для этого метода не определен соответствующий псевдоним.

После рассмотрения примеров использования LINQ у вас наверняка возникнет вопрос, как Entity Framework интерпретирует эти запросы на связанные запросы SQL? Ответ на этот вопрос довольно простой в контексте нашего примера. Вызов коллекции `Customers` объекта контекста говорит EF, что нужно сгенерировать запрос `SELECT` для выборки всех записей из таблицы. После этого EF видит вызов метода `Select(u => u.FirstName)`, который указывает, что нас интересует только имя пользователя, хранящееся в столбце `FirstName`. Затем следует вызов метода `FirstOrDefault()`, что говорит EF, что нам не нужны все записи из таблицы `Users`, а нужна только первая запись. В результате Entity Framework сгенерирует следующий SQL-код для обращения к базе данных:
```sql
SELECT TOP (1)
    [c].[FirstName] AS [FirstName]
    FROM [dbo].[Customers] AS [c]
```

Если вы хотите просматривать генерируемый SQL-код для LINQ-запросов, то вы можете использовать журнал логов операций к базе данных, который можно включить с помощью свойства `Database.Log`. Этому свойству передается делегат, который можно реализовать с помощью лямбда-выражения и указать, куда нужно записывать лог операций. Использование этого свойства показано в примере ниже:
```cs
static void Main()
{
    // Создаем экземпляр класса контекста
    SampleContext context = new SampleContext();

    context.Database.Log = (s => Console.WriteLine(s));

    // Используем LINQ-запрос для извлечения первого заказчика
    var name = context.Customers
      .Select(c => c.FirstName)
      .FirstOrDefault();


    Console.WriteLine(name);
}
```

После запуска этого примера, в консоль будет выведена SQL-команда для этого запроса. Также, SQL-запрос можно вывести, например, в окно отладчика среды Visual Studio:
```cs
// ...

context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

// ...
```

Класс `System.Diagnostics.Debug` как раз является средством взаимодействия между кодом и отладчиком Visual Studio. Сгенерированный код отображается на панели *Output*.

##### Отложенная компиляция LINQ-запросов
Как описывалось только что, LINQ компилирует запросы из управляемого кода в SQL-инструкции. При этом, если мы удалим вызов метода `FirstOrDefault()` в примере выше, сам запрос к базе данных будет выполняется не при инициализации переменной name, а при ее вызове в методе `Console.WriteLine` (в этом случае будет возвращаться коллекция имен пользователей из таблицы). Такой подход называется <dfn title="отложенное выполнение LINQ-запросов">отложенным выполнением LINQ-запросов</dfn>, т.е. запрос компилируется не при его объявлении, а при непосредственном вызове переменной, содержащей этот запрос, в коде.

Это обеспечивается благодаря тому, что класс `DbSet`, экземпляр которого мы получаем через свойство `context.Customers`, реализует интерфейс `IQueryable`. Этот интерфейс специфичен для LINQ и находится в пространстве имен `System.Linq`. Он является производным от интерфейса коллекций `IEnumerable` и обеспечивает отложенное выполнение запросов. Метод `FirstOrDefault()` относится к неотложенным запросам, поэтому, в предыдущем примере запрос будет выполняться при инициализации переменной name.

Чтобы быстро понять концепцию отложенных запросов LINQ, достаточно просто взглянуть на следующие примеры:
```cs
// Используем отложенный LINQ-запрос
// для извлечения имен всех заказчиков
IQueryable<string> names = context.Customers
  .Select(c => c.FirstName);

foreach (string name in names)
  Console.WriteLine(name);


// Используем неотложенный LINQ-запрос
// для извлечения имен всех заказчиков
IQueryable<string> names = context.Customers
  .Select(c => c.FirstName).ToList();

foreach (string name in names)
  Console.WriteLine(name);
```

В первом примере запрос выполняется при первой итерации цикла `foreach`, что является стандартным поведением отложенных запросов LINQ. Во втором примере мы использовали не отложенный метод `ToList()`, для выполнения запроса при объявлении переменной `names`. Понимание отложенной природы запросов в LINQ является важным при работе с Entity Framework, т.к. выполнение запроса в коде в Entity Framework означает, что мы выполняем запрос к базе данных.

### LINQ
*[LINQ]: Language Integrated Query
<dfn title="LINQ">LINQ</dfn> (Language Integrated Query) — это мощный инструмент в C#, который позволяет выполнять запросы и манипуляции с данными в виде языковых конструкций. LINQ обеспечивает стандартизированный синтаксис для работы с различными источниками данных, такими как коллекции, базы данных, XML-документы и другие.

Основные особенности LINQ:
- **Стандартизированный синтаксис**: LINQ позволяет использовать единый подход для запросов к различным типам данных, что упрощает разработку и поддержку приложений.

- **Синтаксис запросов**: LINQ поддерживает декларативный синтаксис запросов, который напоминает SQL, но интегрирован в язык C#.

Преимущества LINQЖ
- **Удобство использования**: LINQ позволяет писать более краткий и читаемый код, что упрощает разработку и сопровождение приложений.

- **Выразительность**: LINQ позволяет сосредоточиться на логике запроса, а не на деталях реализации.

- **Гибкость**: LINQ может использоваться с различными источниками данных, что делает его универсальным инструментом для разработки приложений

Разновидности LINQ:

- **LINQ to Objects**: Для работы с массивами и коллекциями.

- **LINQ to Entities**: Используется для запросов к базам данных через Entity Framework.

- **LINQ to XML**: Для работы с XML-документами.

- **LINQ to DataSet**: Для выполнения запросов к наборам данных ADO.NET.

- **Parallel LINQ (PLINQ)**: Для параллельного выполнения запросов

Ниже представлены разделы, которые входят в данную тему:

- **LINQ to Objects** — название, данное API-интерфейсу `IEnumerable<T>` для *стандартных операций запросов* (*Standard Query Operators*). Именно LINQ to Objects позволяет выполнять запросы к массивам и находящимся в памяти коллекциям данных. Стандартные операции запросов — это статические методы класса `System.Linq.Enumerable`, которые используются для создания запросов LINQ to Objects.

- **LINQ to XML** — название, назначенное API-интерфейсу LINQ, который ориентирован на работу с XML. В Microsoft не только добавили необходимые библиотеки XML для работы с LINQ, но также восполнили недостатки стандартной модели XML DOM, существенно облегчив работу с XML. Прошли времена, когда нужно было создавать XmlDocument только для того, чтобы поработать с небольшим фрагментом XML-кода. Чтобы воспользоваться преимуществами LINQ to XML, в проект понадобится добавить ссылку на сборку `System.Xml.Linq.dll` и директиву `using System.Xml.Linq`.

- **LINQ to DataSet** — название, данное API-интерфейсу LINQ, который предназначен для работы с `DataSet`. У многих разработчиков есть масса кода, полагающегося на `DataSet`. Те, кто не хотят отставать от новых веяний, но и не готовы переписывать свой код, благодаря этому интерфейсу могут воспользоваться всей мощью LINQ.

- **LINQ to SQL** — наименование, присвоенное API-интерфейсу `IQueryable<T>`, который позволяет запросам LINQ работать с базой данных Microsoft SQL Server. Чтобы воспользоваться преимуществами LINQ to SQL в проект понадобится добавить ссылку на сборку `System.Data.Linq.dll`, а также директиву `using System.Data.Linq`.

- **LINQ to Entities** — альтернативный API-интерфейс LINQ, используемый для обращения к базе данных. Он отделяет сущностную объектную модель от физической базы данных, вводя логическое отображение между ними двумя. С таким отделением возрастает мощь и гибкость, но также растет и сложность. Если нужна более высокая гибкость, чем обеспечивается LINQ to SQL, имеет смысл рассмотреть эту альтернативу.

    В частности, когда необходимо ослабить связь между сущностной объектной моделью и базой данных, если сущностные объекты конструируются из нескольких таблиц или требуется большая гибкость в моделировании сущностных объектов, то в этом случае LINQ to Entities может стать оптимальным выбором.

- **Parallel LINQ**. Формально отдельного продукта LINQ, который нужно было бы получать отдельно, не существует. LINQ полностью интегрирован в .NET Framework, начиная с версии 3.5 и Visual Studio 2008. В NET 4.0 и Visual Studio 2010 добавлена поддержка средств Parallel LINQ, которые рассматриваются в данном разделе.


#### Появление LINQ
По мере становления платформы .NET Framework и поддерживаемых ею языков C# и VB, стало ясно, что одной из наиболее проблемных областей для разработчиков остается доступ к данным из разных источников. В частности, доступ к базе данных и манипуляции XML часто в лучшем случае запутаны, а в худшем — проблематичны.

Проблемы, связанные с базами данных, многочисленны. **Первая сложность** в том, что нельзя программно взаимодействовать с базой данных на уровне естественного языка. Это приводит к синтаксическим ошибкам, которые не проявляются вплоть до момента запуска. Неправильные ссылки на поля базы данных тоже не обнаруживаются. Это может пагубно отразиться на программе, особенно если произойдет во время выполнения кода обработки ошибок. Нет ничего хуже, чем сбой механизма обработки ошибок из-за синтаксически неверного кода, который никогда не тестировался. Иногда это неизбежно из-за непредсказуемого поведения ошибки. Наличие кода базы данных, который не проверяется во время компиляции, определенно может привести к этой проблеме.

**Вторая проблема** связана с неудобством, которое вызвано различными типами данных используемыми определенным доменом данных, например, разница между типами базы данных или типами XML и типами данных в языке, на котором написана программа. В частности, серьезные сложности могут вызывать типы времени и даты.

Разбор итерация и манипулирование XML-разметкой могут быть достаточно утомительными. Часто фрагмент XML — это все, что нужно, но из-за требований интерфейса W3C DOM XML API объект `XmlDocument` должен быть обязательно создан, чтобы выполнять различные операции над фрагментом XML.

Вместо того чтобы просто добавить больше классов и методов для постепенного восполнения этих недостатков, в Microsoft решили пойти на один шаг дальше в абстрагировании основ запросов данных из этих конкретных доменов данных. В результате появился <dfn title="LINQ">LINQ</dfn> — технология Microsoft, предназначенная для поддержки запросов к данным всех типов на уровне языка. Эти типы включают массивы и коллекции в памяти, базы данных, документы XML и многое другое.

LINQ включает в себя около 50 стандартных операций запросов, разделяемых на 2 большие группы — <dfn title="отложенные операции">отложенные операции</dfn> (выполняются не во время инициализации, а только при их вызове) и <dfn title="не отложенные операции">не отложенные операции</dfn> (выполняются сразу).

По большей части LINQ ориентирован на ***запросы*** — будь то запросы, возвращающие набор подходящих объектов, единственный объект или подмножество полей из объекта либо набора объектов. В LINQ этот возвращенный набор называется <dfn title="последовательность">последовательностью</dfn> (<dfn title="sequence">sequence</dfn>). Большинство последовательностей LINQ имеют тип `IEnumerable<T>`, где `T` — тип данных объектов, находящихся в последовательности. Например, если есть последовательность целых чисел, они должны храниться в переменной типа `IEnumerable<int>`. Вы увидите, что `IEnumerable<T>` буквально господствует в LINQ и очень многие методы LINQ возвращают `IEnumerable<T>`.

Может показаться, что LINQ — это нечто, связанное только с запросами, поскольку расшифровывается как ***язык интегрированных запросов*** (***Language Integrated Query***). Однако не думайте о нем лишь в этом контексте. Предпочтительнее воспринимать LINQ как *механизм итерации данных* (*data iteration engine*), но возможно в Microsoft не захотели обозначать эту технологию аббревиатурой DIE ("умереть").

Приходилось ли вам когда-нибудь вызывать метод, возвращающий данные в структуре, которую затем приходилось преобразовывать в еще одну структуру данных, прежде чем передать другому методу? Предположим, например, что вызывается метод `А`, и этот метод возвращает массив типа `string`, содержащий числовые значения в виде строк. Затем нужно вызвать метод `В`, но метод `В` требует массива целых чисел. Обычно приходится организовывать цикл для прохода по массиву строк и наполнения вновь сконструированного массива целых чисел. Давайте рассмотрим краткий пример мощи Microsoft LINQ.

Предположим, что имеется массив строк, которые приняты от метода `А`, как показано ниже:
```cs
string[] numbers = { "40", "2012", "176", "5" };

// Преобразуем массив строк в массив типа int используя LINQ
int[] nums = numbers.Select(s => Int32.Parse(s)).ToArray();

foreach (int n in nums)
       Console.Write(n + " ");
```

Вот и все. Что может быть проще?

Возможно, вы подумали, что просто в строках отброшены ведущие пробелы. Но убедит ли вас, если отсортировать результат? Если бы это были по-прежнему строки, то 5 окажется в конце, а 176 — в начале. Ниже приведен код, который выполняет преобразование и сортирует вывод:
```cs
string[] numbers = { "40", "2012", "176", "5" };

// Преобразуем массив строк в массив типа int и сортируем по возрастанию используя LINQ
int[] nums = numbers.Select(s => Int32.Parse(s)).OrderBy(s => s).ToArray();
```

Не правда ли гладко? Вы можете возразить, что все это прекрасно, но пример был очень прост. Давайте рассмотрим более сложный пример. Предположим, что есть некоторый код, содержащий класс `Employee`. В этом классе имеется метод, возвращающий всех сотрудников. Также предположим, что есть другой код, включающий класс `Contact`, с определенным в нем методом, публикующим контакты. Пусть необходимо опубликовать всех сотрудников в виде контактов.

Задача выглядит достаточно простой, но здесь таится ловушка. Общий метод `Employee`, который извлекает всех сотрудников, возвращает их в списке `ArrayList` хранящем объекты `Employee`, а метод `Contact`, публикующий контакты, требует массива объектов типа `Contact`. Ниже показан обычный для такого случая код:
```cs
public class Employee
{
    public int id;
    public string firstName;
    public string lastName;

    public static ArrayList GetEmployees()
    {
        ArrayList al = new ArrayList();
        // В реальном коде коллекция заполнялась бы из базы данных
        al.Add(new Employee { id = 1, firstName = "Alexandr", lastName = "Erohin" });
        al.Add(new Employee { id = 2, firstName = "Alexey", lastName = "Volkov" });
        al.Add(new Employee { id = 3, firstName = "Dmitry", lastName = "Moiseenko" });
        return (al);
    }
}

public class Contact
{
    public int id;
    public string Name;

    public static void PublishContacts(Contact[] contacts)
    {
        foreach (Contact c in contacts)
            Console.WriteLine("Contact Id: {0} Contact: {1}",c.id,c.Name);
    }
}
```

Как видите, метод `GetEmployees` возвращает `ArrayList`. Метод `PublishContacts` требует передачи ему массива объектов `Contact`. Ранее это всегда требовало итерации по списку `ArrayList`, который возвращен методом `GetEmployee` и создания нового массива типа `Contact` для передачи методу `PublishContacts()`. Как можно видеть ниже, LINQ значительно облегчает решение этой задачи:
```cs
class Program
{
    static void Main()
    {
        ArrayList al = Employee.GetEmployees();
        Contact[] contacts = al
            .Cast<Employee>()
            .Select(e => new Contact
            {
                id = e.id,
                Name = string.Format("{0} {1}", e.firstName, e.lastName)
            })
            .ToArray<Contact>();

        Contact.PublishContacts(contacts);
        Console.ReadLine();
    }
}
```

Чтобы преобразовать коллекцию `ArrayList` объектов `Employee` в массив объектов `Contact`, сначала выполняется приведение `ArrayList` объектов `Employee` к последовательности `IEnumerable<Employee>` с использованием стандартной операции запросов `Cast`. Это необходимо, потому что использован унаследованный класс коллекции `ArrayList`. С синтаксической точки зрения в коллекции `ArrayList` хранятся объекты класса `System.Object`, а не объекты типа класса `Employee`. Поэтому они должны быть приведены к объектам `Employee`. Если бы метод `GetEmployees` возвращал обобщенную коллекцию `List`, необходимости в этом не было бы. Однако на момент написания унаследованного кода этот тип коллекции не был доступным.

Затем на возвращенной последовательности объектов Em`ployee` вызывается операция `Select`, и в лямбда-выражении — коде, переданном внутрь вызова метода `Select`, создается и инициализируется экземпляр объекта `Contact` с использованием для этого средства инициализации объектов C#, чтобы присвоить значения входного элемента `Employee` вновь сконструированному выходному элементу `Contact`. [<dfn title="лямбда-выражение">Лямбда-выражение</dfn> (<dfn title="lambda expression">lambda expression</dfn>)](https://professorweb.ru/my/csharp/charp_theory/level10/10_6.php) — это средство C#, которое является сокращенным способом указания анонимных методов. И, наконец, последовательность вновь сконструированных объектов `Contact` преобразуется в массив объектов `Contact` с применением операции `ТоАrrау`, потому что этого требует метод `PublishContacts`. Разве не изящно?

#### Основы LINQ
<dfn title="LINQ">LINQ</dfn> (Language-Integrated Query) представляет простой и удобный язык запросов к источнику данных. В качестве источника данных может выступать объект, реализующий интерфейс `IEnumerable` (например, стандартные коллекции, массивы), набор данных `DataSet`, документ XML. Но вне зависимости от типа источника LINQ позволяет применить ко всем один и тот же подход для выборки данных.

Существует несколько разновидностей LINQ:

- **LINQ to Objects**: применяется для работы с массивами и коллекциями

- **LINQ to Entities**: используется при обращении к базам данных через технологию Entity Framework

- **LINQ to XML**: применяется при работе с файлами XML

- **LINQ to DataSet**: применяется при работе с объектом DataSet

- **Parallel LINQ** (**PLINQ**): используется для выполнения параллельных запросов

В этой главе речь пойдет прежде всего о **LINQ to Objects**, но в последующих материалах также будут затронуты и другие разновидности LINQ. Основная часть функциональности LINQ сосредоточена в пространстве имен **`System.LINQ`**. В проектах под .NET 6 данное пространство имен подключается по умолчанию.

В чем же удобство LINQ? Посмотрим на простейшем примере. Выберем из массива строки, которые начинаются на определенную букву, например, букву "T", и отсортируем полученный список:
```cs
string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// создаем новый список для результатов
var selectedPeople = new List<string>();
// проходим по массиву
foreach (string person in people)
{
    // если строка начинается на букву T, добавляем в список
    if (person.ToUpper().StartsWith("T"))
        selectedPeople.Add(person);
}
// сортируем список
selectedPeople.Sort();

foreach (string person in selectedPeople)
    Console.WriteLine(person);
```

Для отфильтрованных строк создается специальный список. Затем в цикле проходим по всем элементам массива и, если они соответствуют условию (начинаются на букву T), то добавляем их в этот список. Затем сортируем список по возрастанию. И в конце элементы полученного списка выводим на консоль:
```
Tim
Tom
Tomas
```

Хотя подобный подход вполне работает, однако LINQ позволяет значительно сократить код с помощью интуитивно понятного и краткого синтаксиса.

Для работы с колекциями можно использовать два способа:

- Операторы запросов LINQ

- Методы расширений LINQ

Рассмотрим оба способа

#### Операторы запросов LINQ
Операторы запросов LINQ в каком-то роде частично напоминают синтаксис запросов SQL, поэтому если вы работали когда-нибудь с sql-запросами, то будет проще понять общую концепцию. Итак, изменим предыдущий пример, применив операторы запросов LINQ:
```cs
string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

// создаем новый список для результатов
var selectedPeople = from p in people // передаем каждый элемент из people в переменную p
                    where p.ToUpper().StartsWith("T") //фильтрация по критерию
                    orderby p  // упорядочиваем по возрастанию
                    select p; // выбираем объект в создаваемую коллекцию

foreach (string person in selectedPeople)
    Console.WriteLine(person);
```

Прежде всего, как мы видим, код стал меньше и проще, а результат будет тем же. В принципе все выражение можно было бы записать в одну строку:
```cs
var selectedPeople = from p in people where p.ToUpper().StartsWith("T") orderby p  select p;
```

Но для более понятной логической разбивки я поместил каждое отдельное подвыражение на отдельной строке.

Простейшее определение запроса LINQ выглядит следующим образом:
```cs
from переменная in набор_объектов
select переменная;
```

Итак, что делает этот запрос LINQ? Выражение `from p in people` проходит по всем элементам массива `people` и определяет каждый элемент как `p`. Используя переменную `p` мы можем проводить над ней разные операции.

Несмотря на то, что мы не указываем тип переменной `p`, выражения LINQ являются строго типизированными. То есть среда автоматически распознает, что набор `people` состоит из объектов `string`, поэтому переменная `p` будет рассматриваться в качестве строки.

Далее с помощью оператора `where` проводится фильтрация объектов, и если объект соответствует критерию (в данном случае начальная буква должна быть "T"), то этот объект передается дальше.

Оператор `orderby` упорядочивает по возрастанию, то есть сортирует выбранные объекты.

Оператор `select` передает выбранные значения в результирующую выборку, которая возвращается LINQ-выражением.

В данном случае результатом выражения LINQ является объект `IEnumerable<T>`. Нередко результирующая выборка определяется с помощью ключевого слова `var`, тогда компилятор на этапе компиляции сам выводит тип.

#### Методы расширения LINQ
Кроме стандартного синтаксиса `from .. in .. select` для создания запроса LINQ мы можем применять специальные методы расширения, которые определены для интерфейса `IEnumerable`. Как правило, эти методы реализуют ту же функциональность, что и операторы LINQ типа `where` или `orderby`.

Например:
```cs
string[] people = { "Tom", "Bob", "Sam", "Tim", "Tomas", "Bill" };

var selectedPeople = people.Where(p => p.ToUpper().StartsWith("T")).OrderBy(p => p);

foreach (string person in selectedPeople)
    Console.WriteLine(person);
```

Запрос `people.Where(p=>p.ToUpper().StartsWith("T")).OrderBy(p => p)` будет аналогичен предыдущему. Он состоит из цепочки методов `Where` и `OrderBy`. В качестве аргумента эти методы принимают делегат или лямбда-выражение.

И хотя ряд действий мы можем реализовать как с помощью операторов запросов LINQ, так и с помощью методов расширений LINQ, но не каждый метод расширения имеет аналог среди операторов LINQ. И в этом случае можно сочетать оба подхода. Например, используем стандартный синтаксис linq и метод расширения `Count()`, который возвращает количество элементов в выборке:
```cs
int number = (from p in people where p.ToUpper().StartsWith("T") select p).Count();
Console.WriteLine(number); // 3
```

#### Список используемых методов расширения LINQ
- **`Select`**: определяет проекцию выбранных значений

- **`Where`**: определяет фильтр выборки

- **`OrderBy`**: упорядочивает элементы по возрастанию

- **`OrderByDescending`**: упорядочивает элементы по убыванию

- **`ThenBy`**: задает дополнительные критерии для упорядочивания элементов возрастанию

- **`ThenByDescending`**: задает дополнительные критерии для упорядочивания элементов по убыванию

- **`Join`**: соединяет две коллекции по определенному признаку

- **`Aggregate`**: применяет к элементам последовательности агрегатную функцию, которая сводит их к одному объекту

- **`GroupBy`**: группирует элементы по ключу

- **`ToLookup`**: группирует элементы по ключу, при этом все элементы добавляются в словарь

- **`GroupJoin`**: выполняет одновременно соединение коллекций и группировку элементов по ключу

- **`Reverse`**: располагает элементы в обратном порядке

- **`All`**: определяет, все ли элементы коллекции удовлетворяют определенному условию

- **`Any`**: определяет, удовлетворяет хотя бы один элемент коллекции определенному условию

- **`Contains`**: определяет, содержит ли коллекция определенный элемент

- **`Distinct`**: удаляет дублирующиеся элементы из коллекции

- **`Except`**: возвращает разность двух коллекцию, то есть те элементы, которые создаются только в одной коллекции

- **`Union`**: объединяет две однородные коллекции

- **`Intersect`**: возвращает пересечение двух коллекций, то есть те элементы, которые встречаются в обоих коллекциях

- **`Count`**: подсчитывает количество элементов коллекции, которые удовлетворяют определенному условию

- **`Sum`**: подсчитывает сумму числовых значений в коллекции

- **`Average`**: подсчитывает cреднее значение числовых значений в коллекции

- **`Min`**: находит минимальное значение

- **`Max`**: находит максимальное значение

- **`Take`**: выбирает определенное количество элементов

- **`Skip`**: пропускает определенное количество элементов

- **`TakeWhile`**: возвращает цепочку элементов последовательности, до тех пор, пока условие истинно

- **`SkipWhile`**: пропускает элементы в последовательности, пока они удовлетворяют заданному условию, и затем возвращает оставшиеся элементы

- **`Concat`**: объединяет две коллекции

- **`Zip`**: объединяет две коллекции в соответствии с определенным условием

- **`First`**: выбирает первый элемент коллекции

- **`FirstOrDefault`**: выбирает первый элемент коллекции или возвращает значение по умолчанию

- **`Single`**: выбирает единственный элемент коллекции, если коллекция содержит больше или меньше одного элемента, то генерируется исключение

- **`SingleOrDefault`**: выбирает единственный элемент коллекции. Если коллекция пуста, возвращает значение по умолчанию. Если в коллекции больше одного элемента, генерирует исключение

- **`ElementAt`**: выбирает элемент последовательности по определенному индексу

- **`ElementAtOrDefault`**: выбирает элемент коллекции по определенному индексу или возвращает значение по умолчанию, если индекс вне допустимого диапазона

- **`Last`**: выбирает последний элемент коллекции

- **`LastOrDefault`**: выбирает последний элемент коллекции или возвращает значение по умолчанию

### LINQ to Entities

#### Обзор LINQ to Entities
<dfn title="LINQ to Entities">LINQ to Entities</dfn> — это часть платформы ADO.NET Entity Framework, которая позволяет выполнять запросы к базе данных, используя синтаксис LINQ. Это мощный инструмент для работы с данными в объектно-ориентированной парадигме, что упрощает взаимодействие с базами данных без необходимости писать SQL-запросы напрямую.

LINQ to SQL — это система объектно-реляционного отображения начального уровня. LINQ to Entities — это часть платформы ADO.NET Entity Framework, предоставляющая более высокую гибкость и больше средств, чем LINQ to SQL, но следующая за LINQ to SQL в отношении адаптации, из-за повышенной сложности и ранних выпусков, которым пока недостает ключевых средств.

API-интерфейс Entity Framework спроектирован для работы с любыми базами данных, поддерживающими ADO (а не только с SQL Server), и даже включает собственный диалект независимого от поставщика языка SQL, который можно применять в качестве альтернативы LINQ. Фактически Entity Framework обладает настолько широким набором средств, что для их описания понадобилась бы отдельная книга. Здесь будет показано, как запустить и использовать только важнейшие части Entity Framework, относящиеся к LINQ to Entities.

Имеется некоторая путаница с терминами. API-интерфейсы LINQ to SQL и Entity Framework делают нечто схожее, а потому не удивительно, что в них используется общая терминология.

*[EDM]: Entity Data Model
Подобно LINQ to SQL, LINQ to Entities позволяет работать с объектами, которые представляют информацию из базы данных, выполнять LINQ-запросы, изменять значения, добавлять и удалять объекты. И так же, как LINQ to SQL, первый шаг в направлении использования этих средств предусматривает генерацию классов, отображающих содержимое базы данных на объекты — то, что делается при создании сущностной модели данных (entity data model — EDM). Модель EDM состоит из набора объектов и свойств, которые используются для взаимодействия с данными.

Основные особенности LINQ to Entities:
- **Объектно-реляционное сопоставление**: LINQ to Entities позволяет работать с данными как с объектами, что упрощает разработку и сопровождение приложений.

- **Независимость от базы данных**: LINQ to Entities может работать с различными базами данных, преобразуя запросы LINQ в SQL для конкретной базы данных.

- **Высокая гибкость**: Предоставляет больше возможностей и гибкости по сравнению с LINQ to SQL, что делает его более подходящим для сложных приложений.

- **Использование EDM**: Для работы с LINQ to Entities необходимо создать сущностную модель данных (Entity Data Model, EDM), которая сопоставляет объекты с таблицами базы данных.

Преимущества LINQ to Entities:
- **Упрощение запросов**: LINQ to Entities позволяет писать запросы в виде выражений, похожих на SQL, но интегрированных в язык C#.

- **Гибкость**: Может работать с различными базами данных, что делает его универсальным инструментом для разработки приложений.

- **Объектно-ориентированный подход**: Работа с данными в виде объектов упрощает разработку и сопровождение приложений.

Сравнение с LINQ to SQL:
- LINQ to SQL более прост и эффективен для работы с базами данных SQL Server, но менее гибок и масштабируем по сравнению с LINQ to Entities.

- LINQ to Entities обеспечивает более высокую гибкость и масштабируемость, но может быть более сложным в настройке и использовании.

#### Загрузка данных
В предыдущей статье мы рассмотрели как создаются LINQ-запросы в Entity Framework. В этой и последующих статьях мы рассмотрим *операции CRUD* (create, read, update, delete) для работы с данными. Для извлечения данных из таблиц в SQL используется инструкция `SELECT`. Знать детали SQL-запросов вам не нужно, т.к. Entity Framework заботится о преобразовании LINQ-запросов в SQL.

Для получения всех данных из таблицы вам даже не нужно использовать LINQ-запрос, вы можете просто использовать свойство класса контекста, ссылающееся на класс модели и имеющее тип `DbSet<T>`. Entity Framework создаст запрос в базу данных для загрузки всех данных из таблицы, связанной с этим классом модели. Давайте добавим метод `GetAllCustomers()` в наш консольный проект, который мы создали ранее, чтобы извлечь все данные покупателей (т.к. мы еще не рассмотрели вставку данных с помощью Entity Framework, чтобы протестировать примеры выборки данных, вы можете заполнить таблицы `Customers` и `Orders` вручную, используя средства Visual Studio или SQL Server Management Studio):
```cs
public static void GetAllCustomers()
{
    SampleContext context = new SampleContext();

    // Извлечь всех заказчиков и отобразить их имена в консоли
    foreach (Customer customer in context.Customers)
        Console.WriteLine(customer.FirstName);
}
```

Запрос `context.Customers` в этом примере извлечет все данные из таблицы `Customers`. Для запуска примера, вы можете вызвать метод `GetAllCustomers()` в методе `Main()` консольного приложения. Для этого примера Entity Framework сгенерирует следующий SQL-код (здесь я привожу фрагменты кода SQL для тех читателей, которые хорошо знакомы с T-SQL и хотят знать как EF транслирует запросы LINQ в SQL):
```sql
SELECT
    [Extent1].[CustomerId] AS [CustomerId],
    [Extent1].[FirstName] AS [FirstName],
    [Extent1].[LastName] AS [LastName],
    [Extent1].[Email] AS [Email],
    [Extent1].[Age] AS [Age],
    [Extent1].[Photo] AS [Photo]
    FROM [dbo].[Customers] AS [Extent1]
```

Код в этом примере возможно покажется несколько перегруженным, за счет использования псевдонима `Extent1` для таблицы `Customers` и других псевдонимов для столбцов, а также явного указания схемы по умолчанию `dbo`. Это связано с тем, что Entity Framework имеет общий алгоритм построения запросов, который не только обслуживает этот очень простой запрос в примере, но также используется и для гораздо более сложных сценариев, в которых могут понадобиться эти псевдонимы.

Стоит также отметить, что в этом примере мы используем отложенный LINQ-запрос. Если в вашем приложении предполагается делать несколько выборок данных в одном месте, отложенные запросы могут сильно ухудшить производительность приложения. Давайте рассмотрим пример:
```cs
public static void GetAllCustomers()
{
    SampleContext context = new SampleContext();

    // Отложенный запрос
    var customers = context.Customers;

    // Извлечь всех заказчиков и отобразить их имена в консоли
    foreach (Customer customer in customers)
        Console.WriteLine(customer.FirstName);

    // ... какой-то код

    // Еще один запрос, использующий коллекцию customers
    foreach (Customer customer in
        customers.Where(c => c.FirstName.StartsWith("В")))
    {
        Console.WriteLine(customer.FirstName);
    }
}
```

В этом примере используется отложенный запрос LINQ, т.е. запрос к базе данных вызывается не при инициализации переменной `customers`, а при вызовах циклов `foreach`. В результате, для этого примера будет создано два запроса к базе данных (при вызове первого и второго циклов), при этом SQL-запрос для второго цикла будет немного отличаться от первого, т.к. в нем будет использоваться инструкция `WHERE`. Очевидно, что такое решение для данного примера является плохим, логичнее было бы отправить один запрос к базе данных при инициализации переменной `customers`, а затем уже манипулировать извлеченными данными в коде. Как уже говорилось, для создания не отложенных запросов используются специальные методы LINQ, в частности можно использовать метод `ToList()`:
```cs
// ...

var customers = context.Customers.ToList();

// ...
```

Метод `ToList()` указывает запросу то, что он должен быть вызван сразу же и полученные данные должны быть преобразованы в коллекцию C#, реализующую интерфейс `IList<T>`. Теперь запрос к базе данных будет выполнен один раз, а циклы `foreach` будут манипулировать коллекцией `List`, а не извлекать каждый раз новые данные.

##### Указание столбцов, условий и сортировки в запросе
В запросе данных из таблицы вы можете указать порядок сортировки, который будет использован для выборки данных. Для этого используется вспомогательный метод `OrderBy()`. Ниже показан пример, в котором данные заказчика сортируются по фамилии:
```cs
public static void GetAllCustomers()
{
    SampleContext context = new SampleContext();

    var customers = context.Customers
                           .OrderBy(c => c.LastName);

    foreach (Customer c in customers)
        Console.WriteLine(c.LastName + " " + c.FirstName);
}
```

Приведенный выше код использует LINQ для создания запроса выборки сортированных данных из таблицы, а затем перебирает результаты запроса и отображает имя и фамилию каждого покупателя. После получения коллекции данных через свойство `Customers` класса контекста, вы можете использовать вспомогательные LINQ-методы `OrderBy()`, `GroupBy()` и `Join()` для сортировки, группировки данных на основе ключа и соединения таблиц. Эти методы будут транслированы на одноименные инструкции языка SQL.

Другой часто определяемой задачей при выборке данных, является их фильтрация на основе определенного условия. В SQL для этих целей используется оператор `WHERE`, LINQ содержит одноименный *метод `Where()`*, с помощью которого можно добавить дополнительное условие для загрузки данных:
```cs
var customers = context.Customers
                       .Where(c => c.Age > 25)
                       .OrderBy(c => c.LastName);
```

В этом запросе мы выбираем всех покупателей старше 25 лет.

До сих пор мы выбирали из базы данных только коллекцию объектов модели, т.е. коллекцию `IQueryable<Customer>`. Зачастую извлекать все данные не нужно, а нужно извлечь данные только из определенного столбца таблицы, создавая проекцию таблицы. Такой подход позволяет улучшать производительность, когда запрашиваются данные из таблицы, содержащей много столбцов, а в приложении нужно работать только с одним или несколькими столбцами.

Например, мы могли бы захотеть выбирать только фамилии покупателей из таблицы базы данных и отбрасывать всю другую информацию. Для этих целей в LINQ используется *метод `Select()`*, которому передается делегат, в котором выбираются нужные свойства модели. Этот метод возвращает уже не коллекцию объектов `Customer`, а коллекцию простых типов, например, для фамилий он вернет тип `IQueryable<string>`. Ниже показан соответствующий пример:
```cs
public static void GetAllCustomers()
{
    SampleContext context = new SampleContext();

    var names = context.Customers
                       .OrderBy(c => c.LastName)
                       .Select(c => c.LastName);

    foreach (string lastname in names)
        Console.WriteLine(lastname);
}
```

Этот запрос транслируется в следующий SQL-код:
```sql
SELECT 
    [Extent1].[LastName] AS [LastName]
    FROM [dbo].[Customers] AS [Extent1]
    ORDER BY [Extent1].[LastName] ASC
```

Здесь видно, что из таблицы будут выбираться данные только фамилии покупателей (столбец `LastName` указывается после инструкции `SELECT`).

Зачастую бывает нужно выбрать несколько столбцов из таблицы базы данных. Тогда возникает вопрос, коллекцию каких типов нужно вернуть для такой выборки? Тип `Customer` не подходит для этих целей, как и простые типы, ведь столбцы могут содержать строки, числа, даты и т.д. Для этих целей используются *анонимные объекты C#*, которые указываются в методе `Select()`. Ниже показан пример для выборки данных двух столбцов – `FirstName` и `LastName`:
```cs
var names = context.Customers
                   .OrderBy(c => c.LastName)
                   .Select(c => new
                   {
                        fname = c.FirstName,
                        lname = c.LastName
                   });

foreach (var name in names)
     Console.WriteLine(name.lname + " " + name.fname);
```

В этом примере мы указываем методу `Select()` анонимный объект с двумя свойствами – `lname` и `fname`. При перечислении коллекции объектов анонимного типа в цикле `foreach`, мы используем ключевое слово `var` языка C#, которое указывает, что компилятор должен динамически определить тип объекта. Это единственный способ сослаться на анонимный объект в цикле.

В нашем примере мы загружаем данные имен и фамилий в анонимный объект. Иногда бывает необходимо загрузить данные в объект модели, инициализировав только некоторые его свойства. В контексте нашего примера это означает, что мы могли бы создать коллекцию объектов `Customers`, в которую загрузили бы из базы данных всех пользователей, указав только два свойства `FirstName` и `LastName`. Для этих целей вы могли бы предположить, что нужно написать следующий пример:
```cs
var customers = context.Customers
                       .OrderBy(c => c.LastName)
                       .Select(c => new Customer
                       {
                            FirstName = c.FirstName,
                            LastName = c.LastName
                       });

foreach (Customer c in customers)
     Console.WriteLine(c.LastName + " " + c.FirstName);
```

Если вы запустите этот пример, то в приложении возникнет исключение `NotSupportedException`, в котором говорится, что Entity Framework не может использовать сложный тип `Customer` с запросом LINQ to Entities. Для этих целей вы должны сначала загрузить коллекцию анонимных объектов, которая инициализируется из базы данных, а затем создать коллекцию объектов `Customer`, которая инициализируется из коллекции анонимных объектов. Эту задачу можно выполнить в одном запросе, функционально разделив сложный запрос на две части – первая будет использоваться Entity Framework для извлечения данных из базы, вторая будет работать в памяти приложения и инициализировать коллекцию объектов `Customer`. В качестве разделителя нужно использовать метод `AsEnumerable()`:
```cs
IEnumerable<Customer> customers = context.Customers
          .OrderBy(c => c.LastName)
          .Select(c => new
          {
              fname = c.FirstName,
              lname = c.LastName
          })
          // Разделит запрос
          .AsEnumerable()
          // Этот метод Select выполняется на коллекции объектов,
          // а не в базе данных
          .Select(an => new Customer
          {
              FirstName = an.fname,
              LastName = an.lname
          });

foreach (Customer c in customers)
    Console.WriteLine(c.LastName + " " + c.FirstName);
```

Метод `AsEnumerable()` в LINQ просто преобразует коллекцию `IQueryable` к `IEnumerable`. В простых приложениях, работающих с коллекциями данный метод практически не используется, т.к. в нем нет смысла – интерфейс `IQueryable` является производным от интерфейса `IEnumerable`. Но этот метод оказывает существенное влияние при использовании с Entity Framework, указывая, что цепочку методов в запросе до его вызова нужно выполнить, отправив запрос к базе данных, а последующие методы будут оперировать уже на коллекции в памяти приложения. Если вы запустите этот пример, то можете убедиться в его работоспособности.

##### Поиск в запросе
Пока вы видели запросы, которые возвращают коллекцию объектов из базы данных, но иногда нужно чтобы запрос возвращал один объект. Наиболее распространенным сценарием для запросов, возвращающих один объект, является поиск определенного объекта с заданным ключом. DbContext API позволяет делать это очень просто, используя *метод `Find()`* класса `DbSet`. Этот метод принимает значение, которое нужно найти в таблице и возвращает соответствующий объект, если он найден, или `null` если не найден.

Поиск в запросе в Entity Framework использует следующую последовательность:

1. Сначала выполняется поиск в коллекции объектов, уже загруженных из базы данных в память приложения.

2. Если к коллекции добавлялись новые объекты, то поиск выполняется и в них.

Выполняется поиск в базе данных в объектах, которые еще не были загружены в память приложения.

Чтобы увидеть реализацию поиска, давайте добавим новый метод `FindCustomer()` в котором мы будем принимать идентификатор покупателя от пользователя, путем ввода его в консоль и затем будем искать покупателя с соответствующим идентификатором в базе данных:
```cs
public static void FindCustomer()
{
    Console.Write("Введите CustomerId: ");
    var id = int.Parse(Console.ReadLine());

    SampleContext context = new SampleContext();

    Customer customer = context.Customers.Find(id);

    if (customer != null)
        Console.WriteLine("{0} {1}",
            customer.FirstName, customer.LastName);
    else
        Console.WriteLine("Не найден");
}
```

Метод `Find()` осуществляет поиск по первичному ключу таблицы. Как вы знаете, первичные ключи бывают составными, поэтому методу `Find()` можно передать несколько значений, для поиска в ключах, при этом эти значения должны следовать в том же порядке, в котором свойства первичных ключей определены в классе модели. Напомню, что в Code-First для этого используется атрибут аннотаций данных `Column`, с переданным ему параметром `Order`, либо метод `HasColumnOrder()`, если вы используете для настроек Fluent API.

Если вам нужно выполнить поиск в обычных столбцах, не являющихся ключами таблицы, то для этого можно использовать условие через метод `Where()`. Например, если мы хотим найти всех покупателей, чья фамилия начинается на русскую букву “В”, то можем использовать следующий запрос:
```cs
var customers = context.Customers
    .Where(c => c.LastName.StartsWith("В"));

foreach (Customer c in customers)
    Console.WriteLine(c.LastName);
```

##### Локальные данные
Во всех предыдущих примерах мы использовали запрос к свойству класса контекста типа `DbSet` (`context.Customers`). Как говорилось ранее, использование этого свойства приводит к созданию запроса к базе для выборки всех данных из привязанной таблицы. Мы также использовали метод `Find()`, который ищет в памяти приложения данные до создания запроса к этой базе данных, в уже загруженных ранее данных.

Могут быть случаи, когда вы захотите использовать более сложный запрос для данных, которые уже были загружены из базы данных и находятся в памяти приложения, т.е использовать отложенный запрос, чтобы избежать повторной отправки запроса к базе данных. Например, мы могли бы загружать данные всех пользователей только при первом запуске приложения и сохранить их в каком-то локальном для приложения объекте, а затем в различных частях приложения создавать запросы к уже существующей коллекции, чтобы всякий раз не загружать ее снова.

Еще одной причиной использования такой локальной коллекции данных, является то, что в приложении в разных местах могут добавляться новые данные к этой коллекции, которые должны быть также использованы в запросах. При использовании не отложенного метода `ToList()`, запрос сразу же отправляется в базу данных и извлекаются данные, содержащиеся в базе данных, игнорируя новые данные в памяти приложения. Наглядно это показано на следующем примере:
```cs
// Загрузить данные не отложено из базы
var customers = context.Customers.ToList();

// Добавить нового покупателя в коллекцию Customers,
// предварительно не сохранив эти данные в базе
context.Customers.Add(new Customer
{
    FirstName = "Петр",
    LastName = "Сидоров",
    Age = 28
});

foreach (Customer c in customers)
    Console.WriteLine(c.LastName);
```

Здесь, при перечислении данных покупателей, новый добавленный покупатель не будет отображаться в списке.

Entity Framework позволяет хранить локальные данные для объектов `DbSet`, определяя свойство `Local` в этом классе. Это свойство вернет все данные, которые были загружены из базы данных плюс любые добавленные новые данные в приложении. Данные, которые были помечены в приложении как удаленные, но при этом еще не удаленные из базы данных, также будут фильтроваться в запросе.

Давайте начнем с очень простой задачи и определим, сколько на текущий момент находится объектов в памяти приложения:
```cs
public static void GetLocalCustomersCount()
{
    SampleContext context = new SampleContext();

    int count = context.Customers.Local.Count;
    Console.WriteLine("Объектов Customer в памяти {0}", count);
}
```

Этот метод позволяет проверить, сколько объектов `Customer` на данный момент находятся в памяти приложения. Если вы запустите приложение с вызовом этого метода, вы увидите, что количество объектов равно нулю. Мы получаем нулевой результат, потому что мы не выполняем никаких запросов, чтобы загрузить покупателей из базы данных, и мы не добавляли новые объекты Customer в коде. Давайте немного изменим этот метод, и запросим некоторые данные из базы:
```cs
public static void GetLocalCustomersCount()
{
    SampleContext context = new SampleContext();

    foreach (Customer c in context.Customers)
        Console.WriteLine(c.LastName);

    int count = context.Customers.Local.Count;
    Console.WriteLine("Объектов Customer в памяти {0}", count);
}
```

Перебор содержимого `DbSet` в цикле по каждому элементу является одним из способов, чтобы получить все данные из памяти приложения, но это немного неэффективно, чтобы каждый раз выполнять цикл просто ради загрузки данных. К счастью, DbContext API включает специальный *метод `Load()`* в классе `DbSet`, который можно вызвать для ручного запуска процесса загрузки данных из базы. Ниже показано использование этого метода (не забудьте указать пространство имен `System.Data.Entity`):
```cs
public static void GetLocalCustomersCount()
{
    SampleContext context = new SampleContext();

    context.Customers.Load();

    int count = context.Customers.Local.Count;
    Console.WriteLine("Объектов Customer в памяти {0}", count);
}
```

Этот код гораздо лаконичнее, чем тот, что мы использовали ранее. В сборке `System.Data.Entity` определен также расширяющий `IQueryable<T>` метод `Load()`, поэтому мы можем использовать его не только для загрузки всех данных из таблицы, но также использовать LINQ-методы для сужения выборки. Например, следующий запрос посчитает, сколько находится в памяти объектов `Customer`, чей возраст превышает 25 лет:
```cs
public static void GetLocalCustomersCount()
{
    SampleContext context = new SampleContext();

    context.Customers.Where(c => c.Age > 25).Load();

    int count = context.Customers.Local.Count;
    Console.WriteLine("Объектов Customer в памяти {0}", count);
}
```

В предыдущих примерах мы подсчитывали количество записей, хранящихся в памяти веб-приложения для определенного типа. Вы также можете манипулировать этими данными, используя различные методы LINQ. Как вы понимаете, эти изменения никак не отображаются на базе данных, т.е. вы фактически не работаете с Entity Framework, а работаете с простыми коллекциями C#. В примере ниже мы загружаем данные из базы в одном месте, а затем создаем несколько запросов, которые манипулируют данными уже в памяти приложения:
```cs
public static void LocalLinqQueryies()
{
    SampleContext context = new SampleContext();

    // В этом месте происходит загрузка данных из базы
    context.Customers.Load();


    var sortedCustomers = context.Customers.Local
        .OrderBy(c => c.LastName);

    Console.WriteLine("Все пользователи: ");
    foreach (Customer c in sortedCustomers)
        Console.WriteLine(c.LastName);


    var customers25 = context.Customers.Local
        .Where(c => c.Age > 25);

    Console.WriteLine("\nТолько те, кому за 25: ");
    foreach (Customer c in customers25)
        Console.WriteLine(c.LastName);
}
```

Этот код загружает всех пользователей в память приложения, а затем манипулирует полученными данными без запросов к базе, тем самым не создавая лишних запросов. Фактически, после загрузки данных в память мы больше не работаем с LINQ to Entities, а работаем с LINQ to Objects. Это два разных поставщика LINQ. При создании запросов к `DbSet` мы неявно используем LINQ to Entities, который специфичен для Entity Framework и использует модель и отображение, чтобы превратить ваш запрос в SQL. При использовании LINQ to Objects мы выполняем аналогичные операции с коллекциями в памяти приложения, используя среду .NET. Одинаковый синтаксис запроса может возвращать разные результаты в зависимости от поставщика которой вы используете. Например, база данных при сравнении строк не учитывает регистр символов, в то время как в приложении .NET используется регистрозависимое сравнение строк (если его явно не отключить).

##### Использование особенностей коллекции ObservableCollection
Если вы смотрели примеры использования локальных данных довольно внимательно, то должны были увидеть, что свойство `Local` возвращает специальный тип обобщенной коллекции **`ObservableCollection`**. Этот тип коллекции позволяет получать уведомления, когда добавляются или удаляются элементы из коллекции. Коллекция `ObservableCollection` полезна в ряде сценариев, работающих с привязкой данных.

Эта коллекция имеет *событие `CollectionChanged`*, в обработчике которого мы можем вносить полезные действия. В контексте локальных данных Entity Framework это событие возникает когда мы загружаем или удаляем данные из базы, работаем с данными в памяти приложения или добавляем новые объекты в `DbContext`. Ниже показан пример:
```cs
public static void LocalLinqQueryies()
{
    SampleContext context = new SampleContext();

    context.Customers.Local
        .CollectionChanged += (sender, args) =>
        {
            if (args.NewItems != null)
            {
                foreach (Customer c in args.NewItems)
                {
                    Console.WriteLine("Добавлен: " + c.FirstName);
                }
            }
            if (args.OldItems != null)
            {
                foreach (Customer c in args.OldItems)
                {
                    Console.WriteLine("Удален: " + c.FirstName);
                }
            }
        };

    context.Customers.Load();
}
```

Этот код добавляет новый обработчик событий изменения коллекции локальных данных. Этот обработчик указан через лямбда-выражения, хотя можно было и добавить отдельный метод. С помощью этого обработчика мы фиксируем в консоли, когда добавляется, а когда удаляется запись из коллекции. Если вы запустите приложение с вызовом метода `LocalLinqQueryies()`, то вы увидите, что EF загрузит из базы данных три записи в локальную коллекцию.

Использование такого типа коллекций может упростить работу с Entity Framework в приложениях, которые работают с привязкой данных, например, в приложениях WPF.

#### Загрузка связанных данных
До сих пор мы загружали данные только из одной таблицы базы данных. Но в реальном приложении, скорее всего будут использоваться несколько таблиц с отношениями (связями) между друг другом. В примере нашего приложения существуют две связанные таблицы – `Customers` и `Orders`, первая содержит данные покупателей, а вторая их заказы. Возможно нам нужно загрузить данные какого-то покупателя и все связанные с ним заказы.

В Entity Framework существует три подхода для загрузки связанных данных: “отложенная загрузка” (lazy loading), “прямая загрузка” (eager loading) и “явная загрузка” (explicit loading). С помощью этих подходов обеспечивается одинаковая загрузка данных, но при этом они влияют на производительность приложения. В последующих разделах мы опишем каждый из этих подходов.

##### Отложенная загрузка (lazy loading)
<dfn title="отложенная загрузка">Отложенная загрузка</dfn> (<dfn title="lazy loading">lazy loading</dfn>) заключается в том, что Entity Framework автоматически загружает данные, при этом не загружая связанные данные. Когда потребуются связанные данные Entity Framework создаст еще один запрос к базе данных. В контексте нашего примера это означает, что вы можете, например, загрузить первого заказчика из таблицы `Customers` и сохранить его в переменной `customer`. Затем вам может понадобиться узнать, какие заказы связаны с этим покупателем. Напомню, в классе модели `Customer` у нас определено навигационное свойство `Orders`. Если вы обратитесь к этому свойству (`customer.Orders`), то Entity Framework отправит запрос в базу данных на извлечение всех связанных с этим покупателем заказов.

Entity Framework применяет отложенную загрузку, используя динамические **прокси-объекты**. Вот как это работает. Когда Entity Framework возвращает результаты запроса, он создает экземпляры ваших классов и заполняет их данными, которые были возвращены из базы данных. Entity Framework имеет возможность динамически создавать новый тип во время выполнения, производный от вашего класса модели POCO. Этот новый класс выступает в качестве прокси-объекта для вашего класса POCO и называется динамическим прокси-объектом. Он будет переопределять навигационные свойства вашего класса POCO и включать в себя некоторую дополнительную логику для извлечения данных из базы данных, когда вызывается навигационное свойство. Т.к. динамический прокси-класс является производным от вашего класса POCO, ваше приложение работает непосредственно с классом POCO и не должно знать, что за кулисами создается динамический прокси-объект во время выполнения.

`DbContext` имеет настройку конфигурации для отложенной загрузки с помощью свойства **`DbContext.Configuration.LazyLoadingEnabled`**. Этот параметр включен по умолчанию, поэтому если вы не изменяли значение по умолчанию для него, динамический прокси-объект будет выполнять отложенную загрузку.

Для того, чтобы использовать динамические прокси-объекты, и, следовательно, отложенную загрузку, есть пара условий, которым должен соответствовать ваш класс модели. Если эти условия не выполняются, Entity Framework, не будет создавать динамические прокси-объекты для класса и будет просто возвращать экземпляры вашего класса POCO, которые не могут выполнять отложенную загрузку, а следовательно, взаимодействовать с базой данных:

- Ваш класс модели должен иметь модификатор доступа `public` и не должен запрещать наследование (ключевое слово sealed в C#).

- Навигационные свойства, которые должны обеспечивать отложенную загрузку, должны быть виртуальными (модификатор `virtual`).

Прежде чем изменять класс модели, давайте посмотрим на поведение приложения без отложенной загрузки. Добавьте новый метод `LazyLoading()` в ваш класс программы, который имеет следующий код:
```cs
public static void LazyLoading()
{
    SampleContext context = new SampleContext();

    // Загрузить одного покупателя
    Customer customer = context.Customers
        .Where(c => c.CustomerId == 2)
        .FirstOrDefault();

    // Попытаться загрузить связанные с ним заказы
    if (customer != null && customer.Orders != null)
        foreach (Order order in customer.Orders)
            Console.WriteLine(order.ProductName);
}
```

Если вы теперь вызовите этот метод в главном методе `Main()`, то никакие связанные данные не будут загружаться (т.к. мы еще не изучили как вставлять данные с помощью EF, вам нужно будет вручную вставить какие-нибудь данные в таблицу `Orders` с помощью Visual Studio или SQL Server Management Studio, для тестирования последующих примеров). В этом примере не происходит отложенная загрузка, т.к. наш класс модели `Customer` не подходит под второе условие – навигационное свойство `Customer.Orders` не является виртуальным. Давайте изменим это:
```cs
public class Customer
{
     // ...

     // Ссылка на заказы
     public virtual List<Order> Orders { get; set; }
}
```

Теперь, при запуске приложения Entity Framework создаст динамически прокси-объект для класса `Customer` и извлечет данные заказов из базы при их запросе.

Отложенная загрузка является очень простой в использовании, потому что используется автоматически. При этом, она является довольно опасной в плане производительности! Что если мы захотим извлечь сначала всех пользователей используя не отложенный запрос, а затем захотим извлечь все заказы, связанные с этими пользователями:
```cs
public static void LazyLoading()
{
    SampleContext context = new SampleContext();

    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    // Загрузить всех покупателей
    List<Customer> customers = context.Customers
         .ToList();      // +1 запрос к базе

    // ... какой-то код работы с данными покупателей

    // Загрузить все их заказы
    List<Order> orders = customers.SelectMany(c => c.Orders)
         .ToList();      // +3 запроса к базе данных
}
```

В этом примере создается три запроса, при попытке извлечь все заказы, связанные с заказчиками в коллекции `customers`. Мы даже включили средство протоколирования в этом запросе, чтобы вы убедились сами. Количество запросов `SELECT` при извлечении данных из таблицы `Orders` зависит от количества покупателей в коллекции `customers` – Entity Framework будет отправлять один запрос на выборку заказов для каждого покупателя. Очевидно, что такой подход является катастрофическим в плане производительности, если в коллекции будет храниться большое число покупателей.

##### Прямая загрузка (eager loading)
<dfn title="прямая загрузка данных">Прямая загрузка данных</dfn> (<dfn title="eager loading">eager loading</dfn>) позволяет указать в запросе какие связанные данные нужно загрузить при выполнении запроса. Благодаря этому, когда в коде вы будете ссылаться на связанную таблицу через навигационное свойство, SQL-запрос не будет направляться в базу данных, т.к. связанные данные уже будут загружены при первом запросе. В Entity Framework для этих целей используется *метод* `Include()`, которому передается делегат, в котором можно указать навигационное свойство, по которому данные должны загружаться при первом запросе. Этот метод является расширяющим для `IQueryable`. В примере ниже мы добавили метод `EagerLoading()`, в котором исправили предыдущий пример, используя прямую загрузку:

```cs
public static void EagerLoading()
{
    SampleContext context = new SampleContext();

    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    // Загрузить всех покупателей и связанные с ними заказы
    List<Customer> customers = context.Customers
        .Include(c => c.Orders)
        .ToList();      // +1 запрос к базе

    // ... какой-то код работы с данными покупателей

    // Получить все их заказы
    List<Order> orders = customers.SelectMany(c => c.Orders)
        // Запрос к базе данных не выполняется,
        // т.к. данные уже были извлечены
        // ранее с помощью прямой загрузки
        .ToList();
}
```

В этом примере базе данных будет отправляться всего один запрос при инициализации коллекции customers.

Метод `Include()` можно использовать для загрузки нескольких связанных таблиц. Этот метод возвращает тип `IQueryable<TEntity>`, где `TEntity` это базовый тип, на коллекции которого он был вызван, поэтому можно использовать цепочку вызовов `Include`. Давайте изменим модель, добавив два новых сущностных класса:
```cs
public class Customer
{
     // ...

     public Profile Profile { get; set; }
}

public class Order
{
    // ...

    public List<OrderLines> Lines { get; set; }
}

public class Profile
{
    [Key]
    [ForeignKey("CustomerOf")]
    public int CustomerId { get; set; }
    public DateTime RegistrationDate { get; set; }
    public DateTime LastLoginDate { get; set; }

    public Customer CustomerOf { get; set; }
}

public class OrderLines
{
    public int OrderLinesId { get; set; }
    public string Address { get; set; }
}
```

Класс `Profile` связан с классом `Customer` связью один-к-одному, а класс `OrderLine` связан с классом `Order` связью один-ко-многим. Обратите внимание, что мы не использовали виртуальные навигационные свойства, т.к. при прямой загрузке делать это необязательно. Для загрузки связанных данных из таблицы `Profiles` нужно будет использовать отдельный вызов метода `Include()`, а для загрузки связанных данных из `OrderLines` нужно указать метод `Select()` со ссылкой на этот класс, при вызове метод `Include()` для `Orders` (т.к. `OrderLines` напрямую не связан с `Customer`):
```cs
context.Customers
       .Include(c => c.Profile)
       .Include(c => c.Orders.Select(o => o.Lines))
       .ToList();
```

В этом примере будут загружены все связанные данные для всех пользователей. Стоит напомнить, когда мы изменяем модель и используем подход Code-First, базу данных нужно будет воссоздать с использованием инициализатора модели или удалив ее вручную.

Т.к. метод `Include()` возвращает тип `IQueryable<TEntity>`, мы можем использовать цепочку вызовов методов LINQ как обычно. Например, следующий запрос извлекает все связанные данные для покупателя с идентификатором равным 2:
```cs
Customer customer = context.Customers
    .Include(c => c.Profile)
    .Include(c => c.Orders.Select(o => o.Lines))
    .Where(c => c.CustomerId == 2)
    .FirstOrDefault();

if (customer.Orders != null)
    foreach (Order order in customer.Orders)
        Console.WriteLine(order.ProductName);
```

Стоит заметить, что при таком подходе к созданию запроса, обязательно возникнет проблема с производительностью приложения. Любой IT-специалист на определенном этапе работы должен ставить перед собой задачу: как увеличить быстродействие системы, как ускорить ноутбук или как улучшить отклик сервера. Вы, как разработчик, должны контролировать количество запросов к базе и объем данных, получаемых при выполнении этих запросов.

Ранее мы рассмотрели, как можно ограничить выбор столбцов в запросе. Естественно такой вопрос обязательно возникнет при выборке связанных данных, т.к. зачастую большинство данных из связанных таблиц не требуется. Для такой сложной загрузки можно не использовать методы `Include()`, а явно указать загрузку нужных связанных данных через вложенные анонимные объекты в запросе `Select()`. Допустим, нам нужно выбрать имена и фамилии всех покупателей, названия товаров, которые они заказали, а также их количество. Это можно сделать с помощью следующего запроса:
```cs
public static void EagerLoading()
{
    SampleContext context = new SampleContext();

    List<Customer> customers = context.Customers
        .Select(c => new
        {
            fname = c.FirstName,
            lname = c.LastName,
            orders = c.Orders.Select(o => new  // вложенный анонимный объект
            {
                pname = o.ProductName,
                quantity = o.Quantity
            })
        })
        .AsEnumerable()
        .Select(an => new Customer
        {
            // Инициализируем экземпляр Customer из анонимного объекта
            FirstName = an.fname,
            LastName = an.lname,
            Orders = an.orders.Select(o => new Order
            {
                ProductName = o.pname,
                Quantity = o.quantity
            }).ToList()
        })
        .ToList();

    // Отобразить извлеченные данные
    foreach (Customer customer in customers)
    {
        Console.WriteLine("\nЗаказы покупателя {0} {1}: \n",
            customer.FirstName, customer.LastName);

        foreach (Order order in customer.Orders)
            Console.WriteLine("\t\t{0} - {1} шт.",
        order.ProductName, order.Quantity);
    }
}
```

Не смотря на свою сложность, этот запрос намного производительнее, нежели если бы мы извлекали все данные из таблиц `Customers` и `Orders`.

##### Явная загрузка (explicit loading)
Последним вариантом загрузки данных в Entity Framework является <dfn title="явная загрузка">явная загрузка</dfn> (<dfn title="explicit loading">explicit loading</dfn>) данных. Явная загрузка, как и отложенная загрузка, не приводит к загрузке всех связанных данных в первом запросе. Но при этом, в отличие от отложенной загрузки, при вызове навигационного свойства связанного класса, эта загрузка не приводит к автоматическому извлечению связанных данных, вы должны явно вызвать метод `Load()`, если хотите загрузить связанные данные. Такой тип загрузки может использоваться в следующих случаях:

- Этот тип загрузки устраняет необходимость отмечать навигационные свойства класса модели как виртуальные. Для вас это может показаться не значительным изменением, но тот факт, что технология доступа к связанным данным при отложенной загрузке требует изменять ваши классы POCO модели, далека от идеальной.

- Вы можете работать с существующей библиотекой классов, где навигационные свойства не помечены как виртуальные, и вы не можете изменить эту библиотеку.

- В конце концов явная загрузка позволяет быть уверенным, что вы точно знаете, когда запросы отправляются в базу данных. Отложенная загрузка имеет характерную особенность генерировать много запросов к базе данных, с явной загрузкой очевидно, когда и где запросы выполняются в настоящее время.

Явная загрузка использует метод `DbContext.Entry()` для доступа к сущностному объекту, а не свойство типа `DbSet`. Объект `DbEntityEntry`, возвращаемый этим методом, дает вам доступ ко всей информации о сущностном типе данных. Помимо обычных свойств модели, этот объект хранит большое количество расширенных настроек сущностных объектов, а также позволяет вызвать метод `Load()` для вызова явной загрузки. В примере ниже мы используем метод `ExplicitLoading()`, в котором мы реализовали самый первый пример в этой статье, в котором мы не могли загрузить данные заказов автоматически, т.к. навигационное свойство `Customer.Orders` не было виртуальным:
```cs
public static void ExplicitLoading()
{
    SampleContext context = new SampleContext();

    // Загрузить одного покупателя
    Customer customer = context.Customers
        .Where(c => c.CustomerId == 2)
        .FirstOrDefault();

    // Загрузить связанные с ним заказы с помощью явной загрузки
    context.Entry(customer)
            .Collection(c => c.Orders)
            .Load();

    if (customer != null && customer.Orders != null)
        foreach (var order in customer.Orders)
            Console.WriteLine(order.ProductName);
}
```

В первой части этого примера мы загружаем данные пользователя с идентификатором, равным 2. Затем мы используем явную загрузку, чтобы указать Entity Framework о необходимости загрузить для пользователя связанные с ним заказы. Обратите внимание, что в этом примере используется *метод `Collection()`*, которому передается делегат, в котором выбирается навигационное свойство, имеющее тип коллекции. Если навигационное свойство имеет тип ссылки (например, для связи один-к-одному между таблицами), то нужно использовать *метод* `Reference()`. После этого используется метод `Load()` для создания запроса к базе данных.

Если вы теперь вызовете этот метод в основном методе `Main()` и запустите приложение, то сможете убедиться, что заказы извлекаются корректно. Стоит отметить, что в этом примере будет создано два SQL-запроса к базе данных: при извлечения данных покупателя с `CustomerId = 2` и при загрузке заказов для этого покупателя.

Методы `Collection()` и `Reference()` класса `DbEntityEntry` возвращают экземпляры классов **`DbCollectionEntry`** и **`DbReferenceEntry`**. Эти классы содержат полезное *свойство* `IsLoaded`, которое указывает, были ли уже загружены ранее связанные данные. Это свойство позволит оптимизировать вам некоторые запросы, чтобы повторно не извлекать соответствующие данные и его можно использовать не только при явной загрузке, но и при других типах загрузок. Ниже показан соответствующий пример:
```cs
public static void ExplicitLoading()
{
    SampleContext context = new SampleContext();

    // Загрузить одного покупателя с использованием прямой загрузки
    Customer customer = context.Customers
        .Include(c => c.Orders)
        .Where(c => c.CustomerId == 2)
        .FirstOrDefault();

    // Мы можем проверить, были ли загружены ранее данные о заказах,
    // для этого покупателя, если нет, то используем явную загрузку.
    if (!context.Entry(customer)
            .Collection(c => c.Orders).IsLoaded)
    {
        context.Entry(customer)
            .Collection(c => c.Orders)
            .Load();
    }

    if (customer != null && customer.Orders != null)
        foreach (var order in customer.Orders)
            Console.WriteLine(order.ProductName);
}
```

В предыдущих примерах при использовании явной загрузки мы указывали, что нужно выбрать все заказы. Что делать, если нужно использовать LINQ-методы для ограничения этой выборки, ведь классы `DbCollectionEntry` и `DbReferenceEntry`, объекты которых возвращаются методами `Collection()` и `Reference()`, не подходят для использования LINQ-запросов? Для этих целей в этих классах определен вспомогательный *метод* `Query()`, который возвращает типизированную сущностным классом коллекцию `IQueryable`. В примере ниже показано использование этого метода, для ограничения заказов, если количество товаров меньше 5:
```cs
context.Entry(customer)
    .Collection(c => c.Orders)
    .Query()
    .Where(o => o.Quantity >= 5)
    .Load();
```

##### Универсальный метод загрузки данных
Очевидно, что написание каждый раз запроса (включая объявление класса контекста) для выборки данных является утомительным занятием. Мы можем определить универсальный метод выборки данных, определив его в одном месте приложения, и ссылаться на него в любой части приложения. Давайте добавим в папку *Model* файл *Repository.cs* со следующим содержимым:
```cs
using System;
using System.Linq;
using System.Collections.Generic;
using System.Data.Entity;

namespace ExamplesEF
{
    public class Repository
    {
        public static IQueryable<TEntity> Select<TEntity>()
            where TEntity : class
        {
            SampleContext context = new SampleContext();

            // Здесь мы можем указывать различные настройки контекста,
            // например выводить в отладчик сгенерированный SQL-код
            context.Database.Log =
                (s => System.Diagnostics.Debug.WriteLine(s));

            // Загрузка данных с помощью универсального метода Set
            return context.Set<TEntity>();
        }
    }
}
```

Этот обобщенный метод `Select` типизируется сущностным типом из класса модели. Т.к. он является обобщенным, то для выборки объекта `DbSet` из класса контекста `DbContext` мы не можем использовать свойства. Вместо этого мы используем вспомогательный метод `DbContext.Set()`. В нашем универсальном методе можно определять общие настройки для обработки запросов, мы, например, добавили возможность выводить команды SQL с помощью свойства `DbContext.Database.Log`. После того как вы развернете приложение, достаточно будет удалить этот вызов в одном месте, чем искать везде в приложении места, где осуществляли загрузку данных из базы.

Ниже показан пример использования этого метода в методе `Main()` класса приложения, где мы извлекаем всех покупателей, старше 25:
```cs
static void Main()
{
     var customers = Repository.Select<Customer>()
        .Include(c => c.Orders)
        .Where(c => c.Age > 25)
        .ToList();
}
```

Благодаря тому, что универсальный метод `Select()` возвращает коллекцию `IQueryable<TEntity>`, мы можем создавать цепочку запросов не беспокоясь о предварительной загрузке данных (т.е. здесь используется отложенная природа выполнения запросов). Этот метод можно использовать для любого класса сущности в модели.

#### Вставка данных
В предыдущих статьях мы уже видели как загрузить данные из базы данных в память приложения с использованием Entity Framework. Вы уже могли наглядно убедиться в главном преимуществе ***объектно-реляционной модели*** (***Object Relational Mapper*** — ***ORM***) Entity Framework, которое заключается во взаимодействии с базой данных с помощью управляемого кода C# без использования SQL-инструкций. Выборка данных – это только половина доступных возможностей для работы с базой данных. Большинству приложений также необходимо вносить изменения в эти данные, путем вставки, удаления или обновления данных, а затем отражать все эти изменения в базе данных.

В этой статье мы рассмотрим, как можно вставлять новые записи в таблицу базы данных, а в последующих статьях рассмотрим вопросы обновления и удаления данных. Стоит отметить, что для сохранения любых изменений используется *метод* `SaveChanges()` класса контекста `DbContext`.

Метод `SaveChanges()` будет вызывать обновление в источнике данных, который отвечает за перевод изменений в сущностных объектах в правильные инструкции SQL, которые выполняются с базой данных. Т.к. Entity Framework известно о связях между таблицами, определяемых с помощью навигационных свойств, этот фреймворк обеспечит создание нужных SQL-инструкций, чтобы эти изменения применялись в правильном порядке. В контексте нашего примера, вы можете, например, удалить покупателя. Entity Framework автоматически распознает связь между классами модели `Customer` и `Order` и удалит все связанные с покупателем заказы. Это говорит о том, что Entity Framework позволяет вносить изменения, которые автоматически влияют на отдельные объекты, на пару связанных объектов или на весь граф объектов.

##### Вставка одного объекта
Добавление нового объекта с помощью Entity Framework является простой операцией нужно только создать новый экземпляр вашего объекта и добавить его в коллекцию сущностных объектов `DbSet` с помощью метода `Add()`. Ниже показан пример, как мы можем вставить нового пользователя в базу данных (мы используем все тот же проект консольного приложения с которым работали в предыдущих статьях):
```cs
public static void AddNewCustomer()
{
    SampleContext context = new SampleContext();

    // Создать нового покупателя
    Customer customer = new Customer
    {
        FirstName = "Иван",
        LastName = "Иванов",
        Age = 30
    };

    // Добавить в DbSet
    context.Customers.Add(customer);

    // Сохранить изменения в базе данных
    context.SaveChanges();
}
```

При сохранении изменений в базе данных с помощью метода `SaveChanges()`, Entity Framework сгенерирует следующий SQL-запрос:
```sql
INSERT [dbo].[Customers]([FirstName], [LastName], [Email], [Age], [Photo])
    VALUES (@0, @1, NULL, @2, NULL)

SELECT [CustomerId]
    FROM [dbo].[Customers]
    WHERE @@ROWCOUNT > 0 AND [CustomerId] = scope_identity()
```

Обратите внимание на отображение нашего управляемого кода на этот SQL-запрос. Для вставки значений используются переменные `@0`, `@1` и `@2`. Они инициализируются при компиляции приложения. Также, после инструкции `INSERT` следует инструкция `SELECT`, которая выбирает значение первичного ключа (в нашем случае `CustomerId`) для вновь вставленной записи. Благодаря этому, Entity Framework передает значение этого ключа переменной `customer` в коде. Т.е. после вставки данных, мы можем изменить или удалить этот объект, не извлекая его снова из базы. Чтобы убедиться, что EF инициализирует свойство первичного ключа в объекте модели при вставке в базу данных, можно изменить немного предыдущий пример:
```cs
public static void AddNewCustomer()
{
     // ...

    Console.WriteLine("ID до сохранения в базе: {0}",customer.CustomerId);

    // Сохранить изменения в базе данных
    context.SaveChanges();

    Console.WriteLine("ID после сохранения в базе: ", customer.CustomerId);
}
```

##### Вставка связанных объектов
Связи между таблицами в Entity Framework описываются с помощью навигационных свойств. В нашей модели существует связь один-ко-многим между классами `Customer` и `Order`, которая выражается с помощью пары навигационных свойств `Customer.Orders` и `Order.Customer`. Если навигационное свойство имеет тип ссылки, то для вставки связанных данных нужно просто инициализировать это свойство. Если навигационное свойство имеет тип коллекции, то нужно использовать ее метод `Add()` для добавления новой записи. Следует помнить, что изменения могут быть сделаны с одного или с двух концов связи (если используется пара навигационных свойств).

Давайте предположим, что нам нужно вставить новый заказ для добавленного в предыдущем примере пользователя “Иван Иванов”:
```cs
public static void AddNewOrder()
{
    SampleContext context = new SampleContext();

    // Нужно извлечь сначала покупателя,
    // которому добавляется заказ
    Customer ivan = context.Customers
        .Where(c => c.LastName == "Иванов")
        .FirstOrDefault();

    // Создаем заказ
    Order order = new Order
    {
        ProductName = "Яблоки",
        Quantity = 5,
        PurchaseDate = DateTime.Now,
        // Ссылка на покупателя в навигационном свойстве
        Customer = ivan
    };

    context.Orders.Add(order);

    context.SaveChanges();
}
```

В этом примере мы извлекаем пользователя с фамилией “Иванов” и добавляем для него новый заказ. Как видите, мы извлекаем все данные пользователя в первом запросе. Если таблица `Customers` содержит много столбцов с большим объемом данных, то такой подход плохо влияет на производительность. В таком случае можно извлечь только первичный ключ для покупателя (свойство `CustomerId`), а экземпляру класса `Order` добавить не ссылку в навигационном поле, а инициализировать внешний ключ. В примере нашей модели мы не определяли явно внешний ключ в классе `Order`, поэтому Code-First генерировал внешний ключ автоматически. Чтобы использовать описанный выше прием, мы должны будем добавить явно внешний ключ в класс `Order`:
```cs
public class Order
{
    // ...

    // Внешний ключ
    [ForeignKey("Customer")]
    public int UserId { get; set; }

    // Навигационные свойства
    public Customer Customer { get; set; }
    public List<OrderLines> Lines { get; set; }
}
```

Перед тем, как перейти к следующему примеру вы должны воссоздать базу данных с этой новой моделью, используя инициализаторы базы данных или удаляя ее вручную, как это описывалось при обсуждении Code-First. Теперь можно будет использовать этот внешний ключ в экземпляре класса `Order`:
```cs
public static void AddNewOrder()
{
    SampleContext context = new SampleContext();

    // Извлечь только Id покупателя
    int idIvan = context.Customers
        .Where(c => c.LastName == "Иванов")
        .Select(c => c.CustomerId)
        .FirstOrDefault();

    // Создаем заказ
    Order order = new Order
    {
        ProductName = "Яблоки",
        Quantity = 5,
        PurchaseDate = DateTime.Now,
        // Ссылка на покупателя во внешнем ключе
        UserId = idIvan
    };

    context.Orders.Add(order);

    context.SaveChanges();
}
```

В предыдущих примерах мы добавляли новый связанный объект для уже существующего базового объекта. В примере ниже показано, как при создании базового объекта, можно добавить сразу связанные объекты в одном запросе. Здесь мы создаем нового покупателя Петр Петров с двумя новыми заказами:
```cs
Customer customer = new Customer
{
    FirstName = "Петр",
    LastName = "Петров",
    Age = 30,
    Orders = new List<Order>
    {
        new Order {
            ProductName = "Яблоки",
            Quantity = 8,
            PurchaseDate = DateTime.Now
        },
        new Order {
            ProductName = "Апельсины",
            Quantity = 5,
            PurchaseDate = DateTime.Now
        }
    }
};

context.Customers.Add(customer);

context.SaveChanges();
```

Для этого примера Entity Framework создаст три SQL-запроса `INSERT` – один для вставки нового покупателя, а два для вставки связанных с ним заказов.

##### Реализация шаблона “найти или вставить”
В вашем приложении возможно понадобится реализовать простой шаблон “найти или вставить” (find or add), в котором вы проверяете, существует ли объект данных в базе, если нет, то создаете новый объект. Т.к. метод `DbSet.Add()` возвращает экземпляр сущностного класса модели, реализовать этот шаблон с помощью Entity Framework довольно просто:
```cs
public static Customer FindOrAdd(int id)
{
    SampleContext context = new SampleContext();

    return context.Customers.Find(id)
        ?? context.Customers.Add(new Customer
          {
              FirstName = "...",
              LastName = "...",
              Age = 40
          });
}
```

Напомню, что метод `Find()` ищет переданное ему значение в первичных ключах таблицы. В этом примере используется оператор C# `??`, который проверяет на `null` выражение стоящее слева от него, и если оно возвращает `null`, то вызывается выражение справа.

##### Создание универсального метода вставки
В предыдущей статье, где мы рассматривали создание универсального метода для загрузки данных, мы создали новый класс `Repository` и обобщенный метод `Select<TEntity>()`. Давайте создадим подобный метод `Insert()` для универсальной вставки данных в базу:
```cs
public static void Insert<TEntity>(TEntity entity) where TEntity : class
{
    // Настройки контекста
    SampleContext context = new SampleContext();
    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    context.Entry(entity).State = EntityState.Added;
    context.SaveChanges();
}

/// <summary>
/// Запись нескольких полей в БД
/// </summary>
public static void Inserts<TEntity>(IEnumerable<TEntity> entities) where TEntity : class
{
    // Настройки контекста
    SampleContext context = new SampleContext();

    // Отключаем отслеживание и проверку изменений для оптимизации вставки множества полей
    context.Configuration.AutoDetectChangesEnabled = false;
    context.Configuration.ValidateOnSaveEnabled = false;

    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));


    foreach (TEntity entity in entities)
        context.Entry(entity).State = EntityState.Added;
    context.SaveChanges();

    context.Configuration.AutoDetectChangesEnabled = true;
    context.Configuration.ValidateOnSaveEnabled = true;
}
```

В этом примере мы создаем два метода, первый из которых служит для вставки одного объекта, а второй вставит коллекцию объектов. Для вставки объекта entity используется *средство состояний Entity Framework* – альтернативное средство вставки объектов, благодаря которому мы указываем состояние сущностного объекта из перечисления `EntityState`. В нашем случае мы используем состояние `EntityState.Added`.

Обратите внимание, что в методе `Inserts()` мы отключили некоторые настройки конфигурации класса контекста. В частности свойство `AutoDetectChangesEnabled` отключает создание уведомлений при изменении сущностных данных, а `ValidateOnSaveEnabled` отключает проверку достоверности запроса при сохранении. Предполагается, что в этом методе могут вставляться тысячи записей, поэтому нужно оптимизировать эти настройки.

Теперь вы можете использовать эти методы для создания простых запросов, не беспокоясь о деталях реализации вставки данных:
```cs
static void Main()
{
    Repository.Inserts(
        new List<Customer>
        {
            new Customer {
                FirstName = "Сидор",
                LastName = "Сидоров",
                Age = 23
            },
            new Customer {
                FirstName = "Павел",
                LastName = "Васин",
                Age = 20
            }
        });
}
```

#### Обновление данных
Обновление существующих объектов в базе данных реализуется также просто, как и вставка данных. Для этого нужно сначала извлечь нужный объект из базы данных, затем изменить одно или несколько значений его свойств, а затем сохранить изменения в базе данных используя метод `DbContext.SaveChanges()`.

##### Обновление одного объекта
Допустим в таблице `Customers` существуют покупатели с фамилиями “Иванов”. Мы хотим поменять фамилии этих покупателей на “Сидоров”. Сделать это можно с помощью следующего кода:
```cs
public static void UpdateIvanov()
{
    SampleContext context = new SampleContext();

    var customer = context.Customers
        // Загрузить покупателя с фамилией "Иванов"
        .Where(c => c.LastName == "Иванов")
        .FirstOrDefault();

    // Внести изменения
    customer.LastName = "Сидоров";

    // Сохранить изменения
    context.SaveChanges();
}
```

Этот пример использует запрос LINQ для загрузки первого попавшегося покупателя с фамилией Иванов. Затем мы изменяем фамилию пользователя и вызываем метод `SaveChanges()`, при котором Entity Framework определяет, что объект сущности изменился и его нужно обновить используя следующий SQL-запрос:
```sql
UPDATE [dbo].[Customers]
SET [LastName] = @0
WHERE ([CustomerId] = @1)

-- @0: 'Сидоров' (Type = String, Size = -1)
-- @1: '5' (Type = Int32)
```

Как описывалось в предыдущей статье, для указания на изменение данных можно использовать модель состояний Entity Framework. Состояние сущностного объекта указывается через свойство `State` класса `DbEntityEntry`, который в свою очередь доступен через свойство `DbSet.Entry`. Для указания на то, что объект изменился используется значение `EntityState.Modified`. Ниже показан пример, как мы можем обновить фамилии всех Ивановых в таблице, а не только первого попавшегося:
```cs
public static void UpdateIvanov()
{
   SampleContext context = new SampleContext();

   IEnumerable<Customer> customers = context.Customers
       // Загрузить всех покупателей с фамилией "Иванов"
       .Where(c => c.LastName == "Иванов")
       .AsEnumerable()
       // Поменять им всем фамилию
       .Select(c => {
           c.LastName = "Сидоров";
           return c;
       });

   foreach (Customer customer in customers)
   {
       // Указать, что запись изменилась
       context.Entry(customer).State = EntityState.Modified;
   }

   // Сохранить изменения
   context.SaveChanges();
}
```

Этот код сгенерирует по одной инструкции `UPDATE` для каждого найденного покупателя с фамилией Иванов. Стоит отметить, что в показанных выше запросах мы загружали все данные пользователя, а во втором примере при использовании состояний, мы обновляли все данные, хотя достаточно лишь обновить только фамилию. (При автоматическом обновлении свойств модели, как в первом примере, Entity Framework будет обновлять только столбец `LastName`, как показано в сгенерированном SQL-коде). Класс `DbEntityEntry` содержит *метод* `Property()`, в котором можно явно указать свойство модели, которое нужно обновлять. Ниже показан более оптимизированный запрос для смены фамилий всех пользователей, в котором мы загружаем только их идентификаторы и обновляем только фамилии:
```cs
public static void UpdateIvanov()
{
    SampleContext context = new SampleContext();

    IEnumerable<Customer> customers = context.Customers
        // Загрузить всех покупателей с фамилией "Иванов"
        .Where(c => c.LastName == "Иванов")
        .Select(c => c.CustomerId)
        .AsEnumerable()
        // Поменять им всем фамилию
        .Select(id => new Customer {
            CustomerId = id,
            LastName = "Сидоров"
        });

    foreach (Customer customer in customers)
    {
        // Указать, что запись изменилась
        context.Customers.Attach(customer);
        context.Entry(customer)
            .Property(c => c.LastName).IsModified = true;
    }

    // Сохранить изменения
    context.SaveChanges();
}
```

Метод `Property()` возвращает объект **`DbPropertyEntry`**, в свойстве `IsModified` которого мы указываем, что состояние объекта изменилось. Это аналогично использованию свойства `State` класса `DbEntityEntry`. Обратите внимание на использование метода `DbSet.Attach()` при перечислении. Этот метод указывает, что объект нужно явно прикрепить в сущностной модели данных, т.к. он был создан вручную, а не загружен из базы данных. Действительно, следующий запрос LINQ to `Entities`:
```cs
context.Customers
    // Загрузить всех покупателей с фамилией "Иванов"
     .Where(c => c.LastName == "Иванов")
     .Select(c => c.CustomerId)
     .AsEnumerable()
```

фактически извлекает коллекцию идентификаторов имеющую тип `IEnumerable<int>`, а следующий за ним запрос LINQ to Objects уже создает коллекцию `IEnumerable<Customer>` в памяти приложения на основе идентификаторов. Как упоминалось ранее, метод `AsEnumerable()` в контексте использования в Entity Framework позволяет логически разделить один запрос на запрос к базе данных (LINQ to Entities) и простой запрос для работы с коллекциями C# (LINQ to Objects). На выходе, Entity Framework фактически ничего не знает об объектах коллекции `customers`, поэтому их нужно вручную прикрепить к объекту контекста используя метод `Attach()`.

##### Обновление связанных объектов
Обновление связанных объектов происходит также как и их вставка. Мы используем навигационное свойство или внешний ключ для изменения связанного объекта, а затем сохраняем эти изменения в базе данных.

Давайте рассмотрим обновление связанных объектов в контексте нашего примера. Допустим мы допустили ошибку при определении заказа с идентификатором `OrderId = 3`, и нам нужно переместить этот заказ к другому пользователю (в моей тестовой базе данных этот заказ принадлежит покупателю с `CustomerId = 4`, у вас соответственно это может отличаться). Ниже показан пример, как это можно сделать с использованием навигационного свойства:
```cs
public static void UpdateOrder()
{
    SampleContext context = new SampleContext();

    Customer customer = context.Customers
        .Where(c => c.CustomerId == 3)
        .FirstOrDefault();

    Order order = context.Orders
        .Where(o => o.OrderId == 3)
        .FirstOrDefault();

    order.Customer = customer;

    context.SaveChanges();
}
```

В этом примере мы сначала выбираем покупателя, кому будет принадлежать новый заказ, затем выбираем сам заказ, после чего обновляем ссылку на покупателя через навигационное свойство `Order.Customer`. Это говорит Entity Framework о том, что нужно сгенерировать инструкцию `UPDATE` для обновления соответствующей записи в таблице `Orders`:
```sql
UPDATE [dbo].[Orders]
SET [UserId] = @0
WHERE ([OrderId] = @1)
```

Entity Framework автоматически ищет измененные свойства в прикрепленных сущностных объектах и обновляет только их, как говорилось в предыдущем разделе. В данном примере обновляется внешний ключ `UserId`, который мы явно определили в предыдущей статье.

Стоит отметить, что в этом примере мы использовали навигационное свойство на стороне зависимой таблицы `Orders`. Можно обновить связанные объекты также использовав навигационное свойство `Customer.Orders` на стороне базовой таблицы, но для этого нужно обязательно при выборке данных покупателя включить и выборку связанных с ним заказов с помощью прямой загрузки, чтобы Entity Framework мог отслеживать изменения в коллекции заказов пользователя:
```cs
Customer customer = context.Customers
    .Include(c => c.Orders)
    .Where(c => c.CustomerId == 3)
    .FirstOrDefault();

Order order = context.Orders
    .Where(o => o.OrderId == 3)
    .FirstOrDefault();

customer.Orders.Add(order);
```

Очевидно, что этот пример гораздо хуже в плане производительности, чем предыдущий, т.к. при извлечении данных покупателя мы извлекаем данные всех его заказов, количество которых может быть очень большим. Поэтому использование навигационного свойства на стороне базовой таблицы при отношении один-ко-многим является неэффективным.

Мы можем еще более оптимизировать первый пример, используя в запросах загрузку только идентификатора пользователя, идентификатора и внешнего ключа заказа, чтобы не выбирать слишком много данных. Как говорилось в предыдущем разделе, такие выбранные данные нужно будет явно прикрепить к контексту используя метод `DbSet.Attach()`. Ниже показан соответствующий пример:
```cs
public static void UpdateOrder()
{
    SampleContext context = new SampleContext();

    // Загрузить только идентификатор покупателя
    int id = context.Customers
        .Where(c => c.CustomerId == 3)
        .Select(c => c.CustomerId)
        .FirstOrDefault();

    Customer customer = new Customer { CustomerId = id };

    // Загрузить идентификатор и значение внешнего ключа
    // для заказа
    var tempOrder = context.Orders
        .Where(o => o.OrderId == 3)
        .Select(o => new {
            id = o.OrderId,
            userId = o.UserId
        })
        .FirstOrDefault();

    Order order = new Order
    {
        OrderId = tempOrder.id,
        UserId = tempOrder.userId
    };

    // Обновить внешний ключ
    order.UserId = customer.CustomerId;

    // Прикрепить сущность к контексту и указать, что
    // изменился только внешний ключ
    context.Orders.Attach(order);
    context.Entry(order).Property(o => o.UserId).IsModified = true;

    context.SaveChanges();
}
```

Сгенерированный SQL-оператор `UPDATE` для этого примера не отличается от того, который мы приводили выше, но при этом значительно увеличивается производительность двух операторов `SELECT` для выборки только ключей.

##### Универсальный метод обновления
В предыдущих статьях мы добавили универсальные методы загрузки данных и вставки данных. Их универсальность заключается в том, что они не привязаны к конкретному классу модели, а используют обобщения. Напомню, что для этих целей в нашем проекте мы создали класс `Repository`, файл которого находится в папке *Model*. Давайте добавим такой же метод для обновления данных:
```cs
public static void Update<TEntity>(TEntity entity, DbContext context)
    where TEntity : class
{
    // Настройки контекста
    context.Database.Log = (s => System.Diagnostics.Debug.WriteLine(s));

    context.Entry<TEntity>(entity).State = EntityState.Modified;
    context.SaveChanges();
}
```

Этот метод использует настройки состояний для обновления сущностных данных. Теперь мы можем использовать этот универсальный метод в нашем приложении.
