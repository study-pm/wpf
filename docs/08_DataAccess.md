## Data Access / Доступ к данным

- [Data Access / Доступ к данным](#data-access--доступ-к-данным)
  - [Основные технологии доступа к данным](#основные-технологии-доступа-к-данным)
  - [Объектно-ориентированные механизмы](#объектно-ориентированные-механизмы)
  - [Базовая технология доступа к данным СОМ](#базовая-технология-доступа-к-данным-сом)
  - [Технология ODBC](#технология-odbc)
    - [Недостатки ODBC](#недостатки-odbc)
  - [DAO и RDO](#dao-и-rdo)
  - [Технология OLE DB](#технология-ole-db)
    - [Цели создания OLE DB](#цели-создания-ole-db)
    - [Технология OLE](#технология-ole)
    - [Суть OLE DB](#суть-ole-db)
    - [Основные понятия OLE DB](#основные-понятия-ole-db)
    - [Объектная модель OLE DB](#объектная-модель-ole-db)
    - [Доступ к OLE DB](#доступ-к-ole-db)
  - [Технология ADO](#технология-ado)
  - [Платформа .NET](#платформа-net)
      - [CIL и CLR](#cil-и-clr)
      - [.NET Framework и .NET](#net-framework-и-net)
      - [Управляемый и неуправляемый код](#управляемый-и-неуправляемый-код)
      - [JIT-компиляция](#jit-компиляция)
    - [Работа с базами данных в .NET Framework](#работа-с-базами-данных-в-net-framework)
  - [Технология ADO.NET](#технология-adonet)
    - [Обзор ADO.NET](#обзор-adonet)
      - [Три стороны ADO.NET](#три-стороны-adonet)
    - [Архитектура и принцип работы ADO.NET](#архитектура-и-принцип-работы-adonet)
      - [Поставщики данных в ADO.NET](#поставщики-данных-в-adonet)
      - [Стандартизация в ADO.NET](#стандартизация-в-adonet)
      - [Фундаментальные классы ADO.NET](#фундаментальные-классы-adonet)
      - [Автономный уровень](#автономный-уровень)
    - [Сравнение ADO и ADO.NET](#сравнение-ado-и-adonet)
  - [ADO.NET Entity Framework](#adonet-entity-framework)
    - [Предыстория возникновения](#предыстория-возникновения)
    - [ORM / Объектно-реляционное отображение](#orm--объектно-реляционное-отображение)
    - [История развития Entity Framework](#история-развития-entity-framework)
    - [Архитектура Entity Framework](#архитектура-entity-framework)
      - [Роль служб объектов](#роль-служб-объектов)
      - [Роль клиента сущности](#роль-клиента-сущности)
      - [Роль файла \*.edmx](#роль-файла-edmx)
      - [Роль классов ObjectContext и ObjectSet](#роль-классов-objectcontext-и-objectset)
    - [Модель EDM](#модель-edm)
      - [Генерация файла \*.edmx](#генерация-файла-edmx)
      - [Изменение формы сущностных данных](#изменение-формы-сущностных-данных)
      - [Просмотр отображений](#просмотр-отображений)
      - [Просмотр данных сгенерированного файла \*.edmx](#просмотр-данных-сгенерированного-файла-edmx)

### Основные технологии доступа к данным
На заре эпохи баз данных разработчикам достаточно было знать только те базы данных, которые они использовали. Но базы данных и их технологии развивались довольно быстро — от реляционных баз данных к нереляционным информационным хранилищам, таким, как электронная почта и файловые системы. Развитие баз данных сейчас идет в ногу со стремительными изменениями в технике. А с появлением клиент-серверных и многоуровневых архитектур разработчикам уже приходится разбираться во всем многообразии технологий баз данных. Большинство разработчиков потратили годы на изучение ODBC, DAO, RDO, OLE DB, ADO и RDS. К настоящему моменту Microsoft представила .NET Framework и вместе с ней новую технологию баз данных ADO.NET.

Как только мы начинаем углубляться в какую-то новую технологию, мы забываем, как она развивалась и что рационального за ней стоит. Проследив развитие технологий баз данных от ODBC до ADO.NET, проще выбрать подходящую технологию и оптимизировать ее для своих целей.

<dfn title="технология доступа к данным">Технологией доступа к данным</dfn> называется система интерфейсов, обеспечивающая взаимодействие между приложением и базой данных. Во многих системах управления базами данных имеются библиотеки, содержащие интерфейсы прикладного программирования (application programming interface – API), представляющие собой функции, при помощи которых можно выполнять с данными те или иные действия.

Для того, чтобы наиболее полно использовать возможности того или иного сервера баз данных, необходимо работать с ним напрямую, через API. Однако это означает полную зависимость приложения от того или иного сервера и сложность перехода на другую платформу, так как будет необходимо переписывать большое количество кода.

Этот вопрос призваны решить различные технологии доступа к данным. Они являются прослойкой между API конкретного сервера и приложением пользователя, предоставляя программисту простой унифицированный механизм работы с данными.

На сегодняшний день существует множество технологий доступа к данным, таких как:
- COM
- ODBC
- OLE DB
- ADO
- ADO.NET
- MIDAS

Все эти технологии основаны на единых принципах – объектных моделях доступа к удаленным БД, и разрабатываются, соответственно, на методах объектно-ориентированного программирования.

### Объектно-ориентированные механизмы
После того как объектно-ориентированные технологии стали доминирующими в системном программировании, разработчики приложений клиент-сервер также начали применять этот подход. В этом случае объекты на клиентах и серверах обмениваются сообщениями. Взаимодействие между объектами может быть основано на обмене сообщениями, на удаленном вызове процедур или непосредственно на объектноориентированных возможностях операционной системы.

Клиент, которому требуется услуга, посылает запрос брокеру объектных запросов, действующему как каталог всех доступных в сети удаленных услуг. Брокер вызывает соответствующий объект и передает ему необходимые данные. Затем удаленный объект обслуживает запрос и отвечает брокеру, который возвращает ответ клиенту.

*[COM]: Component Object Model
*[OLE]: Object Linking and Embedding
*[CORBA]: Common Object Request Broker Architecture
Успех объектно-ориентированного подхода зависит от того, насколько хорошо стандартизирован объектный механизм. К сожалению, в этой области сосуществуют сразу несколько конкурирующих схем. Одной из них является модель COM (Component Object Model — модель компонентных объектов) компании Microsoft, являющаяся основой технологии OLE (Object Linking and Embedding — связывание и внедрение объектов). Этот метод получил поддержку со стороны компании Digital Equipment Corporation, разработавшей механизм СОМ для операционной системы UNIX. С этим подходом конкурирует получившая широкую промышленную поддержку технология CORBA (Common Object Request Broker Architecture — обобщенная архитектура брокера объектных запросов), разработанная компанией Object Management Group. Архитектуру CORBA поддерживают компании IBM, Apple, Sun, а также многие другие.

Механизмы доступа к базам данных снижают сложность обмена информацией с базами, однако интерпретация результатов их работы также достаточно трудоемка. Поэтому реализованы наборы компонентов, предназначенные для взаимодействия с механизмами обмена.

Таким образом, можно выделить несколько субъектов, участвующих в движении информации между базой данных и приложением (например, пользовательским интерфейсом):
1) интерфейсная часть приложения или его программная часть, манипулирующая информацией, хранимой в базе данных;
2) компоненты, обеспечивающие связь приложения с механизмом доступа к базе данных;
3) механизм доступа к базе данных;
4) база данных.

При разработчике приложения-СУБД программист работает с наборами компонентов, предназначенных для обмена информацией с базами данных и ее отображения. В зависимости от выбранного механизма доступа к базе данных некоторые наборы компонентов могут не использоваться, однако все они, вне зависимости от особенностей используемой базы данных и механизма доступа к ней, имеют схожие свойства и методы.

### Базовая технология доступа к данным СОМ
*[COM]: Component Object Model
Технология доступа к удаленным данным Component Object Model (COM) – компонентная модель объектов, разработанная фирмой Microsoft как средство взаимодействия приложений (в том числе составных частей ОС Windows), функционирующих на одном ПК. На технологии СОМ построены такие методы управления удаленными объектами, как OLE, Автоматизация, ActivX.

Стандарт COM был разработан в 1993 году корпорацией Microsoft как основа для развития технологии OLE. <dfn title="объектная модель компонентов">Объектная Модель Компонентов</dfn> (Component Object Model, COM) — это технологический стандарт от компании Microsoft, предназначенный для создания программного обеспечения на основе взаимодействующих распределённых компонентов, каждый из которых может использоваться во многих программах одновременно. Стандарт COM воплощает в себе идеи полиморфизма[^полиморфизм] и инкапсуляции[^инкапсуляция] объектно-ориентированного программирования.

[^полиморфизм]: <dfn title="полиморфизм">Полиморфизм</dfn> — взаимозаменяемость объектов с одинаковым интерфейсом.

[^инкапсуляция]: <dfn title="инкапсуляция">Инкапсуляция</dfn> — свойство языка программирования, позволяющее объединить данные и код в объект и скрыть реализацию объекта от пользователя.

### Технология ODBC
ODBC (Open Database Connectivity – открытый доступ к базам данных) – разработанный компанией Microsoft универсальный интерфейс программирования приложений для доступа к базам данных.

В большинстве систем проектирования баз данных приложения основываются на одном типе баз данных. В таких простых схемах разработчик приложения может программировать напрямую, используя системный интерфейс базы данных. Хотя подобный подход обеспечивает быстрый и эффективный доступ к данным, могут возникать проблемы, когда задача расширяется, и разработчику приходится дорабатывать программу. При данном подходе это означает, что каждая готовая программа должна иметь различные версии с поддержкой всевозможных типов баз данных. Если компании расширяются или объединяются одна с другой, приложение должно получить доступ к базам данных, основанным на различных платформах.

Технология ODBC обеспечивает общий интерфейс для доступа к разнородным базам данных стандарта SQL. ODBC использует язык SQL как стандарт для доступа к данным. Этот интерфейс очень удобен: одно приложение может обращаться к различным базам данных SQL через общий набор команд. Таким образом, разработчик может создавать и распространять приложения, не привязываясь к конкретной базе данных.

Можно также добавить драйвер базы данных, чтобы приложение могло работать с базой данных по выбору пользователя. Менеджер драйверов является промежуточным звеном между приложением и базами данных. Интерфейс ODBC содержит набор функций, который управляет каждым инструментом базы данных. Если приложению нужно сменить используемую базу, разработчик просто заменяет один драйвер другим, и приложение может работать как обычно, без необходимости модификации кода программы.

Основной целью разработки протокола ODBC считается стандартизация механизмов взаимодействия с различными СУБД. Основная проблема, связанная с разработкой приложений, взаимодействующих с базами данных на основе специальных SQL API, состояла в том, что каждая СУБД имела собственный программный интерфейс доступа, каждый из них имел свои особенности и функционировал не совсем так, как другие. В связи с этим разработка приложения существенно зависела от используемой СУБД. Компания Microsoft сделала важный шаг для решения этой проблемы. Основная идея заключалась в разработке универсального интерфейса на уровне семейства операционных систем Windows, который мог бы быть поддержан в разных СУБД.

Технология ODBC (от англ. Open Database Connectivity – открытый механизм доступа к базам данных) – это компонент операционной системы Windows, предназначенный для унификации доступа к информации, хранящейся в базах данных различных видов. ODBC состоит из набора драйверов, осуществляющих операции обмена с определенными базами данных, и менеджера драйверов, осуществляющего передачу запросов от приложения к драйверу и передачу информации от драйвера к приложению.

Для получения и изменения данных используется язык запросов SQL, вне зависимости от того, поддерживается ли он базой данных, к которой обращается приложение. Если база данных не поддерживает язык SQL, то доступ к ней не отличается от доступа к БД, поддерживающим SQL. В этом и заключается унификация доступа к базам данных системой ODBC – приложение указывает название драйвера, который должен использоваться для подключения к базе данных, и передает запрос, в котором описан состав требуемой информации. Далее механизм ODBC выполняет все необходимые операции по получению информации, скрывая от приложения специфику работы с конкретной базой данных. Доступ приложений к ODBC осуществляется через API-функции, реализованные в динамических библиотеках.

#### Недостатки ODBC
Стандарт ODBC предназначен для реляционных баз данных, но в электронном мире существует достаточно много не реляционной информации, такой как сообщения электронной почты, документы, Web-страницы,  картинки, аудиофайлы и т.д. Эти данные не могут хранится в формате реляционных СУБД.

Для выполнения самых простых задач программисту приходится вызывать десятки сложных функций, т.к. доступ к драйверам ODBC осуществлялся посредством API.

<dfn title="интерфейс прикладного программирования">Интерфейс прикладного программирования</dfn> (Application Programming Interface, API) — набор готовых констант, структур и функций, используемых при программировании пользовательских приложений и обеспечивающих правильное взаимодействие между пользовательским приложением и операционной системой.

То есть для доступа к данным при помощи ODBC любая программа вызывает API-функции, причем в определённой последовательности:
- подключение к источнику данных;
- инициализация и настройка параметров SQL-запроса/оператора;
- формирование и выполнение запроса/оператора;
- получение результатов;
- отключение от источника данных.

### DAO и RDO

*[VB]: Visual Basic
*[DAO]: Data Access Object
ODBC использует низкоуровневый интерфейс, поэтому программисты на С и С++ реально задействуют все преимущества технологии ODBC. Программисты на Visual Basic (VB) не имеют простого доступа к интерфейсу ODBC. До появления VB 6.0 разработчики применяли высокоуровневый доступ к данным. Программисты VB используют технологию Data Access Object (DAO) для доступа к данным.

DAO базируется на технологии баз данных Microsoft Jet — процессоре баз данных, предназначенном для Microsoft Access. JET был первым объектно-ориентированным интерфейсом для связи с Access. Приложения, использующие Access, могут задействовать DAO для прямого доступа к данным. Поскольку DAO создавалась сразу же вслед за Access, применение этой технологии — самый быстрый и наиболее эффективный способ доступа к базам данных Access. DAO может работать и с отличными от Access базами данных, такими, как SQL Server и Oracle. DAO использует ODBC, но, поскольку метод DAO спроектирован специально для взаимодействия с JET, JET транслирует запросы между DAO и ODBC. Этот дополнительный шаг трансляции и является причиной замедления работы с базами данных, отличными от Access.

*[RDO]: Remote Data Objects
Чтобы преодолеть это ограничение, разработчики Microsoft создали RDO. RDO обращается к ODBС API напрямую, минуя JET.

Затем было введено ODBCDirect, расширение DAO, которое отодвигает RDO на задний план. DAO-приложение, используя ODBCDirect, обращается к базе данных, минуя проблемы, которые вызывает JET.

### Технология OLE DB
Спустя несколько лет ODBC становится стандартом для клиент-серверного доступа к базам данных. ODBC обеспечивает стандартный интерфейс, который требует функций SQL и оптимизирован под методы SQL. Однако что произойдет, если нужно будет обратиться к нереляционной базе данных, в которой не используются принципы SQL (например, Microsoft Exchange Server, хранилище которого не содержит данные реляционно)?

Технология OLE DB пришла на смену ODBC, с тем, чтобы устранить её недостатки. В начале 1990-x корпорация Microsoft представила OLE DB – объектно-ориентированный интерфейс для доступа к базам данных.

Технология OLE DB (от англ. Object Linking and Embedding DataBase – механизм доступа к базам данных с помощью технологии OLE) представляет собой набор СОМ-интерфейсов, обеспечивающих универсальный доступ приложений к базам данных и другим хранилищам информации (в том числе и нереляционным —  файловым системам, системам электронной почты и др.), в которых результатом запросов является информация, представленная в табличной форме.

#### Цели создания OLE DB

*[VSAM]: Virtual Storage Access Method
1. Создание объектных интерфейсов для элементов функциональности СУБД – запрос, обновление, управление транзакциями.

2. Увеличение гибкости:
   - дать потребителям данных возможность использовать только те объекты, которые им нужны.
   - дать поставщикам данных возможность открывать доступ к элементам функциональности СУБД.
   - обеспечить возможность доступа к функциональности с помощью множества различных интерфейсов.
   - сделать эти интерфейсы стандартизированными и расширяемыми.

3. Создание объектных интерфейсов для любых типов данных: реляционных баз данных (через ODBC или собственные интерфейсы СУБД), нереляционных баз данных, систем обработки файлов (VSAM и др.),  электронной почты и т.п.

4. Реализация стратегии, при которой данные не должны преобразовываться в другие форматы или перемещаться из того места, где они находятся.

#### Технология OLE
OLE (Object Linking and Embedding) — технология связывания и внедрения объектов в другие документы и объекты, разработанные корпорацией Microsoft.

OLE используется при обработке составных документов (compound documents), может быть использована при передаче данных между различными несвязанными между собой системами посредством интерфейса переноса (drag-and-drop), а также при выполнении операций с буфером обмена.

OLE-объекты являются COM-объектами и поддерживают все требуемые для таких объектов интерфейсы.

#### Суть OLE DB
Рассмотрим OLE DB. Технология OLE DB построена на ODBC и расширяет ее до компонентной архитектуры, которая обеспечивает высокоуровневый интерфейс доступа к данным. Эта архитектура предоставляет постоянный доступ к SQL-данным, не SQL-данным и неструктурированным источникам данных по локальным сетям и Internet. В действительности для доступа к SQL-данным OLE DB использует ODBC, потому что это самая подходящая архитектура для работы с SQL. На Рисунке 5 показано, что OLE DB состоит из трех компонентов: потребителя данных (например, приложения); поставщика (провайдера) данных, который содержит и предоставляет данные; служебного компонента, который обрабатывает и транспортирует данные (в частности, процессоры запросов, процессоры курсоров). OLE DB — это единый API, который обрабатывает как совместимые с SQL источники данных, так и несовместимые, такие, как почта и каталоги.

#### Основные понятия OLE DB
OLE DB представляет собой набор COM-интерфейсов, которые предоставляют приложению-клиенту унифицированный доступ к различным  источникам данных. А именно: OLE DB разбивает всю совокупность возможностей и функций СУБД на отдельные фрагменты – COM-объекты с узкой специализацией. Одни объекты выполняют запросы, другие производят обновление, третьи создают структурные  элементы базы данных – таблицы, индексы и представления, четвёртые занимаются управлением транзакциями – например, устанавливают оптимистическую блокировку.

OLE DB – это метод доступа к любым данным, вне зависимости от типа данных и места их расположения. В качестве данных могут выступать реляционные и не реляционные базы данных, картинки, аудиофайлы, электронная почта и другие источники данных.

Средства, предоставляющие доступ к источнику данных с использованием технологии OLE DB, называются OLE DB **провайдерами**. Программы-клиенты, использующие для доступа OLE DB провайдеры, называются **потребителями данных**. В случае, если существует только ODBC-драйвер для доступа к конкретному источнику данных, то для применения технологии OLE DB можно использовать OLE DB провайдер, предназначенный для доступа к ODBC-источнику данных.

Характерной особенностью механизма OLE DB является то, что данные, возвращаемые OLE DB приложению, представляют собой не просто массив информации, а СОМ-объект, обладающий, помимо самой информации, методами управления этой информацией (например, фильтрация и сортировка). Логическая схема доступа к данным с помощью OLE DB представлена на рис. 3.

Приложение, называемое потребителем данных, обращается к поставщику данных, который перенаправляет запрос от приложения к базе данных, либо обрабатывает запрос самостоятельно. Таким образом, поставщик данных аналогичен драйверам ODBC. Механизм OLE DB имеет доступ к ODBC, поддерживая, таким образом, большое количество драйверов, реализованных для ODBC.

#### Объектная модель OLE DB
Спецификация OLE DB определяет набор интерфейсов базового уровня, которые должны реализовываться любыми OLE DB провайдерами. В базовую модель OLE DB входят следующие объекты:
- объект `DataSource` (источник данных), используемый для соединения с источником данных и создания одного или нескольких сеансов. Этот объект управляет соединением, использует информацию о полномочиях и аутентификациях[^аутентификация] пользователя.

- объект `Session` (сеанс) управляет взаимодействием с источником данных – выполняет запросы и создаёт результирующие наборы. Сеанс также может возвращать метаданные[^метаданные]. В сеансе может создаваться одна или несколько команд.

- Спецификация OLE DB определяет объект `Command` (команда), предназначенный для выполнения текстовой команды. В качестве такой команды может выступать и SQL-оператор. При  этом выполнение команды может создавать результирующий набор (в случае SQL-оператора – это оператор SELECT).
- Представление (`View`) определяет группу столбцов из набора данных, но само не содержит их. Представления не могут объединять данные из нескольких наборов таблиц, подмножество строк.

[^аутентификация]: <dfn title="аутентификация">Аутентификация</dfn> (Authentication) — процедура проверки соответствия некоего лица и его учетной записи в компьютерной системе. В простейшем случае проверка происходит с помощью пароля.

[^метаданные]: <dfn title="метаданные">Метаданные</dfn>: <ul><li>информация о данных.</li><li>информация об информации.</li><li>структурированные данные, представляющие собой характеристики описываемых сущностей для целей их идентификации, поиска, оценки, управления ими.</li><li>данные из более общей формальной системы, описывающей заданную систему данных.</li></ul>

OLE DB провайдеры, как и все COM-компоненты, регистрируются в реестре Windows. Для поиска информации о зарегистрированных источниках данных используются специальные объекты, называемые нумераторами. <dfn title="нумератор">Нумератор</dfn> — это обычный СОМ-сервер, позволяющий получить информацию об источниках данных в виде результирующего набора. Для создания такого результирующего набора в объектном типе `DataSource` специфицирован интерфейс `IDBEnumerateSources`.

Для каждого объектного типа спецификация OLE DB определяет набор интерфейсов, который должен обязательно быть реализован для данного объекта. Такие интерфейсы отмечаются как `[mandatory]`. Интерфейсы, которые могут отсутствовать, отмечаются как `[optional]`.

#### Доступ к OLE DB
Будучи COM-интерфейсом, OLE DB непосредственно доступен из C++, C# и Java, но недоступен из Visual Basic и сценарных языков. Поэтому, чтобы использовать OLE DB из любых языков программирования, необходимо использовать объектный интерфейс ADO.

### Технология ADO
OLE DB обеспечивает связывание для программистов на С и C++, а также программистов, использующих языки с С-подобными вызовами функций. Такие языки, как VB и VBScript, не поддерживают тип данных «указатель» (адресных переменных). Следовательно, они не могут использовать связывание в стиле С и прямое обращение к OLE DB.

*[ADO]: ActiveX Database Objects
Вероятно, для большей путаницы разработчики Microsoft ввели еще одну объектную модель доступа к данным: ADO. ADO работает с объектами DAO и RDO, а также поддерживает более простые модели, чем DAO и RDO (хотя с избыточной функциональностью, так что можно выполнить операцию несколькими способами). Объектная иерархия в ADO более однородная, чем в DAO. ADO содержит несколько встроенных объектов, которые упрощают доступ к данным из информационных хранилищ.

<dfn title="ActiveX">ActiveX</dfn> – это фреймворк от Microsoft, используемый для создания программных компонентов, которые могут применяться в различных языках программирования. Технология позволяет интегрировать интерактивные функции на веб-страницы для улучшения взаимодействия с пользователем. ActiveX – технология, на основе которой создаются компоненты для программирования сайтов под Internet Explorer. К настоящему времени ActiveX считается устаревшей технологией, которую не следует использовать для новых разработок. Многие возможности элементов activeX можно выполнять проще и более безопасно с помощью современных технологий, таких как HTML5 и JavaScript, современные расширения браузера или модули WebAssembly.

Технология ADO (от англ. ActiveX Database Objects – механизм доступа к базам данных через объекты ActiveX) – технология доступа к данным, разработанная Microsoft, является надстройкой над механизмом доступа OLE DB и предназначена для унификации работы с поставщиками данных OLE DB. Обеспечивает удобный и надежный доступ к данным, хотя и несколько более медленный, чем в технологиях BDE и dbExpress. Хорошо подходит для работы с системами управления базами данных (СУБД) от фирмы Microsoft (MS Access, MS SQL Server), поскольку не требует дополнительных компонентов (библиотек, драйверов), так как они уже есть на компьютере пользователя.

Механизм ADO предоставляет несколько основных СОМ-объектов, используемых для получения и управления информацией (имеются дополнительные СОМ-объекты, расширяющие функциональность ADO):
- `Connection` для управления соединением с базой данных и передачи запросов поставщику данных;
- `Command` для управления информацией о запросе к базе данных или команде;
- `Recordset`, содержащий таблицу, которая является результатом запроса к базе данных;
- `Field`, содержащий описание поля в таблице, возвращенной поставщиком данных. Список всех полей таблицы содержится в подобъекте `Fields` объекта `RecordSet`;
- `Error`, содержащий расширенную информацию об ошибке, о которой сообщил поставщик данных. Если ошибок несколько, доступ к ним можно получить с помощью объекта `Errors`.

Существует несколько способов, с помощью которых приложение связывается с базой данных. Например, VB-программист может использовать ADO для соединения приложения с провайдером OLE DB. Если база данных не поддерживает OLE DB, приложение может задействовать ODBC. Программист на Visual C++ может применять ADO или соединяться напрямую через OLE DB.

### Платформа .NET
**.NET** – это кросплатформенная среда выполнения приложений. Проще говоря – это то, что позволяет запускаться нашим приложениям в системе. 

**.Net Framework** – это набор уже скомпилированных библиотек, откуда берутся методы и функции для запуска и разработки приложений. В разработке нам придётся просто вызвать уже готовую функцию для того чтобы она заработала.

Язык C# используется всего лишь для описания команд и инструкций, но используя возможности .Net Framework позволяет создавать приложения разного типа.

Когда говорят C#, нередко имеют в виду технологии платформы .NET (Windows Forms, WPF, ASP.NET, Xamarin). И, наоборот, когда говорят .NET, нередко имеют в виду C#. Однако, хотя эти понятия связаны, отождествлять их неверно. Язык C# был создан специально для работы с фреймворком .NET, однако само понятие .NET несколько шире.

Фреймворк .NET представляет мощную платформу для создания приложений. Можно выделить следующие ее основные черты:

*[CLR]: Common Language Runtime
*[CIL]: Common Intermediate Language
- **Поддержка нескольких языков** – C#, C++, F# и др. Основой платформы является общеязыковая среда исполнения Common Language Runtime (CLR), благодаря чему .NET поддерживает несколько языков: наряду с C# это также VB.NET, C++, F#, а также различные диалекты других языков, привязанные к .NET, например, Delphi.NET. При компиляции код на любом из этих языков компилируется в сборку на общем языке CIL (Common Intermediate Language) - своего рода ассемблер платформы .NET. Поэтому при определенных условиях мы можем сделать отдельные модули одного приложения на отдельных языках.

- **Кроссплатформенность** – можно разрабатывать приложения на языке C# для самых разных платформ - Windows, MacOS, Linux, Android, iOS. .NET является переносимой платформой (с некоторыми ограничениями). Например, последняя версия платформы на данный момент — .NET 7 поддерживается на большинстве современных ОС Windows, MacOS, Linux. Используя различные технологии на платформе .NET, можно разрабатывать приложения на языке C# для самых разных платформ — Windows, MacOS, Linux, Android, iOS, Tizen. Стоит также упомянуть аппаратную кроссплатформенность (x86, x64, arm).

- **Мощная библиотека классов** – позволяет создавать приложения разного типа. .NET представляет единую для всех поддерживаемых языков библиотеку классов. И какое бы приложение мы не собирались писать на C# — текстовый редактор, чат или сложный веб-сайт — так или иначе мы задействуем библиотеку классов .NET.

- **Разнообразие технологий**. Общеязыковая среда исполнения CLR и базовая библиотека классов являются основой для целого стека технологий, которые разработчики могут задействовать при построении тех или иных приложений. Например, для работы с базами данных в этом стеке технологий предназначена технология ADO.NET и Entity Framework Core. Для построения графических приложений с богатым насыщенным интерфейсом — технология WPF и WinUI, для создания более простых графических приложений — Windows Forms. Для разработки кроссплатформенных мобильных и десктопных приложений — Xamarin/MAUI. Для создания веб-сайтов и веб-приложений — ASP.NET и т.д.

- **Производительность**. Согласно ряду тестов веб-приложения на .NET 7 в ряде категорий сильно опережают веб-приложения, построенные с помощью других технологий. Приложения на .NET 7 в принципе отличаются высокой производительностью.

Также еще следует отметить такую особенность языка C# и фреймворка .NET, как автоматическая сборка мусора. А это значит, что нам в большинстве случаев не придется, в отличие от С++, заботиться об освобождении памяти. Вышеупомянутая общеязыковая среда CLR сама вызовет сборщик мусора и очистит память.

##### CIL и CLR

*[CIL]: Common Intermediate Language
*[CLR]: Common Language Runtime

В программировании на .Net компиляция и запуск приложений происходит следующим образом:
- Код из любого языка преобразовывается в код, написанный на общем языке (Common Intermediate Language или CIL). Этот язык является языком низшего уровня, похожего по синтаксису на язык ассемблер.
- После, этот код передаётся так называемой исполняющей среде (Common Language Runtime или CLR), которая берёт функции и методы из .Net Framework и управляет нашим приложением.
- После этого конечный результат передаётся на процессор и выполняется программа.

![CIL и CLR](./img/CIL-CLR.png "CIL и CLR")

*[JIT]: Just In Time
*[IL]: Intermediate Language
CLR идёт вместе с .Net и является его частью. Используется для выполнения кода, написанного на платформе .Net. Код, сформированный компилятором в CIL (IL) выполняется CRL. В процессе работы происходит JIT (just in time) компиляция, которая компилирует IL код, в код, понятный компьютеру.

Кроме того, CRL отвечает за работу с потоками, осуществляет оптимизацию кода и многое другое.

При этом CRL не привязан строго к процессу разработки. Это о том, что CRL в целом используется для запуска .Net приложений.

##### .NET Framework и .NET
Стоит отметить, что .NET долгое время развивался премущественно как платформа для Windows под названием .NET Framework. В 2019 вышла последняя версия этой платформы — .NET Framework 4.8. Она больше не развивается

С 2014 Microsoft стал развивать альтернативную платформу — .NET Core, которая уже предназначалась для разных платформ и должна была вобрать в себя все возможности устаревшего .NET Framework и добавить новую функциональность. Затем Microsoft последовательно выпустил ряд версий этой платформы: .NET Core 1, .NET Core 2, .NET Core 3, .NET 5. И текущей версией является расматриваемая в этом руководстве платформа .NET 9. Поэтому следует различать .NET Framework, который предназначен преимущественно для Windows, и кросплатформенный .NET 9.

##### Управляемый и неуправляемый код
Нередко приложение, созданное на C#, называют <dfn title="управляемый код">управляемым кодом</dfn> (managed code). Что это значит? А это значит, что данное приложение создано на основе платформы .NET и поэтому управляется общеязыковой средой CLR, которая загружает приложение и при необходимости очищает память. Но есть также приложения, например, созданные на языке С++, которые компилируются не в общий язык CIL, как C#, VB.NET или F#, а в обычный машинный код. В этом случае .NET не управляет приложением.

В то же время платформа .NET предоставляет возможности для взаимодействия с неуправляемым кодом.

##### JIT-компиляция
Код, написанный на C# (или других языках) обрабатывается компилятором, который идёт вместе с .Net. Хотя таких компиляторов может быть много. Кроме стандартного компилятора, есть Roslyn, например.

Как выше писалось, код на C# компилируется в приложения или сборки с расширениями exe или dll на языке CIL. Далее при запуске на выполнение подобного приложения происходит JIT-компиляция (Just-In-Time) в машинный код, который затем выполняется. При этом, поскольку наше приложение может быть большим и содержать кучу инструкций, в текущий момент времени будет компилироваться лишь та часть приложения, к которой непосредственно идет обращение. Если мы обратимся к другой части кода, то она будет скомпилирована из CIL в машинный код. При том уже скомпилированная часть приложения сохраняется до завершения работы программы. В итоге это повышает производительность.

#### Работа с базами данных в .NET Framework
Работа с базами данных повсеместно встречается в современных приложениях, будь то настольное приложение, веб-сайт или веб-служба. Естественно платформа .NET Framework предлагает множество способов взаимодействия с базами данных из управляемого кода, которые и описываются в данном разделе. Основной системой управления базами данных для Windows являтся SQL Server.

Как и следовало ожидать, платформа .NET определяет ряд пространств имен, которые позволяют непосредственно взаимодействовать с локальными и удаленными базами данных. Вместе эти пространства имен известны как ADO.NET. Существует два базовых уровня работы с ADO.NET: ***подключенный уровень*** (***connected layer***) — позволяет взаимодействовать с базой данных с помощью объектов подключения, чтения данных и команд конкретного поставщика данных; ***отключенный уровень*** (***disconnected layer***) — позволяет смоделировать в памяти данные из базы данных с помощью многочисленных классов из пространства имен `System.Data` (`DataSet`, `DataTable` и т.д.). Кроме того, существует возможность взаимодействия с базой данных через объектную модель C#, с помощью ORM-фреймворка ***Entity Framework***.

- **ADO.NET**

    Платформа .NET Framework включает собственную технологию доступа к данным — ADO.NET. Эта технология состоит из управляемых классов, позволяющих приложениям .NET подключаться к источникам данных (обычно реляционным базам данных), выполнять команды и управлять автономными данными. Маленькое чудо ADO.NET заключается в том, что эта технология позволяет писать более-менее одинаковый код для доступа к данным — как в веб-приложениях, так и в клиент-серверных настольных приложениях, и даже в однопользовательских приложениях, подключаемых к локальной базе данных.

- **Entity Framework 6**

    API-интерфейс Entity Framework спроектирован для работы с любыми базами данных, поддерживающими ADO (а не только с SQL Server), и даже включает собственный диалект независимого от поставщика языка SQL, который можно применять в качестве альтернативы LINQ.

- **SQL Server 2012 и язык T-SQL**

    Система управления базами данных SQL Server является наилучшим выбором для широкого диапазона конечных пользователей и программистов баз данных, работающих над созданием бизнес-приложений. В целом, SQL Server является больше, чем просто системой управления реляционными базами данных. Это платформа, которая не только позволяет управлять структурированными, полуструктурированными и неструктурированными данными, но также предоставляет комплексное, интегрированное системное программное обеспечение и программное обеспечение для аналитических исследований, которые позволяют организациям надежно управлять критически важными данными.

- **Оконные функции T-SQL**

    Одним из самых фундаментальных расширений языка SQL в Microsoft SQL Server 2005 стало добавление оконных функций с такими синтаксическими конструкциями, как предложение `OVER` и набор новых функций, известных как функции ранжирования (`ROW_NUMBER`, `RANK`, и других). В отличие от обычных агрегатных функций, оконные функции не группируют строки в одну выходную строку, а добавляют результаты вычислений к каждой строке результирующей выборки как новое поле. Это позволяет сохранить уникальные идентификаторы строк и упростить выполнение аналитических расчетов. Это добавление позволило решать стандартные проблемы более простым, интуитивно понятным и отличающимся более высокой производительностью способом, чем раньше.

### Технология ADO.NET
Когда Microsoft начала разрабатывать .NET Framework, она имела хорошую возможность пересмотреть модель доступа к данным. Решив не продолжать разработку технологии ADO, специалисты Microsoft приступили к созданию новой структуры доступа к данным, при этом сохранив акроним. Microsoft разрабатывает ADO.NET на базе уже зарекомендовавшей себя объектной технологии ADO. Но ADO.NET ориентируется на три важные возможности, которые не поддерживаются ADO: поддержка модели доступа к несвязанным данным, что является ключевым элементом для работы в Web; поддержка тесной интеграции с XML; интеграция с .NET Framework (например, совместимость с базовой библиотекой классов типичной системы).

ADO.NET является преемником Microsoft ActiveX Data Objects (ADO). Это стандартизированная модель программирования для создания распределенных прикладных программ, нацеленных на совместное использование данных. Подобно ADO, ADO.NET является программным интерфейсом (API) для прикладного программного обеспечения, позволяющим обращаться к данным и другой информации. ADO.NET поддерживает такие современные требования, как создание клиентского интерфейса к базам данных на фронтальном уровне и на уровне промежуточного слоя объектов клиентских приложений, инструментальных средств, языков программирования или Internet браузера.

Технология ADO.NET разработана на основе промышленных стандартов. ADO.NET, подобно ADO, обеспечивает интерфейс доступа к OLE DB — совместимым источникам данных, таким, как Microsoft SQL Server. Прикладные программы, позволяющие пользователям совместно использовать данные, могут использовать ADO.NET для подключения к источниками данных, а также для поиска, управления, и модификации этих данных. Также, прикладные программы (далее ПП) могут использовать OLE DB для управления данными, хранящимися в не относительных форматах, таких, как Microsoft Excel.

В решениях, требующих офлайнового или удаленного доступа к данным, ADO.NET использует XML для обмена данными между программами или с Веб страницами. Любой компонент, который обслуживает XML, также может использовать и компоненты ADO.NET. Если передача пакетов компонентом ADO.NET подразумевает поставку набора данных в файле XML, компонентом, способным обеспечить его получение, может быть только компонент ADO.NET. Передача данных в XML-формате даёт возможность программистам легко отделить обработку данных от компонент пользовательского интерфейса data-sharing ПП, разместив их на отдельных серверах. Это может существенно повысить эффективность и надёжность многопользовательских систем.

Для распределенных ПП, использование наборов данных XML в ADO.NET обеспечивает лучшую эффективность, чем использование COM для офлайнового обслуживания данных в ADO. Поскольку передача наборов данных происходит через файлы XML, описанные в очень простом, принятом повсюду стандарте и являющиеся (по сути) обычными текстовыми файлами, компоненты ADO.NET не имеют ни одного из архитектурных ограничений COM. Наборы данных XML, используемые в ADO.NET избавлены также от необходимости конвертации данных в рекордсете для получения типов данных, применимых в COM. Фактически, любые два компонента могут совместно использовать наборы данных XML при условии, что они оба используют ту же самую схему форматирования набора данных XML. ADO.NET обладает хорошей масштабируемостью, что требуется для совместно использующих данные ПП, работающих на основе Веб. Такие Веб-программы могут обслужить десятки, сотни, а то и тысячи пользователей. ADO.NET не применяет длительные блокировки баз данных или такие активные подключения, которые на долгое время монополизируют ресурсы сервера, являющимися (как правило) весьма ограниченными. Это позволяет увеличивать число пользователей без значительного увеличения утилизации ресурсов системы.

#### Обзор ADO.NET
***ADO.NET*** — нечто большее, чем надстройка над каким-нибудь существующим API-интерфейсом. Сходство с ADO минимально; классы и методы доступа к данным довольно существенно отличаются.

*[ADO]: ActiveX Data Objects
<dfn title="ADO">ADO</dfn> (<dfn title="ActiveX Data Objects">ActiveX Data Objects</dfn>) — это библиотека компонентов СОМ, получившая в последние несколько лет множество воплощений. ADO состоит, прежде всего, из объектов Connection, Command, Recordset и Field. С помощью ADO открывается соединение с базой данных, после чего некоторые данные извлекаются и помещаются в набор записей, состоящих из полей; эти данные затем претерпевают манипуляции и обновления на сервере, после чего соединение закрывается. Кроме того, ADO предлагает так называемый *отключенный набор записей* (*disconnected record set*), который используется, когда соединение с базой нежелательно удерживать открытым в течение длительного времени.

Существует несколько проблем, которые ADO не решает удовлетворительным образом. Наиболее заметная из них — громоздкость (в плане физического размера) отключенного набора записей. Потребность в этом средстве возрастает по мере развития веб-ориентированных вычислений, поэтому в данном случае понадобился свежий подход. Переход от ADO к ADO.NET не должен быть слишком трудным, поскольку между этими технологиями все же имеется некоторое сходство.

Более того, если вы используете SQL Server, существует замечательный набор управляемых классов, которые настроены на обеспечение максимальной производительности базы данных. Одного этого достаточно для перехода на ADO.NET.

*[ODBC]: Open Database Connectivity
ADO.NET поставляется с тремя пространствами имен клиента базы данных: одно для **SQL Server**, другое для источников данных **Open Database Connectivity** (**ODBC**) и третье для любой базы данных, доступной через **OLE DB**. Если выбрана база данных, отличная от SQL Server, отдавайте предпочтение OLE DB, если только не окажется, что нет другого выбора кроме ODBC. Если в качестве базы данных используется Oracle, можете посетить сайт Oracle .NET Developer и получить там их поставщика .NET — ODP.NET на странице www.oracle.com/technology/tech/windows/odpnet/index.html.

С точки зрения программиста, тело ADO.NET составляет базовая сборка с именем **`System.Data.dll`**. В этом двоичном файле находится значительное количество пространств имен, многие из которых представляют типы конкретного поставщика данных ADO.NET.

Большинство шаблонов проектов Visual Studio 2010 автоматически ссылаются на эту ключевую библиотеку доступа к данным. Однако для импортирования нужных пространств имен необходимо изменить кодовые файлы, например:
```cs
using System;
using System.Data;
using System.Data.SqlClient;
```

Учтите также, что кроме `System.Data.dll`, существуют и другие ориентированные на ADO.NET сборки (например, `System.Data.OracleClient.dll` и `System.Data.Entity.dll`), которые необходимо вручную указывать в текущем проекте с помощью диалогового окна *Add Reference* (Добавление ссылки).

##### Три стороны ADO.NET
Библиотеки ADO.NET можно применять тремя концептуально различными способами: в подключенном режиме, в автономном режиме и с помощью технологии Entity Framework. При использовании **подключенного уровня** (**connected layer**), кодовая база явно подключается к соответствующему хранилищу данных и отключается от него. При таком способе использования ADO.NET обычно происходит взаимодействие с хранилищем данных с помощью объектов подключения, объектов команд и объектов чтения данных.

**Автономный уровень** (**disconnected layer**), позволяет работать с набором объектов `DataTable` (содержащихся в `DataSet`), который представляет на стороне клиента копию внешних данных. При получении `DataSet` с помощью соответствующего объекта адаптера данных подключение открывается и закрывается автоматически. Понятно, что этот подход помогает быстро освобождать подключения для других вызовов и повышает масштабируемость систем.

Получив объект `DataSet`, вызывающий код может просматривать и обрабатывать данные без затрат на сетевой трафик. А если нужно занести изменения в хранилище данных, то адаптер данных (вместе с набором операторов SQL) задействуется для обновления данных — при этом подключение открывается заново для проведения обновлений в базе, а затем сразу же закрывается.

*[EF]: Entity Framework
После выпуска .NET 3.5 SP1 в ADO.NET появилась поддержка нового API, которая называется **Entity Framework** (сокращенно EF). Технология EF показывает, что многие низкоуровневые детали работы с базами данных (например, сложные SQL-запросы) скрыты от программиста и отрабатываются за него при генерации соответствующего LINQ-запроса (например, LINQ с Entities).

#### Архитектура и принцип работы ADO.NET
В ADO.NET используется многоуровневая архитектура, которая обращается вокруг небольшого числа ключевых концепций, таких как объекты `Connection`, `Command` и `DataSet`. Однако архитектура ADO.NET серьезно отличается от классической архитектуры ADO.

Объект `Recordset`, который выполняет так много функций в ADO, здесь отсутствует. Вместо него в ADO.NET предусмотрено несколько особых объектов, выполняющих специфические задачи. Три важнейших из них: `DataAdapter`, `DataReader` и `DataSet`.

Очень важный компонент ADO.NET, поставщик (провайдер) данных .NET, реализует интерфейсы ADO.NET. В частности, он реализует объект `DataReader` так, что его могут использовать и приложение, и объект `DataSet`.

Поставщик данных .NET состоит из четырех основных компонентов: `Connection` — для связи с источником данных; `Command` выполняет команды над источником данных; `DataReader` читает данные из источника данных в однонаправленном режиме «только чтение», и `DataAdapter`, который читает данные из источника данных и использует их для заполнения объекта `DataSet`.

Visual Studio .NET содержит два поставщика данных .NET.
*[TDS]: Tabular Data Stream

- *Поставщик данных SQL Server .NET* обеспечивает связь с SQL Server 7.0 и более поздними версиями. Этот метод доступа наиболее эффективен для SQL Server 7.0 и выше, потому что поставщик данных SQL Server .NET связывается напрямую с SQL Server через протокол Tabular Data Stream (TDS).
- *Поставщик данных OLE DB .NET* необходим для соединения с отличными от SQL Server базами данных, такими, как Oracle или IBM DB2. Этот поставщик данных использует OLE DB для соответствующих баз данных.

Существуют различные пути, по которым приложение может связываться с базой данных через ADO.NET. При выборе пути сначала определяется, какой поставщик данных .NET будет использоваться. Если это SQL Server 7.0 или более поздняя версия, то подключается поставщик данных SQL Server.NET. Если база данных SQL Server 6.5 или отличная от SQL Server (например, Oracle), понадобится поставщик данных OLE DB .NET. Заметим, что можно задействовать поставщик данных OLE DB .NET для баз данных SQL 7.0 и выше, но тогда потеряется выигрыш в производительности, который дает прямое подключение к SQL Server через протокол TDS. Однако в этом неспецифическом способе есть свой плюс — мобильность, т. е. можно менять базы данных без модификации кода.

Далее необходимо определить, какую задачу требуется выполнить. Если надо просто прочитать и отобразить данные из источника данных, объекта Data Reader вполне достаточно. Но если предстоит манипулировать данными (например, редактировать или удалять), нужно использовать объект Data Set. Хотя задействовать этот объект следует только в случае необходимости, потому что он работает медленнее, чем Data Reader (Data Set использует Data Reader для заполнения таблиц).

##### Поставщики данных в ADO.NET
<dfn title="поставщик данных">Поставщик данных</dfn> (<dfn title="data provider">data provider</dfn>) — это набор классов ADO.NET, которые позволяют получать доступ к определенной базе данных, выполнять команды SQL и извлекать данные. По сути, поставщик данных — это мост между вашим приложением и источником данных.

В первом приближении поставщик данных можно рассматривать как набор типов, определенных в данном пространстве имен, который предназначен для взаимодействия с конкретным источником данных. Однако независимо от используемого поставщика данных, каждый из них определяет набор классов, обеспечивающих основную функциональность. В таблице ниже приведены некоторые общие основные объекты, их базовые классы (определенные в пространстве имен `System.Data.Common`) и основные интерфейсы (определенные в пространстве имен `System.Data`), которые они реализуют:

*Основные объекты поставщиков данных ADO.NET*

| Тип объекта | Базовый класс | Соответствующие интерфейсы       | Назначение                                                                                                                                                                                                                                 |
| ----------- | ------------- | -------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`Connection`**  | `DbConnection`  | `IDbConnection`                    | Позволяет подключаться к хранилищу данных и отключаться от него. Кроме того, объекты подключения обеспечивают доступ к соответствующим объектам транзакций                                                                                 |
| **`Command`**     | `DbCommand`     | `IDbCommand`                       | Представляет SQL-запрос или хранимую процедуру. Кроме того, объекты команд предоставляют доступ к объекту чтения данных конкретного поставщика данных                                                                                      |
| **`DataReader`**  | `DbDataReader`  | `IDataReader`, `IDataRecord`         | Предоставляет доступ к данным только для чтения в прямом направлении с помощью курсора на стороне сервера                                                                                                                                  |
| **`DataAdapter`** | `DbDataAdapter` | `IDataAdapter`, `IDbDataAdapter`     | Пересылает наборы данных из хранилища данных к вызывающему процессу и обратно. Адаптеры данных содержат подключение и набор из четырех внутренних объектов команд для выборки, вставки, изменения и удаления информации в хранилище данных |
| **`Parameter`**   | `DbParameter`   | `IDataParameter`, `IDbDataParameter` | Представляет именованный параметр в параметризованном запросе                                                                                                                                                                              |
| **`Transaction`** | `DbTransaction` | `IDbTransaction`                   | Инкапсулирует транзакцию в базе данных                                                                                                                                                                                                     |

Конкретные имена этих основных классов различаются у различных поставщиков (например, `SqlConnection`, `OracleConnection`, `OdbcConnection` и `MySqlConnection`), но все эти объекты порождены от одного и того же базового класса (в случае объектов подключения это `DbConnection`), который реализует идентичные интерфейсы (вроде `IDbConnection`). Поэтому если вы научитесь работать с одним поставщиком данных, то легко справитесь и с остальными.

В ADO.NET термин "объект подключения" на самом деле относится к конкретному типу, порожденному от `DbConnection`; объекта подключения "вообще" нет. То же можно сказать и об "объекте команды", "объекте адаптера данных" и т.д. По соглашению имена объектов в конкретном поставщике данных имеют префиксы соответствующей СУБД (например, `SqlConnection`, `OracleConnection`, `SqlDataReader` и т.д.).

Одной из ключевых идей, лежащих в основе модели поставщиков ADO.NET, является расширяемость. Другими словами, разработчики могут создавать собственные поставщики для патентованных источников данных. В действительности доступно множество подтверждающих это примеров, которые демонстрируют, как создавать настраиваемые поставщики ADO.NET, служащие оболочками для нереляционных хранилищ данных, таких как файловая система или служба каталогов. Некоторые независимые производители также продают собственные поставщики данных для .NET.

В рамках .NET Framework поставляется небольшой набор из четырех поставщиков:

- **SQL Server**

    Предоставляет оптимизированный доступ к базам данных SQL Server (версии 7.0 и выше).

- **OLE DB**

    Предоставляет доступ к любому источнику данных, который имеет драйвер OLE DB. Это включает базы данных SQL Server версий, предшествующих 7.0.

- **Oracle**

    Предоставляет оптимизированный доступ к базам данных Oracle (версии 8i и выше).

- **ODBC**

    Предоставляет доступ к любому источнику данных, имеющему драйвер ODBC.

*[ODP]: Oracle Data Provider
В версии .NET 4 поставщик Oracle объявлен устаревшим. И хотя он по-прежнему работает, в Microsoft рекомендуют применять вместо него для доступа к базам данных Oracle поставщик от стороннего производителя, такой как ODP.NET (Oracle Data Provider для .NET) производства Oracle, который доступен на веб-сайте http://www.oracle.com. Этот поставщик обеспечивает расширенную поддержку для специализированных типов данных Oracle, вроде LOB, временных меток и данных XML, а также обладает несколькими дополнительными средствами.

При выборе поставщика сначала пытайтесь найти встроенный поставщик .NET, который предназначен для имеющегося источника данных. Если таковой не найден, можно воспользоваться OLE DB при наличии драйвера OLE DB для источника данных.

Технология OLE DB существует уже много лет как часть ADO, поэтому для большинства источников данных предусмотрены драйверы OLE DB (включая SQL Server, Oracle, Access, MySQL и многие другие). В тех редких случаях, когда найти специализированный поставщик .NET или драйвер OLE DB не удается, можно обратиться к поставщику ODBC, который работает в сочетании с драйвером ODBC.

##### Стандартизация в ADO.NET
На первый взгляд может показаться, что ADO.NET предлагает фрагментированную модель, поскольку не включает обобщенного набора объектов, которые работали бы с множеством типов баз данных. В результате, когда вы переходите от одной реляционной СУБД к другой, приходится модифицировать код доступа к данным для использования другого набора классов.

Но даже несмотря на то, что разные поставщики данных .NET используют различные классы, все они некоторым образом стандартизированы. Точнее говоря, каждый поставщик основан на одном и том же наборе интерфейсов и базовых классов. Так, например, объект `Connection` реализует интерфейс `IDbConnection`, который определяет такие ключевые методы, как `Open()` и `Close()`. Подобная стандартизация гарантирует, что каждый класс `Connection` будет работать одинаковым образом и предоставит один и тот же набор ключевых свойств и методов.

*[TDS]: Tabular Data Stream
"За кулисами" различные поставщики используют совершенно разные низкоуровневые вызовы и API-интерфейсы. Например, поставщик данных SQL Server применяет патентованный протокол ***TDS*** (***Tabular Data Stream — поток табличных данных***) для взаимодействия с сервером. Преимущества этой модели не сразу очевидны, но весьма существенны:

- Поскольку каждый поставщик использует одни и те же интерфейсы и базовые классы, можно писать обобщенный код доступа к данным (с приложением небольших дополнительных усилий), работая с интерфейсами, а не классами поставщиков.

- Поскольку каждый поставщик реализован отдельно, он может использовать соответствующую оптимизацию (это отличается от модели ADO, где каждый вызов базы данных должен проходить через общий уровень, прежде чем достигнет лежащего в основе драйвера базы данных). Кроме того, специализированные поставщики могут добавлять нестандартные средства, которых не имеют другие поставщики (например, возможность SQL Sever выполнять XML-запросы).

ADO.NET также имеет другой уровень стандартизации — **`DataSet`**. Класс `DataSet` — это контейнер данных общего назначения, которые извлекаются из одной или более таблиц источника данных. `DataSet` полностью обобщен; другими словами, специализированные поставщики не определяют собственных специализированных версий класса `DataSet`.

Независимо от того, какой поставщик данных применяется, можно извлекать данные и помещать их в полностью автономный `DataSet` одинаковым образом. Это облегчает отделение кода, извлекающего данные, от кода, обрабатывающего их. В случае смены лежащей в основе базы данных придется изменить только код, извлекающий данные, но если используется `DataSet`, а информация имеет одну и ту же структуру, модифицировать способ ее обработки не понадобится.

##### Фундаментальные классы ADO.NET
Классы ADO.NET группируются в несколько пространств имен. Каждый поставщик имеет свое собственное пространство имен, а обобщенные классы вроде `DataSet` находятся в пространстве имен `System.Data`. Ниже описаны наиболее важные пространства имен для базовой поддержки ADO.NET:

- **`System.Data`**

    Содержит ключевые классы контейнеров данных, которые моделируют столбцы, отношения, таблицы, наборы данных, строки, представления и ограничения. Дополнительно содержит ключевые интерфейсы, которые реализованы объектами данных, основанными на соединениях

- **`System.Data.Common`**

    Содержит базовые, наиболее абстрактные классы, которые реализуют некоторые из интерфейсов из `System.Data` и определяют ядро функциональности ADO.NET. Поставщики данных наследуются от этих классов (`DbConnection`, `DbCommand` и т.п.), создавая собственные специализированные версии

- **`System.Data.OleDb`**

    Содержит классы, используемые для подключения к поставщику OLE DB, включая `OleDbCommand`, `OleDbConnection` и `OleDbDataAdapter`. Эти классы поддерживают большинство поставщиков OLE DB, но не те, что требуют интерфейсов OLE DB версии 2.5

- **`System.Data.SqlClient`**

    Содержит классы, используемые для подключения к базе данных Microsoft SQL Server, в том числе `SqlDbCommand`, `SqlDbConnection` и `SqlDbDataAdapter`. Эти классы оптимизированы для использования интерфейса TDS к SQL Server

- **`System.Data.OracleClient`**

    *[OCI]: Oracle Call Interface
    Содержит классы, необходимые для подключения к базе данных Oracle (версии 8.1.7 и выше), в том числе `OracleCommand`, `OracleConnection` и `OracleDataAdapter`. Эти классы используют оптимизированный интерфейс *OCI* (*Oracle Call Interface — Интерфейс вызовов Oracle*)

- **`System.Data.Odbc`**

    Содержит классы, необходимые для подключения к большинству драйверов ODBC, такие как `OdbcCommand`, `OdbcConnection`, `OdbcDataReader` и `OdbcDataAdapter`. Драйверы ODBC поставляются для всех видов источников данных и конфигурируются через значок *Data Sources* (*Источники данных*) панели управления

- **`System.Data.SqlTypes`**

    Содержит структуры, соответствующие встроенным типам данных SQL Server. Эти классы не являются необходимыми, но предоставляют альтернативу применению стандартных типов данных .NET, требующих автоматического преобразования

##### Автономный уровень
Работа с подключенным уровнем позволяет взаимодействовать с базой данных с помощью первичных объектов подключения, команд и чтения данных. Этот небольшой набор типов позволяет выбирать, вставлять, изменять и удалять записи (а также вызывать хранимые процедуры или выполнять другие операции над данными — например, операторы DDL для создания таблицы и DCL для назначения полномочий). Но вы увидели лишь половину ADO.NET, поскольку с помощью объектной модели ADO.NET можно работать и в *автономном режиме*.

Автономные типы позволяют эмулировать реляционные данные с помощью модели объектов, находящихся в памяти. Кроме простого моделирования табличных данных, состоящих из строк и столбцов, типы из `System.Data` позволяют воспроизводить отношения между таблицами, ограничения столбцов, первичные ключи, представления и другие примитивы баз данных. К смоделированным данным можно применять фильтры, отправлять запросы и сохранять (или загружать) данные в формате XML и двоичном формате. И все это можно делать, даже не подключаясь к СУБД (откуда и термин "автономный уровень") — достаточно загрузить данные из локального XML-файла или программным образом создать объект `DataSet`.

Автономные типы действительно можно использовать без подключения к базе данных, но все-таки обычно применяются подключения и объекты команд. Кроме того, используется и особый объект — <dfn title="адаптер данных">адаптер данных</dfn> (расширяющий абстрактный тип `DbDataAdapter`), который как раз поставляет и обновляет данные. Но в отличие от подключенного уровня, данные, полученные через адаптер данных, не обрабатываются с помощью объектов чтения данных. Вместо этого объекты адаптеров пересылают данные между вызывающим процессом и источником данных с помощью объектов `DataSet`.

Тип `DataSet` представляет собой контейнер для любого количества объектов `DataTable`, каждый из которых содержит коллекцию объектов `DataRow` и `DataColumn`. Объект адаптера данных конкретного поставщика данных автоматически обслуживает подключение к базе данных. Для повышения масштабируемости адаптеры данных держат подключение открытым минимально возможное время. Как только вызывающий процесс получит объект `DataSet`, вызывающий уровень полностью отключается от базы данных и остается с локальной копией удаленных данных.

Теперь в нем можно вставлять, удалять или изменять строки различных объектов `DataTable`, но физическая база данных не обновляется, пока вызывающий процесс явно не передаст `DataSet` адаптеру данных для обновления. По сути, объекты `DataSet` имитируют постоянное подключение клиентов, хотя на самом деле они работают с находящейся в памяти базой данных.

#### Сравнение ADO и ADO.NET
ADO.NET — эволюционное развитие ADO. Самый простой путь быстрого понимания преимуществ ADO.NET состоит в сравнении с ADO.

| Термин  | ADO  | ADO.NET |
-- | -- | --
Резидентное представление данных в памяти | Использует объект RecordSet, который напоминает отдельную таблицу. | Использует объект DataSet, который может содержать одну или более таблиц, представленных объектами DataTable
Отношения между множеством таблицами | Требует, чтобы запрос JOIN транслировал данные из объединяемых таблиц базы данных в отдельную, результирующую таблицу. | Поддерживает объект DataRelation, чтобы сопоставить строки в одном объекте DataTable со строками в другом объекте DataTable.
Инспектирование данных | Последовательное сканирование данных DataSet | Использует навигационную парадигму для непоследовательного доступа к строкам в таблице. Следует за отношениями, чтобы передвигаться от строк в одной таблице к соответствующим строкам в другой таблице.
Офлайновый доступ | Использует RecordSet, для которого типична поддержка соединения, представленная объектом Connection. Вы подключаетесь к базе данных посредством запросов к OLE DB провайдеру. | Подключается к базе данных посредством стандартизированных запросов к объекту DataSetCommand, который подключается к OLE DB провайдеру (а иногда, непосредственно к API, обеспечивающемуся СУБД).
Программируемость | Использует объект Connection, чтобы передать команды, адресуемые источникам данных, лежащим в основе конструкции данных. | Использует строгий формат программирования характеристик XML. Данные включают в себя собственные описатели, поэтому, имена элементов кода отражают реальные проблемы, решаемые кодом. Лежащие в основе конструкций данных типы таблиц, строки, и таблицы, делают код проще для понимания и написания.
Совместное использование офлайновый данных между уровнями или компонентами | Использует COM для передачи RecordSet в офлайне. Поддерживаются только те типы данных, которыми располагает стандарт COM. Требуется преобразование типов, которое отнимает системные ресурсы. | Передает DataSet с XML файлом. Формат XML не имеет никаких ограничений на типы данных и не требует никаких преобразований типов.
Передача данных через межсетевые экраны (firewalls) | Проблематично, потому что межсетевые экраны обычно конфигурируются так, чтобы предотвратить запросы системного уровня, которые используются в COM. | Поддерживается, потому что объекты DataSet, используемые ADO.NET, передают XML, разработанный на основе HTML, который может проходить через межсетевые экраны.
Масштабируемость | Блокировки баз данных и длительные, активные подключения к базам данных могут стать причиной коллизий и сильно ограничивать ресурсы базы данных. | Офлайновый доступ к базам данных без накладывания длительных блокировок или применения длительных, активных подключений к базе данных, существенно разгружает ресурсы базы данных.

### ADO.NET Entity Framework

#### Предыстория возникновения
Подключенный и автономный уровни ADO.NET снабжают фабрикой, которая позволяет выбирать, вставлять, обновлять и удалять данные с помощью объектов соединений, команд, чтения данных, адаптеров данных и `DataSet`. Хотя все это замечательно, эти аспекты ADO.NET заставляют трактовать полученные данные в манере, которая тесно связана с физической схемой данных.

Вспомните, например, что при использовании подключенного уровня обычно производится итерация по каждой записи за счет указания имен столбцов объекту чтения данных. С другой стороны, в случае работы с автономным уровнем придется иметь дело с коллекциями строк и столбцов объекта `DataTable` внутри контейнера `DataSet`.

При использовании подключенного и автономного уровней ADO.NET всегда приходится помнить о физической структуре лежащей в основе базы данных. Необходимо знать схему каждой таблицы данных, писать сложные SQL-запросы для взаимодействия с данными таблиц и т.д. Это вынуждает писать довольно громоздкий код C#, поскольку C# существенно отличается от языка самой базы данных.

Вдобавок способ конструирования физической базы данных (администратором баз данных) полностью сосредоточен на таких конструкциях базы, как внешние ключи, представления и хранимые процедуры. Сложность баз данных, спроектированных администратором, может еще более возрастать, если администратор при этом заботится о безопасности и масштабируемости. Это также усложняет код C#, который приходится писать для взаимодействия с хранилищем данных.

Платформа <dfn title="Entity Framework">ADO.NET Entity Framework</dfn> (<dfn title="EF">EF</dfn>) — это программная модель, которая пытается заполнить пробел между конструкциями базы данных и объектно-ориентированными конструкциями. Используя EF, можно взаимодействовать с реляционными базами данных, не имея дело с кодом SQL (при желании). Исполняющая среда EF генерирует подходящие операторы SQL, когда вы применяете запросы LINQ к строго типизированным классам.

<dfn title="LINQ to Entities">LINQ to Entities</dfn> — это термин, описывающий применение запросов LINQ к сущностным объектам ADO.NET.

Другой возможный подход состоит в том, чтобы вместо обновления базы данных посредством нахождения строки, обновления строки и отправки строки обратно на обработку в пакете запросов SQL, просто изменять свойства объекта и сохранять его состояние. И в этом случае исполняющая среда EF обновляет базу данных автоматически.

В Microsoft считают ADO.NET Entity Framework новым членом семейства технологий доступа к данным, и не намерены заменять им подключенный и автономный уровни. Однако после недолгого использования EF часто отдается предпочтение этой развитой объектной модели перед относительно примитивным миром SQL-запросов и коллекций строк/столбцов.

Тем не менее, иногда в проектах .NET используются все три подхода, поскольку одна только модель EF чрезмерно усложняет код. Например, при построении внутреннего приложения, которому нужно взаимодействовать с единственной таблицей базы данных, подключенный уровень может применяться для запуска пакета хранимых процедур. Существенно выиграть от использования EF могут более крупные приложения, особенно если команда разработчиков уверенно работает с LINQ. Как с любой новой технологией, следует знать, как (и когда) имеет смысл применять ADO.NET EF.

#### ORM / Объектно-реляционное отображение
При работе с реляционными базами данных мы используем таблицы со строками и столбцами, такая инфраструктура устройства баз данных является очень структурированной. Перед широким внедрением объектно-ориентированного программирования мы работали в рамках “процедурного” программирования – для решения проблем использовался структурный код и функции. Устройство баз данных в виде таблиц, строк и столбцов было в какой-то степени похоже на структурные и процедурные шаблоны программирования, которые мы использовали в нашем коде. Жизнь была хороша ...

После этого произошла эволюция на стороне кода – сейчас мы уже не используем функции, а думаем в терминах объектов, классов и моделей. Процесс разработки программного обеспечения значительно повзрослел за эти годы и обрел концептуальный уровень – изменилось все, начиная от кода (появились ООП, различные фреймворки и шаблоны облегчающие жизнь) и заканчивая командами разработчиков (современный крупный проект трудно представить без архитекторов, дизайнеров, оптимизаторов и т.д.)

При этом эти изменения практически не затронули базы данных. Данные все также остаются заперты в таблицах, строках и столбцах. Это создает большую пропасть в работе между иерархическим объектно-ориентированным кодом и высоко-нормализованной структурой баз данных. Чтобы справиться с этой проблемой, разработчики предложили внести в программные проекты “объектный слой базы данных”, в котором таблицы баз данных представлялись в виде классов, столбцы в виде свойств, а вся работа с базой данных строилась на программном коде без использования SQL. Такой подход получил название <dfn title="объектно-реляционное отображение">объектно-реляционного отображения</dfn> (<dfn title="object-relational mapping">object-relational mapping</dfn> — <dfn title="ORM">ORM</dfn>).

Различные программные платформы предлагают множество систем, реализующих модель ORM. ***Entity Framework*** в сочетании с [LINQ (Language-Integrated Query)](https://professorweb.ru/my/LINQ/base/level1/info_linq.php) представляет собой реализацию ORM для платформы .NET Framework от компании Microsoft. Entity Framework содержит механизмы создания и работы с сущностями базы данных через объектно-ориентированный код на языке, совместимым с CLR (в наших примерах мы будем использовать C#). LINQ представляет собой библиотеку, расширяющую возможности C#, и облегчающую создание запросов (благодаря LINQ можно создавать SQL-подобные запросы в коде C#).

Entity Framework является продолжением другого API-интерфейса для работы с базами данных в .NET – [ADO.NET](https://professorweb.ru/my/ADO_NET/base/level1/ado_net_index.php), в котором для работы с базами данных приходилось писать запросы на SQL и вставлять их в команды. Думаю как вы поняли, Entity Framework значительно облегчает жизнь программистам C#, слабо разбирающимся в SQL и в деталях работы с базами данных.

#### История развития Entity Framework
Entity Framework представляет стратегический подход Microsoft к технологии доступа к данным для построения приложений. В отличие от предыдущих технологий доступа к данным, Entity Framework, в сочетании с Visual Studio, обеспечивает широкие возможности работы с базами данных и может использоваться в любых приложениях, будь это веб-сайт, настольное приложение или веб-служба. Давайте кратко рассмотрим хронологию развития Entity Framework.

Впервые Entity Framework появился в 2007 году, а его первая поддержка была обеспечена в Visual Studio 2008, после чего этот API-интерфейс проделал долгий путь и оброс новыми возможностями.

*[POCO]: Plain Old CLR Object
В первой версии Entity Framework был достаточно ограничен и обеспечивал только базовую реализацию модели ORM на основе подхода Database-First (рассмотрим чуть позже). Версия 4.0 появилась вместе с .NET Framework 4 и Visual Studio 2010 и принесла нам новый подход — Model-First и поддержку *POCO-объектов* (POCO — Plain Old CLR Object). Вскоре после этого, команда разработчиков Entity Framework выпустила три версии (4.1 – 4.3), в которых поддерживался еще один подход к реализации ORM – Code-First.

Версия 5 Entity Framework вышла вместе с выпуском .NET 4.5 и Visual Studio 2012. Эта версия обеспечивает значительное повышение производительности наряду с поддержкой перечислений, табличных функций, пространственных типов Transact SQL, импорта хранимых процедур, и глубокой интеграцией с ASP.NET MVC.

Текущей версией Entity Framework является 6, в которой появилась поддержка асинхронных запросов и возможность работы с хранимыми процедурами через подход Code-First. Более подробный список изменений в версиях Entity Framework вы можете увидеть на сайте MSDN в статье [Entity Framework Version History](https://msdn.microsoft.com/en-us/data/jj574253.aspx).

#### Архитектура Entity Framework
Давайте рассмотрим архитектуру EF. Составные части архитектуры ADO.NET Entity Framework не столь сложны, как могут показаться на первый взгляд. Давайте рассмотрим их более подробно.

Строго типизированные классы, упомянутые ранее, называются <dfn title="сущность">сущностями</dfn> (***entities***). Сущности — это концептуальная модель физической базы данных, которая отображается на предметную область. Формально говоря, эта модель называется <dfn title="модель сущностных данных">моделью сущностных данных</dfn> (<dfn title="Entity Data Model">Entity Data Model</dfn> — <dfn title="EDM">EDM</dfn>). Модель EDM представляет собой набор классов клиентской стороны, которые отображаются на физическую базу данных.

Тем не менее, нужно понимать, что сущности вовсе не обязаны напрямую отображаться на схему базы данных, как может показаться, исходя из названия. Сущностные классы можно реструктурировать для соответствия существующим потребностям, и исполняющая среда EF отобразит эти уникальные имена на корректную схему базы данных.

Во многих случаях сущностный класс клиентской стороны называется по имени связанной с ним таблицы базы данных. Однако помните, что вы всегда можете изменить сущность для лучшего соответствия конкретной ситуации.

API-интерфейс EF находится на вершине существующей инфраструктуры ADO.NET. Подобно любому взаимодействию ADO.NET, сущностная платформа использует поставщик данных ADO.NET для взаимодействия с хранилищем данных. Однако поставщик данных должен быть обновлен, чтобы поддерживать новый набор служб, прежде чем он сможет взаимодействовать с API-интерфейсом ЕF. И как можно было ожидать, поставщик данных Microsoft SQL Server уже обновлен соответствующей инфраструктурой, которая полагается на использование сборки `System.Data.Entity.dll`.

Многие сторонние базы данных (например, Oracle и MySQL) предлагают EF-совместимые поставщики данных. Детальную информацию можно узнать у поставщика системы управления базами данных или просмотреть список известных поставщиков данных ADO.NET.

В дополнение к добавлению необходимых компонентов к поставщику данных Microsoft SQL Server, сборка `System.Data.Entity.dll` содержит различные пространства имен, которые сами полагаются на службы EF. Две ключевых части API-интерфейса EF, на которые следует обратить внимание сейчас — это **службы объектов** (object services) и **клиент сущности** (entity client).

##### Роль служб объектов
Под службами объектов подразумевается часть EF, которая управляет сущностями клиентской стороны при работе с ними в коде. Службы объектов отслеживают изменения, внесенные в сущность (например, смена цвета автомобиля с зеленого на синий), управляют отношениями между сущностями (скажем, просмотр всех заказов для клиента с заданным именем), а также обеспечивают возможности сохранения изменений в базе данных и сохранение состояния сущности с помощью сериализации (XML и двоичной).

<details>
<summary><em>Сериализация в десериализация</em></summary>

<dfn title="сериализация">Сериализация</dfn> (в программировании) — процесс перевода структуры данных в битовую последовательность. Обратной к операции сериализации является операция <dfn title="десериализация">десериализации</dfn> (структуризации) — создание структуры данных из битовой последовательности.

<dfn title="сериализация">Сериализация</dfn> — это преобразование объекта или дерева объектов в какой-либо формат (обычно текстовый или в набор байт) с тем, чтобы потом исходные объекты можно было восстановить из этого формата. Используется, например, для сохранения состояния программы (то есть, некоторых её объектов) между запусками. Или для передачи данных между различными экземплярами программы (или различными программами), например, по сети.

Главная идея состоит в том, что сериализованный формат — набор байт или строка, которую можно легко сохранить на диск или передать другому процессу (возможно, находящемуся на другом хосте), в отличие от самого объекта. А значит, задача сохранения/передачи объекта (или группы объектов) при этом сводится к простой задаче сохранения/передачи набора байт или строки.

JSON — один из популярных форматов для сериализации, он текстовый, легковесный и легко читается человеком. Является альтернативой более громоздкому XML.

Сериализация используется для передачи объектов по сети и для сохранения их в файлы. Например, нужно создать распределённое приложение, разные части которого должны обмениваться данными со сложной структурой. В таком случае для типов данных, которые предполагается передавать, пишется код, который осуществляет сериализацию и десериализацию. Объект заполняется нужными данными, затем вызывается код сериализации, в результате получается, например, XML-документ. Результат сериализации передаётся принимающей стороне по, скажем, электронной почте или HTTP. Приложение-получатель создаёт объект того же типа и вызывает код десериализации, в результате получая объект с теми же данными, что были в объекте приложения-отправителя. По такой схеме работает, например, сериализация объектов через SOAP в Microsoft .NET.

</details>

С точки зрения программирования, уровень службы объектов управляет любым классом, расширяющим базовый класс `EntityObject`. Как и ожидалось, `EntityObject` представляет цепочку наследования для любых сущностных классов в программной модели EF.

##### Роль клиента сущности
Вторым важным аспектом API-интерфейса EF является уровень клиента сущности. Эта часть API-интерфейса EF отвечает за работу с поставщиком данных ADO.NET для установки соединений с базой данных, генерации необходимых SQL-операторов на основе состояния сущностей и запросов LINQ, отображения извлеченных данных на корректные формы сущностей, а также управления прочими деталями, которые обычно приходится делать вручную, если не используется Entity Framework.

Функциональность уровня клиента сущности определена в пространстве имен `System.Data.EntityClient`. Это пространство имен включает набор классов, которые отображают концепции EF (такие как запросы LINQ to Entity) на лежащий в основе поставщик данных ADO.NET. Эти классы (т.е. `EntityCommand` и `EntityConnection`) очень похожи на классы, которые можно найти в составе поставщика данных ADO.NET.

Уровень клиента сущности обычно работает "за кулисами", но вполне может взаимодействовать с клиентом сущности напрямую, если нужен полный контроль над его действиями (прежде всего, над генерацией запросов SQL и обработкой возвращенных данных из базы).

Если требуется более тонкий контроль над тем, как сущностный клиент строит SQL-оператор на основе входящего запроса LINQ, можно использовать Entity SQL. Это независимый от базы данных диалект SQL, который работает непосредственно с сущностями. Построенный запрос Entity SQL может быть отправлен непосредственно службам клиента сущности (или, при желании, объектным службам), где он будет сформатирован в правильный SQL-оператор для лежащего в основе поставщика данных.

Если требуется более высокая степень контроля над манипуляциями извлеченными результатами, можно отказаться от автоматического отображения результатов базы данных на сущностные объекты и вручную обрабатывать записи с помощью класса `EntityDataReader`. Как и можно было ожидать, `EntityDataReader` позволяет обрабатывать извлеченные данные с использованием однонаправленного, доступного только для чтения потока данных, как это делает `SqlDataReader`.

##### Роль файла *.edmx
Подводя итог сказанному: сущности — это классы клиентской стороны, которые функционируют, как модель сущностных данных (Entity Data Model). Хотя сущности клиентской стороны в конечном итоге отображаются на таблицу базы данных, жесткая связь между именами свойств сущностных классов и именами столбцов таблиц с данными отсутствует.

В контексте API-интерфейса Entity Framework, чтобы данные сущностных классов отображались на данные таблиц корректно, требуется правильное определение логики отображения. В любой системе, управляемой моделью данных, уровни сущностей, реальной базы данных и отображения разделены на отдельные части: *концептуальная модель*, *логическая модель* и *физическая модель*:

- <dfn title="концептуальная модель">Концептуальная модель</dfn> определяет сущности и отношения между ними (если есть).

- <dfn title="логическая модель">Логическая модель</dfn> отображает сущности и отношения на таблицы с любыми необходимыми ограничениями внешних ключей.

- <dfn title="физическая модель">Физическая модель</dfn> представляет возможности конкретного механизма данных, указывая детали хранилища, такие как табличная схема, разбиение на разделы и индексация.

В мире EF каждый из этих трех уровней фиксируется в XML-файле. В результате использования интегрированных визуальных конструкторов Entity Framework из Visual Studio 2010 получается файл с расширением **.edmx*. Этот файл содержит XML-описания сущностей, физической базы данных и инструкции относительно того, как отображать эту информацию между концептуальной и физической моделями.

##### Роль классов ObjectContext и ObjectSet<T>
Последним фрагментом мозаики EF является класс `ObjectContext`, определенный в пространстве имен `System.Data.Objects`. Генерация файла **.edmx* дает в результате сущностные классы, которые отображаются на таблицы базы данных, и класс, расширяющий `ObjectContext`. Обычно этот класс используется для непрямого взаимодействия со службами объектов и функциональностью клиента сущности.

Класс `ObjectContext` предлагает набор базовых служб для дочерних классов, включая возможность сохранения всех изменений (которые в конечном итоге превращаются в обновление базы данных), настройку строки соединения, удаление объектов, вызов хранимых процедур, а также обработку других фундаментальных деталей.

#### Модель EDM
Понимая предназначение платформы ADO.NET Entity Framewrok, а также имея общее представление о ее работе, можно приступать к рассмотрению первого примера. Чтобы пока не усложнять картину, построим простую модель EDM.

##### Генерация файла *.edmx
Начнем с создания консольного приложения. Когда планируется использование Entity Framework, первый шаг состоит в генерации необходимой концептуальной, логической и физической модели данных, определенной в файле *\*.edmx*. Один из способов предусматривает применение для этого утилиты командной строки *EdmGen.exe* из комплекта .NET 4.0 SDK. Откройте окно командной строки Visual Studio и введите следующую команду:
```cmd
EdmGen.exe -?
```

На консоль выводится список опций, которые можно указывать утилите для генерации необходимых файлов, основываясь на существующей базе данных; кроме того, доступны опции для генерации совершенно новой базы данных на основе имеющихся сущностных файлов. Ниже описаны некоторые общие опции *EdmGen.exe*:

- **`/mode:FullGeneration`**

    Генерировать файлы *.ssdl, *.msl, *.csdl и клиентские сущности из указанной базы данных

- **`/project:`**

    Базовое имя, которое должно использоваться для сгенерированного кода и файлов. Обычно это имя базы данных, из которой извлекается информация (допускается сокращенная форма — `/р:`)

- **`/connectionstring:`**

    Строка соединения, используемая для взаимодействия с базой данных (допускается сокращенная форма — `/с:`)

- **`/language:`**

    Позволяет указать, какой синтаксис должен использоваться для сгенерированного кода — C# или VB

- **`/pluralize`**

    Позволяет автоматически выбирать множественное или единственное число для имени набора сущностей, имени типа сущности и имени навигационного свойства, согласно правилам английского языка

Как и платформа .NET 4.0 в целом, программная модель EF поддерживает программирование в стиле сначала домен (*domain first*), что позволяет создавать свойства (с применением типичных объектно-ориентированных приемов) и использовать их для генерации новой базы данных.

##### Изменение формы сущностных данных
После завершения работы с мастером откроется визуальный конструктор EDM в IDE-среде с одной сущностью по имени `Inventory`. Просмотреть композицию любой сущности в визуальном конструкторе можно в окне *Model Browser* (*Браузер моделей*), которое открывается через пункт меню *View* --> *Other Windows* (*Вид* --> *Другие окна*).

По умолчанию имена сущностей будут основаны на именах исходных объектов баз данных; однако, вспомните, что имена сущностей в концептуальной модели могут быть любыми. Чтобы изменить имя сущности либо имена свойств сущности, необходимо выбрать нужный элемент в визуальном конструкторе и установить соответствующим образом свойство `Name` в окне свойств (*Properties*).

##### Просмотр отображений
Имея данные в измененной форме, можно просматривать отображения между концептуальным уровнем и физическим уровнем в окне *Mapping Details* (*Сведения об отображениях*), которое открывается через пункт меню *View* --> *Other Windows* --> *Mapping Details*. Обратите внимание, что узлы в левой части дерева представляют имена данных из физического уровня, в то время как узлы справа представляют имена концептуальной модели.

##### Просмотр данных сгенерированного файла *.edmx
Теперь давайте посмотрим, что именно мастер EDM Wizard сгенерировал. Щелкните правой кнопкой мыши на файле *InventoryEDM.edmx* в проводнике решения и выберите в контекстном меню пункт *Open With...* (*Открыть с помощью*). В открывшемся диалоговом окне выберите опцию *XML Editor* (*Редактор XML*). Это позволит просмотреть XML-данные, лежащие в основе представления в визуальном конструкторе EDM. Структура этого XML-документа разделена на четыре части: все они находятся в корневом элементе `<edms:Edmx>`.

Подэлемент `<edmx:Runtime>` определяет XML-данные для концептуальной, физической и модели уровня отображения. Ниже показано определение физической таблицы базы данных `Inventory`:
```xml
<!-- SSDL content -->
    <edmx:StorageModels>
      <Schema Namespace="AutoLotModel.Store" Alias="Self" Provider="System.Data.SqlClient" ProviderManifestToken="2008" xmlns:store="http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator" xmlns="http://schemas.microsoft.com/ado/2009/02/edm/ssdl">
        <EntityContainer Name="AutoLotModelStoreContainer">
          <EntitySet Name="Inventory" EntityType="AutoLotModel.Store.Inventory" store:Type="Tables" Schema="dbo" />
        </EntityContainer>
        <EntityType Name="Inventory">
          <Key>
            <PropertyRef Name="CarID" />
          </Key>
          <Property Name="CarID" Type="int" Nullable="false" />
          <Property Name="Make" Type="varchar" MaxLength="50" />
          <Property Name="Color" Type="varchar" MaxLength="50" />
          <Property Name="PetName" Type="varchar" Nullable="false" MaxLength="50" />
        </EntityType>
      </Schema>
</edmx:StorageModels>
```

Обратите внимание, что узел `<Schema>` определяет имя поставщика данных ADO.NET, который использует эту информацию при взаимодействии с базой данных (`System.Data.SqlClient`). Узлами `<EntityType>` помечается имя физической таблицы базы данных, а также каждый столбец в таблице.

Следующая важная часть файла *.edmx — элемент `<edmx:ConceptualModels>`. который определяет измененные сущности клиентской стороны. Как видно, сущность `Cars` определяет свойство `CarNickname`, которое изменяется в визуальном конструкторе:
```xml
<!-- CSDL content -->
<edmx:ConceptualModels>
<Schema Namespace="AutoLotModel" Alias="Self" xmlns:annotation="http://schemas.microsoft.com/ado/2009/02/edm/annotation" xmlns="http://schemas.microsoft.com/ado/2008/09/edm">
    <EntityContainer Name="AutoLotEntities" annotation:LazyLoadingEnabled="true">
    <EntitySet Name="Cars" EntityType="AutoLotModel.Car" />
    </EntityContainer>
    <EntityType Name="Car">
    <Key>
        <PropertyRef Name="CarID" />
    </Key>
    <Property Name="CarID" Type="Int32" Nullable="false" />
    <Property Name="Make" Type="String" MaxLength="50" Unicode="false" FixedLength="false" />
    <Property Name="Color" Type="String" MaxLength="50" Unicode="false" FixedLength="false" />
    <Property Name="CarNickname" Type="String" Nullable="false" MaxLength="50" Unicode="false" FixedLength="false" />
    </EntityType>
</Schema>
</edmx:ConceptualModels>
```

Это перемещает на уровень отображения, который окно *Mapping Details* и исполняющая среда EF используют для подключения имен в концептуальной модели к физической модели:
```xml
<!-- C-S mapping content -->
<edmx:Mappings>
    <Mapping Space="C-S" xmlns="http://schemas.microsoft.com/ado/2008/09/mapping/cs">
    <EntityContainerMapping StorageEntityContainer="AutoLotModelStoreContainer" CdmEntityContainer="AutoLotEntities">
        <EntitySetMapping Name="Cars"><EntityTypeMapping TypeName="AutoLotModel.Car"><MappingFragment StoreEntitySet="Inventory">
        <ScalarProperty Name="CarID" ColumnName="CarID" />
        <ScalarProperty Name="Make" ColumnName="Make" />
        <ScalarProperty Name="Color" ColumnName="Color" />
        <ScalarProperty Name="CarNickname" ColumnName="PetName" />
        </MappingFragment></EntityTypeMapping></EntitySetMapping>
    </EntityContainerMapping>
    </Mapping>
</edmx:Mappings>
</edmx:Runtime>
```

Последней частью файла *.edmx является элемент `<Designer>`. который исполняющей средой EF не используется. Он содержит инструкции, используемые Visual Studio для отображения сущностей на поверхности визуального конструктора.

Удостоверьтесь, что проект скомпилирован, по крайней мере, однажды, и щелкните на кнопке *Show All Files* (*Показать все файлы*) в проводнике решений. Затем зайдите в папку *obj\Debug*, а после этого — в *edmxResourcesToEmbed*. Здесь находятся три XML-файла, основанные на содержимом файла *.edmx.

Данные в этих файлах будут встроены в сборку как двоичные ресурсы. Таким образом, приложение .NET обладает всей информацией, необходимой для понимания концептуального, физического и уровня отображения модели EDM.
