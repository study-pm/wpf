## Bindings / Привязки

- [Bindings / Привязки](#bindings--привязки)
  - [Введение в привязку](#введение-в-привязку)
    - [Классификация привязок](#классификация-привязок)
    - [Работа с привязкой в C#](#работа-с-привязкой-в-c)
    - [Режимы привязки](#режимы-привязки)
    - [Обновление привязки. UpdateSourceTrigger](#обновление-привязки-updatesourcetrigger)
    - [Свойство Source](#свойство-source)
    - [Свойство TargetNullValue](#свойство-targetnullvalue)
    - [Свойство RelativeSource](#свойство-relativesource)
    - [Свойство IsAsync](#свойство-isasync)
    - [Свойство DataContext](#свойство-datacontext)
  - [Привязка элементов](#привязка-элементов)
    - [Связывание элементов](#связывание-элементов)
      - [Ошибки привязки](#ошибки-привязки)
    - [Режимы привязки](#режимы-привязки-1)
    - [Создание привязки в коде](#создание-привязки-в-коде)
    - [Множественные привязки](#множественные-привязки)
    - [Обновление привязок](#обновление-привязок)
    - [Привязка к объектам](#привязка-к-объектам)
      - [Свойство Source](#свойство-source-1)
      - [Свойство RelativeSource](#свойство-relativesource-1)
      - [Свойство DataContext](#свойство-datacontext-1)
  - [Привязка данных](#привязка-данных)
    - [Режимы привязки](#режимы-привязки-2)
    - [Особенности](#особенности)
    - [Привязка к данным в отделенном коде](#привязка-к-данным-в-отделенном-коде)
  - [Интерфейс INotifyPropertyChanged](#интерфейс-inotifypropertychanged)
    - [Дополнительные возможности](#дополнительные-возможности)
    - [Использование объектно-ориентированного проектирования](#использование-объектно-ориентированного-проектирования)
  - [Форматирование привязанных данных](#форматирование-привязанных-данных)
    - [Преобразование данных](#преобразование-данных)
      - [Свойство StringFormat](#свойство-stringformat)
      - [Конвертеры значений](#конвертеры-значений)
      - [Форматирование строк с помощью конвертера значений](#форматирование-строк-с-помощью-конвертера-значений)
      - [Создание объектов с конвертером значений](#создание-объектов-с-конвертером-значений)
      - [Применение условного форматирования](#применение-условного-форматирования)
      - [Оценка множества свойств](#оценка-множества-свойств)
    - [Форматирование значений](#форматирование-значений)
    - [Конвертеры значений](#конвертеры-значений-1)
    - [Списочные элементы управления](#списочные-элементы-управления)

### Введение в привязку
В WPF привязка (binding) является мощным инструментом программирования, без которого не обходится ни одно серьезное приложение. <dfn title="привязка">Привязка</dfn> в WPF — это мощный механизм, позволяющий связывать свойства элементов управления с данными из различных источников. Это позволяет синхронизировать значения свойств двух разных объектов, что упрощает представление и взаимодействие с данными в приложениях.

Привязка подразумевает взаимодействие двух объектов: *источника* и *приемника*. Объект-приемник создает привязку к определенному свойству объекта-источника. В случае модификации объекта-источника, объект-приемник также будет модифицирован.

Например, простейшая форма с использованием привязки:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="250" Width="300">
    <StackPanel>
        <TextBox x:Name="myTextBox" Height="30" />
        <TextBlock x:Name="myTextBlock" Text="{Binding ElementName=myTextBox,Path=Text}" Height="30" />
    </StackPanel>
</Window>
```

Для определения привязки используется выражение типа:
```xml
{Binding ElementName=Имя_объекта-источника, Path=Свойство_объекта-источника}
```

То есть в данном случае у нас элемент `TextBox` является источником, а `TextBlock` — приемником привязки. Свойство `Text` элемента `TextBlock` привязывается к свойству `Text` элемента `TextBox`. В итоге при осуществлении ввода в текстовое поле синхронно будут происходить изменения в текстовом блоке.

#### Классификация привязок
В WPF существует несколько видов привязок, которые позволяют связывать свойства элементов управления с данными из различных источников. Основные виды привязок включают:

1. <dfn title="привязка элементов">Привязка элементов</dfn> — это механизм, позволяющий связывать свойства различных элементов управления между собой. Привязка элементов — это простейший сценарий, когда источником данных является другой элемент WPF, а целевым свойством — свойство зависимости другого элемента. Это позволяет синхронизировать значения свойств элементов, что упрощает создание динамического и отзывчивого пользовательского интерфейса. Пример:

    ```xml
    <TextBox x:Name="textBox1" />
    <TextBlock Text="{Binding ElementName=textBox1, Path=Text}" />
    ```

2. <dfn title="привязка объектов">Привязка объектов</dfn> предполагает связывание свойств элементов WPF с свойствами объектов .NET. Это может быть любой объект, который содержит данные, например, класс с публичными свойствами. Чтобы использовать этот подход, вы должны определить объект в ресурсах или задать его как `DataContext` для элемента.

    ```xml
    <Window.Resources>
        <local:MyData x:Key="myData" ColorName="Red" />
    </Window.Resources>

    <Grid DataContext="{StaticResource myData}">
        <TextBlock Text="{Binding Path=ColorName}" />
    </Grid>
    ```

3. <dfn title="привязка данных">Привязка данных</dfn> — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными. Привязка данных — это более широкое понятие, которое включает в себя привязку элементов WPF к различным источникам данных, таким как коллекции, объекты ADO.NET или XML-данные. Привязка данных позволяет автоматически обновлять интерфейс при изменении данных и наоборот. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения. Пример:

    ```xml
    <ListBox ItemsSource="{Binding Path=Employees}" />
    ```

4. <dfn title="вложенная привязка">Вложенные привязки</dfn> позволяют использовать несколько привязок одновременно для одного свойства. В WPF существуют три вида вложенных привязок:

   - **`Binding`**: Стандартная привязка.

   - **`PriorityBinding`**: Выполняет привязку к нескольким источникам с приоритетом.

   - **`MultiBinding`**: Объединяет несколько значений из разных источников в одно.

   Пример `MultiBinding`:
   ```xml
   <TextBlock>
       <TextBlock.Text>
           <MultiBinding StringFormat="{}{0} {1}">
               <Binding Path="FirstName" />
               <Binding Path="LastName" />
           </MultiBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

#### Работа с привязкой в C#
Ключевым объектом при создании привязки является объект `System.Windows.Data.Binding`.

Определение:
```cs
public class Binding : System.Windows.Data.BindingBase
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding?view=windowsdesktop-9.0

Используя этот объект мы можем получить уже имеющуюся привязку для элемента:
```cs
Binding binding = BindingOperations.GetBinding(myTextBlock, TextBlock.TextProperty);
```

В данном случае получаем привязку для свойства зависимостей `TextProperty` элемента `myTextBlock`.

Также можно полностью установить привязку в коде C#:
```cs
public MainWindow()
{
    InitializeComponent();

    Binding binding = new Binding();

    binding.ElementName = "myTextBox"; // элемент-источник
    binding.Path = new PropertyPath("Text"); // свойство элемента-источника
    myTextBlock.SetBinding(TextBlock.TextProperty, binding); // установка привязки для элемента-приемника
}
```

Если в дальнейшем нам станет не нужна привязка, то мы можем воспользоваться классом **`BindingOperations`** и его методами **`ClearBinding()`** (удаляет одну привязку) и **`ClearAllBindings()`** (удаляет все привязки для данного элемента)
```cs
BindingOperations.ClearBinding(myTextBlock, TextBlock.TextProperty);
```

или
```cs
BindingOperations.ClearAllBindings(myTextBlock);
```

Некоторые свойства класса **`Binding`**:

- **`ElementName`**: имя элемента, к которому создается привязка

- **`IsAsync`**: если установлено в `True`, то использует асинхронный режим получения данных из объекта. По умолчанию равно `False`

- **`Mode`**: режим привязки

- **`Path`**: ссылка на свойство объекта, к которому идет привязка

- **`TargetNullValue`**: устанавливает значение по умолчанию, если привязанное свойство источника привязки имеет значение `null`

- **`RelativeSource`**: создает привязку относительно текущего объекта

- **`Source`**: указывает на объект-источник, если он не является элементом управления.

- **`XPath`**: используется вместо свойства `path` для указания пути к xml-данным

#### Режимы привязки
Свойство **`Mode`** объекта `Binding`, которое представляет режим привязки, может принимать следующие значения:

- **`OneWay`**: свойство объекта-приемника изменяется после модификации свойства объекта-источника.

- **`OneTime`**: свойство объекта-приемника устанавливается по свойству объекта-источника только один раз. В дальнейшем изменения в источнике никак не влияют на объект-приемник.

- **`TwoWay`**: оба объекта — приемник и источник — могут изменять привязанные свойства друг друга.

- **`OneWayToSource`**: объект-приемник, в котором объявлена привязка, меняет объект-источник.

- **`Default`**: по умолчанию (если меняется свойство `TextBox.Text`, то имеет значение `TwoWay`, в остальных случаях `OneWay`).

Применение режима привязки:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30" Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay}" />
</StackPanel>
```

#### Обновление привязки. UpdateSourceTrigger
Односторонняя привязка от источника к приемнику практически мгновенно изменяет свойство приемника. Но если мы используем двустороннюю привязку в случае с текстовыми полями (как в примере выше), то при изменении приемника свойство источника не изменяется мгновенно. Так, в примере выше, чтобы текстовое поле-источник изменилось, нам надо перевести фокус с текстового поля-приемника. И в данном случае в дело вступает свойство **`UpdateSourceTrigger`** класса `Binding`, которое задает, как будет происходить обновление. Это свойство в качестве принимает одно из значений перечисления `UpdateSourceTrigger`:

- `PropertyChanged`: источник привязки обновляется сразу после обновления свойства в приемнике

- `LostFocus`: источник привязки обновляется только после потери фокуса приемником

- `Explicit`: источник не обновляется до тех пор, пока не будет вызван метод `BindingExpression.UpdateSource()`

- `Default`: значение по умолчанию. Для большинства свойств это значение `PropertyChanged`. А для свойства `Text` элемента `TextBox` это значение `LostFocus`

В данном случае речь идет об обновлении источника привязки после изменения приемника в режимах `OneWayToSource` или `TwoWay`. То есть чтобы у нас оба текстовых поля, которые связаны режимом `TwoWay`, моментально обновлялись после изменения одного из них, надо использовать значение `UpdateSourceTrigger.PropertyChanged`:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30"
        Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
</StackPanel>
```

#### Свойство Source
Свойство `Source` позволяет установить привязку даже к тем объектам, которые не являются элементами управления WPF. Например, определим класс `Phone`:
```cs
class Phone
{
    public string Title { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
```

Теперь создадим объект этого класса и определим к нему привязку:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black">
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <TextBlock Text="Модель:" Foreground="White"/>
        <TextBlock x:Name="titleTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Title}"
                        Foreground="White" Grid.Column="1"/>
        <TextBlock Text="Цена:" Foreground="White" Grid.Row="1"/>
        <TextBlock x:Name="priceTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Price}"
                        Foreground="White" Grid.Column="1" Grid.Row="1"/>
    </Grid>
</Window>
```

#### Свойство TargetNullValue
На случай, если свойство в источнике привязки вдруг имеет значение `null`, то есть оно не установлено, мы можем задать некоторое значение по умолчанию. Например:
```xml
<Window.Resources>
    <local:Phone x:Key="nexusPhone" Company="Google" Price="25000" />
</Window.Resources>
<StackPanel>
    <TextBlock x:Name="titleTextBlock"
        Text="{Binding Source={StaticResource nexusPhone}, Path=Title, TargetNullValue=Текст по умолчанию}" />
</StackPanel>
```

#### Свойство RelativeSource
Свойство **`RelativeSource`** позволяет установить привязку относительно элемента-источника, который связан какими-нибудь отношениями с элементом-приемником. Например, элемент-источник может быть одним из внешних контейнеров для элемента-приемника. Либо источником и приемником может быть один и тот же элемент.

Для установки этого свойства используется одноименный объект **`RelativeSource`**. У этого объекта есть свойство **`Mode`**, которое задает способ привязки. Оно принимает одно из значений перечисления **`RelativeSourceMode`**:

- `Self`: привязка осуществляется к свойству этого же элемента. То есть элемент-источник привязки в то же время является и приемником привязки.

- `FindAncestor`: привязка осуществляется к свойству элемента-контейнера.

Например, совместим источник и приемник привязке в самом элементе:
```xml
<TextBox Text="{Binding RelativeSource={RelativeSource Mode=Self}, Path=Background, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
```

Здесь текст и фоновый цвет текстового поля связаны двусторонней привязкой. В итоге мы можем увидеть в поле числовое значение цвета, поменять его, и вместе с ним изменится и фон поля.

Привязка к свойствам контейнера:
```xml
<Grid Background="Black">
    <TextBlock Foreground="White"
        Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType={x:Type Grid}}, Path=Background}" />
</Grid>
```

При использовании режима `FindAncestor`, то есть привязке к контейнеру, необходимо еще указывать параметр **`AncestorType`** и передавать ему тип контейнера в виде выражения `AncestorType={x:Type Тип_элемента-контейнера}`. При этом в качестве контейнера мы могли бы выбрать любой контейнер в дереве элементов, в частности, в данном случае кроме `Grid` таким контейнером также является элемент `Window`.

#### Свойство IsAsync
Свойство `IsAsync` класса `Binding` в WPF используется для указания, следует ли получать и задавать значения привязки асинхронно. Это означает, что если `IsAsync` установлено в `true`, привязка будет выполняться в асинхронном режиме, что может быть полезно для предотвращения блокировки интерфейса пользователя при работе с медленными операциями, такими как загрузка данных из внешних источников.

Однако, стоит отметить, что использование `IsAsync` может не всегда быть самым эффективным или правильным решением для всех сценариев. Например, если источник данных доступен быстро, использование асинхронной привязки может не дать заметных преимуществ и может даже привести к дополнительной сложности.

Пример использования `IsAsync` в XAML:
```xml
<Run Text="{Binding Source={StaticResource nexusPhone}, Path=Discount, IsAsync=True}" />
```

В коде-behind это можно установить так:
```cs
var binding = new Binding("Discount") { IsAsync = true };
```

Несмотря на то, что `IsAsync` может быть полезен в определенных ситуациях, его применение должно быть тщательно обосновано, чтобы избежать ненужной сложности и потенциальных проблем с синхронизацией данных.

Кроме того, стоит отметить, что для более сложных асинхронных операций, таких как загрузка данных из внешних источников, могут быть более подходящими другие механизмы, такие как использование `ObjectDataProvider` с `IsAsynchronous=true` или реализация асинхронных команд в MVVM-паттерне.

#### Свойство DataContext
У объекта `FrameworkElement`, от которого наследуются элементы управления, есть интересное свойство `DataContext`. Оно позволяет задавать для элемента и вложенных в него элементов некоторый контекст данных. Тогда вложенные элементы могут использовать объект `Binding` для привязки к конкретным свойствам этого контекста. Например, используем ранее определенный класс `Phone` и создадим контекст данных из объекта этого класса:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black" DataContext="{StaticResource nexusPhone}" TextBlock.Foreground="White">
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <TextBlock Text="Модель" />
        <TextBlock Text="{Binding Title}" Grid.Row="1" />
        <TextBlock Text="Производитель" Grid.Column="1"/>
        <TextBlock Text="{Binding Company}" Grid.Column="1" Grid.Row="1" />
        <TextBlock Text="Цена" Grid.Column="2" />
        <TextBlock Text="{Binding Price}" Grid.Column="2" Grid.Row="1" />
    </Grid>
</Window>
```

![Picture 10.4](./img/67d423945040133e8429f1a8-10.4.png)

Таким образом мы задаем свойству `DataContext` некоторый динамический или статический ресурс. Затем осуществляем привязку к этому ресурсу.

### Привязка элементов

#### Связывание элементов
Простейший сценарий привязки данных подразумевает ситуацию, когда исходным объектом является элемент WPF, а исходным свойством — свойство зависимости. Причина в том, что свойство зависимости имеет встроенную поддержку уведомлений об изменениях. В результате, когда значение свойства зависимости изменяется в исходном объекте, привязанное свойство целевого объекта немедленно обновляется. Это именно то, что требуется, и происходит оно без необходимости построения любой дополнительной инфраструктуры.

Хотя привязка элемента к элементу является простейшим подходом, большинство разработчиков заинтересовано в нахождении самого общего подхода для реальных приложений. В общем, большая часть работы по привязке данных будет тратиться на привязку элементов к объектам данных. Это позволит отображать информацию, извлекаемую из внешнего источника (такого как база данных или файл). Однако привязка элемента к элементу также часто бывает полезной.

Например, ее можно использовать для автоматизации способа, которым элементы взаимодействуют, так что когда пользователь модифицирует один элемент управления, другой элемент обновляется автоматически. Это ценное сокращение, которое избавляет от написания громоздкого и рутинного кода (и это прием, не доступный в предыдущем поколении приложений Windows Forms).

Рассмотрим пример приложения из двух элементов управления: ползунка (`Slider`) и текстового блока (`TextBlock`). При изменении положения ползунка размер шрифта текстового блока должен меняться. Такое поведение можно реализовать за счет обработки события изменения положения ползунка `ValueChaned`:
```xml
<Slider Minimum="8" Maximum="30" ValueChanged="Slider_ValueChanged"></Slider>
<TextBlock x:Name="Message" FontSize="20">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

```cs
private void Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
{
    if (Message != null)
        Message.FontSize = ((Slider)sender).Value;
}
```

Как видно из исходного кода, возникает необходимость проверки существования объекта `Message`, т.к. первый вызов обработчика `Slider_ValueChanged` происходит в момент обработки элемента `Slider` XAML-файла, когда элемент `TextBlock` еще не обработан и, соответственно, объект `Message` еще не создан. Второй проблемой является несоответствие начального значения ползунка и начального размера шрифта.

Для решения поставленной задачи можно задействовать связывание элементов управления WPF. Для использования привязки данных необходимо  указать в качестве значения свойства `FontSize` текстового блока следующее выражение привязки:
```cs
{Binding ElementName=SliderFontSize, Path=Value}`
```

Выражение привязки данных задается в виде расширения разметки XAML в фигурных скобках.

Составляющие выражения привязки:
- **`Binding`** – означает, что будет создан объект класса `System.Windows.Data.Binding`
- **`ElementName`** – имя исходного объекта,
- **`Path`** – имя свойства (или путь до свойства) исходного объекта. Пример пути до свойства: `Background.Opacity`

```xml
<Slider Minimum="8" Maximum="30" x:Name="SliderFontSize"></Slider>
<TextBlock x:Name="Message" FontSize="{Binding ElementName=SliderFontSize, Path=Value}">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

В данном примере отсутствуют проблемы, обнаруженные в предыдущем примере. Начальные значения связанных свойств будут согласованы даже в том случае, если элемент `TextBlock` будет предшествовать элементу `Slider`.

Чтобы понять, как привязывать один элемент к другому, рассмотрим простое окно. Оно содержит два элемента управления: `Slider` (ползунок) и `TextBlock` (текстовый блок) с единственной строкой текста. Перемещение ползунка вправо приводит к немедленному увеличению размера шрифта текста, а перемещение влево — к уменьшению размера шрифта.

*XAML*:
```xml
<Slider Margin="5" Minimum="1" Maximum="72" Value="12" Name="sld"
                TickFrequency="5" TickPlacement="BottomRight"></Slider>
<TextBlock Margin="5" Text="Какой-то текст"
            FontSize="{Binding ElementName=sld, Path=Value}"></TextBlock>
```

Привязка определена в элементе `TextBlock`. Вместо установки `FontSize` с использованием литерального значения применяется выражение привязки.

Выражения привязки данных используют расширение разметки XAML (и потому помещаются в фигурные скобки). В начале идет слово `Binding`, потому что создается экземпляр класса **`System.Windows.Data.Binding`**. Хотя объект `Binding` может быть сконфигурирован различными способами, в данной ситуации необходимо установить только два свойства: `ElementName`, которое указывает исходный элемент, и `Path`, указывающее свойство в исходном элементе.

Вместо `Property` используется `Path`, потому что `Path` может указывать на свойство свойства (например, `FontFamily.Source`) или индексатор, используемый свойством (например, `Content.Children[0]`). Путь может включать множество фрагментов, переходящих от свойства к свойству, и т.д.

Чтобы сослаться на присоединенное свойство (свойство, которое определено в другом классе, но применяется к привязанному элементу), имя свойства должно быть указано в круглых скобках. Например, в случае привязки к элементу, помещенному в `Grid`, путь `(Grid.Row)` извлекает номер строки, в которой он находится.

##### Ошибки привязки
WPF не генерирует исключения для уведомления о проблемах привязки данных. Если указан несуществующий элемент или свойство, никакого сообщения об этом не будет; вместо этого данные просто не попадут в целевое свойство. На первый взгляд это может показаться кошмаром для отладки. К счастью, WPF выводит трассировочную информацию, которая детализирует сбои в привязке. Во время отладки приложения эта информация появляется в выходном окне Visual Studio.

Например, попытка привязки к несуществующему свойству приводит к выводу в выходное окно следующего сообщения:
```
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.App"
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.InitializeComponent"
System.Windows.Data Error: 40 : BindingExpression path error:
'SliderValue' property not found on 'object' ''Slider' (Name='sld')'
.BindingExpression:Path=SliderValue; DataItem='Slider' (Name='sld'); target element
is 'TextBlock' (Name=''); target property is 'FontSize' (type 'Double')
```

Среда WPF также игнорирует любые исключения, которые генерируются при попытке читать исходное свойство, и молча поглощает исключение, возникающее, если исходные данные не могут быть приведены к типу данных целевого свойства. Однако есть и другой способ справиться с этой проблемой — можно сообщить WPF о необходимости изменения внешнего вида исходного элемента для индикации возникшей ошибки. Например, неверный ввод можно пометить значком с восклицательным знаком или рамкой красного цвета.

#### Режимы привязки
Одной из ценных особенностей привязки данных является то, что цель обновляется автоматически, независимо от того, как модифицируется источник. В примере из предыдущей статьи источник может быть модифицирован только в одном направлении — через взаимодействие пользователя с ползунком. Однако рассмотрим несколько усложненную версию этого примера, в которой добавляется кнопка, при щелчке на которой изменяется положение ползунка:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    sld.Value += 5;
}
```

Этот код перемещает значение ползунка на 5 единиц, который, в свою очередь, изменяет размер шрифта текста через привязку данных. Это то же самое, как если бы вы двигали ползунок вручную. В этом и заключается основная сила привязки элементов.

Интересно, что существует способ заставить данные перемещаться в обоих направлениях: от источника к цели и от цели к источнику. Трюк заключается в установке свойства **`Mode`** объекта `Binding`. Ниже приведена усовершенствованная двунаправленная привязка, которая позволяет применять значения либо к источнику, либо к цели, и заставит противоположную часть привязки обновлять себя автоматически:
```xml
<TextBlock Margin="5" Text="Какой-то текст"
      FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBlock>
```

В рассматриваемом примере нет причин применять двунаправленную привязку (которая требует больше накладных расходов), поскольку эту проблему можно решить с помощью кода. Однако рассмотрим вариант этого примера, включающий текстовое поле, в котором пользователь может точно устанавливать размер шрифта. Этому текстовому полю понадобится двунаправленная привязка, чтобы оно могло как применять пользовательские изменения, так и отражать последнее значение размера, когда оно изменяется другим путем.

При установке свойства `Binding.Mode` можно использовать одно из пяти значений перечисления `System.Windows.Data.BindingMode`. Ниже приведен их полный список:

- **`OneWay`**

    Целевое свойство обновляется при изменениях исходного свойства

- **`TwoWay`**

    Целевое свойство обновляется при изменениях исходного свойства, а исходное свойство обновляется при изменении целевого свойства

- **`OneTime`**

    Целевое свойство устанавливается изначально на основе значения исходного свойства. Однако с этого момента изменения игнорируются (если только привязка не устанавливается на совершенно другой объект или не вызывается `BindingExpression.UpdateTarget()`). Обычно этот режим используется для сокращения накладных расходов, если известно, что целевое свойство не изменится

- **`OneWayToSource`**

    Подобно `OneWay`, но действует в обратном направлении. Исходное свойство обновляется, когда изменяется целевое свойство (что может показаться несколько странным), но целевое свойство никогда не обновляется

- **`Default`**

    Этот тип привязки зависит от целевого свойства. Это либо `TwoWay` (для устанавливаемых пользователем свойств, таких как `TextBox.Text`), либо `OneWay` (для всего остального). Все привязки используют данный подход, если только не указано иное

Вы уже видели `OneWay` и `TwoWay`. Значение `OneTime` достаточно очевидно. Оставшиеся два варианта требуют ряда дополнительных исследований.

Может возникнуть вопрос: зачем нужны две опции — и `OneWay`, и `OneWayToSource`? В конце концов, оба значения создают однонаправленную привязку, которая работает одинаковым образом. Единственное отличие в том, куда помещено выражение привязки. По сути, `OneWayToSource` позволяет поменять местами источник и цель, поместив выражение в то, что обычно считается источником привязки.

Наиболее общая причина использования этого трюка состоит в установке свойства, которое не является свойством зависимости. Как упоминалось, выражения привязки могут применяться только для установки свойств зависимости. Однако с помощью `OneWayToSource` это ограничение можно обойти, предоставляя в качестве свойства, поставляющего значение, свойство зависимости.

Изначально кажется логичным предположить, что все привязки однонаправленные, если только явно не указано иное. (В конце концов, именно так работает простой пример с ползунком.) Но на самом деле это не так. Чтобы убедиться в этом, вернемся к примеру с привязанным текстовым полем и позволим редактировать текущий размер шрифта. Если убрать установку `Mode=TwoWay`, этот пример все равно будет работать точно также. Причина в том, что WPF использует разные значения `Mode` по умолчанию, в зависимости от привязываемого свойства. (Формально в каждом свойстве зависимости присутствует фрагмент метаданных — флаг `FrameworkPropertyMetadata.BindsTwoWayByDefault`, который указывает, какую привязку должно использовать свойство: однонаправленную или двунаправленную).

Часто значение по умолчанию — именно то, что и нужно. Тем не менее, можно представить пример с текстовым полем только для чтения, которое пользователь не может изменять. В этом случае удается слегка сократить накладные расходы, установив режим однонаправленной привязки.

В качестве общего эмпирического правила: всегда неплохо явно устанавливать режим. Даже в случае текстового поля стоит подчеркнуть, что нужна двунаправленная привязка, включив свойство `Mode`.

#### Создание привязки в коде
При построении окна обычно наиболее эффективно объявлять выражение привязки в разметке XAML с помощью расширения разметки `Binding`. Тем не менее, допускается также создавать привязку и в коде.

Вот как можно создать привязку для элемента `TextBlock`, показанного в примере из предыдущей статьи:
```cs
Binding bind = new Binding();
bind.Source = sld;
bind.Path = new PropertyPath("Value");
bind.Mode = BindingMode.TwoWay;
txb.SetBinding(TextBlock.FontSizeProperty, bind);
```

Для удаления привязки в коде предусмотрены два статических метода класса **`BindingOperations`**. Метод `ClearBinding()` принимает ссылку на свойство зависимости, которое имеет привязку, подлежащую удалению, а метод `ClearAllBindings()` удаляет все привязки данных элемента:
```cs
BindingOperations.ClearAllBindings(txb);
```

И `ClearBinding()`, и `ClearAllBindings()` используют метод `ClearValue()`, который каждый элемент наследует от базового класса `DependencyObject`. Метод `ClearValue()` просто удаляет локальное значение свойства (которым в данном случае является выражение привязки).

Привязка на основе разметки применяется намного чаще, чем программная привязка, потому что она яснее и требует меньше работы. Однако код может применяться для создания привязки в некоторых специализированных сценариях:

- **Создание динамических привязок**

    Если необходимо тонко настраивать привязку на основе другой информации времени выполнения или создавать разные привязки в зависимости от обстоятельств, имеет смысл делать это в коде. (В качестве альтернативы можно было бы определить все необходимые привязки в коллекции `Resources` окна и просто добавить код, который вызывает `SetBinding()` с соответствующим объектом привязки.)

- **Удаление привязки**

    Чтобы удалить привязку и получить возможность установки свойства обычным образом, понадобится помощь метода `ClearBinding()` или `ClearAllBindings()`. Недостаточно просто присвоить новое значение свойству. В случае использования двунаправленной привязки установленное значение распространится на привязанный объект, и оба свойства останутся синхронизированными.

    С помощью методов `ClearBinding()` и `ClearAllBindings()` можно удалить любую привязку. Не имеет значения, применялась привязка программно или в коде XAML.

- **Создание специальных элементов управления**

    Чтобы облегчить для других модификацию визуального представления специального элемента управления, который разрабатывается, определенные детали (такие как обработчики событий и выражения привязки данных) понадобится перенести в код разметки.

#### Множественные привязки
В WPF в одном элементе управления разрешается использовать сколько угодно привязок. Можно модифицировать пример из предыдущей статьи, добавив к элементу `TextBlock` еще несколько привязок:
```xml
<StackPanel>
            <Slider Name="sld" Minimum="1" Maximum="72" Margin="10"
                TickFrequency="5" TickPlacement="BottomRight" Value="12"></Slider>
            <TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"></TextBox>
            <ListBox Margin="10" Name="lst">
                <ListBoxItem Tag="DarkBlue">
                    <Label>Dark Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="Blue">
                    <Label>Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="LightBlue">
                    <Label>Light Blue</Label>
                </ListBoxItem>
            </ListBox>
            <!-- Используем несколько привязок -->
            <TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Text="{Binding ElementName=txt, Path=Text}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}"></TextBlock>
</StackPanel>
```

Допускается также реализовать привязку данных. Например, можно создать выражение привязки для свойства `TextBox.Text`, связывающее его со свойством `TextBlock.FontSize`, которое содержит выражение привязки, связывающее со свойством `Slider.Value`. В этом случае, когда пользователь перетаскивает ползунок в новую позицию, значение передается от `Slider` в `TextBlock` и затем из `TextBlock` в `TextBox`.

Хотя все работает прозрачно, более ясный подход состоит в том, чтобы привязать элементы как можно ближе к данным, которые они используют. В описанном здесь примере необходимо предусмотреть привязку и `TextBlock`, и `TextBox` непосредственно к свойству `Slider.Value`.

Все становится немного более интересно, когда на целевое свойство должны оказывать влияние более одного источника, например, если нужно иметь две равноправные привязки, устанавливающие одно и то же свойство. На первый взгляд это кажется невозможным. Однако существует несколько способов решения.

Простейший подход состоит в изменении режима привязки данных. Как уже известно, свойство `Mode` позволяет модифицировать способ работы привязки так, что данные передаются не только от источника к цели, но и от цели к источнику. С помощью такого приема можно создать несколько выражений привязки, устанавливающих одно и то же свойство. Последнее из них будет иметь эффект.

Чтобы понять, как это работает, рассмотрим вариацию примера элемента — панели с ползунком, который включает текстовое поле, куда можно поместить точное значение размера шрифта. В этом примере свойство `TextBlock.FontSize` может быть установлено двумя путями: перетаскиванием ползунка или вводом в текстовом поле размера шрифта. Все элементы управления синхронизированы так, что если вводится новое число в текстовом поле, размер шрифта текста примера изменяется и ползунок перемещается в соответствующую позицию.

Как уже упоминалось, к свойству `TextBlock.FontSize` можно применять только одну привязку данных. Поэтому имеет смысл оставить свойство `TextBlock.FontSize` в том виде, как оно есть, чтобы оно привязывалось прямо к ползунку.

Хотя добавить другую привязку к свойству `FontSize` нельзя, можно привязать новый элемент управления `TextBox` к свойству `TextBlock.FontSize`. Ниже показана необходимая для этого разметка:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        Text="{Binding ElementName=txb, Path=FontSize, Mode=TwoWay}"></TextBox>
```

Теперь при каждом изменении свойства `TextBlock.FontSize` текущее значение будет вставляться в текстовое поле. Более того, значение в текстовом поле можно редактировать, применяя указанный размер шрифта. Обратите внимание, что для того, чтобы пример работал, свойство `TextBox.Text` должно использовать двунаправленную привязку, передающую данные в обоих направлениях. В противном случае текстовое поле сможет отображать значение `TextBlock.FontSize`, но не позволит изменять его.

С этим примером связано несколько нюансов:

- Поскольку значение свойства `Slider.Value` имеет тип `double`, при перетаскивании ползунка получается дробное значение размера. Установив свойство `TickFrequency` в 1 (или в некоторый целочисленный интервал), a свойство `IsSnapToTickEnabled` в `true`, можно ограничить значение ползунка только целыми величинами.

- Текстовое поле позволяет вводить буквы и другие нечисловые символы. В таком случае значение текстового поля не сможет быть интерпретировано как число. В результате привязка данных молча потерпит неудачу, а значение размера шрифта станет равно 0. Другой подход мог бы состоять в обработке нажатий клавиш в текстовом поле, чтобы вообще предотвратить неправильный ввод, либо в использовании проверки достоверности.

- Изменения, которые вносятся в текстовое поле, не будут применены до тех пор, пока текстовое поле не потеряет фокус (например, когда с помощью клавиши `<Tab>` происходит переход на другой элемент управления). Если такое поведение не подходит, можно обеспечить непрерывное обновление, используя свойство `UpdateSourceTrigger` объекта `Binding`.

Интересно, что показанное здесь решение — не единственный способ привязки текстового поля. Столь же разумно конфигурировать текстовое поле таким образом, чтобы оно изменяло значение свойства `Slider.Value` вместо свойства `TextBlock.FontSize`:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBox>
```

Теперь изменение текстового поля инициирует изменение положения ползунка, которое затем установит новый размер шрифта текста. Опять-таки, данный подход работает только с двунаправленной привязкой данных.

И, наконец, можно поменять местами роли ползунка и текстового поля, чтобы ползунок привязывался к текстовому полю.

В случае привязки `Slider.Value` текстовое поле ведет себя несколько иначе, чем в предыдущих двух примерах. Любые изменения, которые вносятся в текстовое поле, применяются немедленно, вместо того, чтобы ожидать момента утери фокуса.

Как видно из примера, двунаправленные привязки обеспечивает значительную гибкость. Их можно использовать для применения изменений от источника к цели и от цели к источнику. Допускается их применение в комбинации, что позволяет создать неожиданно сложные окна без какого-либо кода.

Обычно решение относительно того, куда применять выражение привязки, диктуется логикой модели кодирования. В предыдущем примере, возможно, было бы больше смысла поместить привязку в свойство `TextBox.Text` вместо свойства `Slider.Value`, потому что текстовое поле — это необязательное дополнение к вполне готовому примеру, а не основной ингредиент, на который полагается ползунок.

Также имело бы больше смысла привязать текстовое поле непосредственно к свойству `TextBlock.FontSize` вместо свойства `Slider.Value`. (Концептуально вы заинтересованы в том, чтобы видеть текущий размер шрифта, и ползунок — только один из способов его установки. Даже несмотря на то, что положение ползунка совпадает с размером шрифта, это — необязательная дополнительная деталь, если вы пытаетесь написать максимально ясную разметку.) Конечно, эти решения субъективны и определяются стилем кодирования. Наиболее важный урок состоит в том, что три подхода могут обеспечить одинаковое поведение.

В следующих статьях мы рассмотрим две детали, касающиеся этого примера. Во-первых, речь пойдет о возможных выборах при установке направления привязки. Во-вторых, будет показано, каким образом точно указать WPF, когда имеет смысл обновлять исходное свойство при двунаправленной привязке.

#### Обновление привязок
В примере из предыдущей статьи (где `TextBox.Text` привязывается к `TextBlock.FontSize`) имеется еще один нюанс. При попытке изменить отображаемый размер шрифта, вводя значение в текстовое поле, ничего не происходит. Изменение не применяется до тех пор, пока не будет совершен переход на другой элемент. Это поведение отличается от поведения, которое демонстрировалось в примере с ползунком. Там новый размер шрифта применялся после перетаскивания ползунка в другую позицию, т.е. в переходе на другой элемент вообще не было необходимости.

Чтобы понять это различие, следует повнимательнее присмотреться к выражениям привязки, которые используются этими двумя элементами управления. Когда применяется привязка `OneWay` или `TwoWay`, измененное значение распространяется от источника к цели немедленно. В случае с ползунком есть однонаправленное выражение привязки в `TextBlock`. Таким образом, изменения в свойстве `Slider.Value` немедленно отражаются в свойстве `TextBlock.FontSize`. То же поведение имеет место в примере с текстовым полем: изменения в источнике (которым является `TextBlock.FontSize`) немедленно влияют на цель (`TextBox.Text`).

Однако изменения, протекающие в обратном направлении — от цели к источнику — не обязательно происходят немедленно. Вместо этого их поведение управляется свойством **`Binding.UpdateSourceTrigger`**, которое принимает одно из значений, описанных ниже. Когда текст берется из текстового поля и используется для обновления свойства `TextBlock.FontSize`, это пример обновления цель-источник, которое использует поведение `UpdateSourceTrigger.LostFocus`.

- **`PropertyChanged`**

    Источник обновляется немедленно, когда изменяется целевое свойство

- **`LostFocus`**

    Источник обновляется немедленно, когда изменяется целевое свойство и цель теряет фокус

- **`Explicit`**

    Источник не обновляется, пока не будет вызван метод `BindingExpression.UpdateSource()`

- **`Default`**

    Поведение обновления определяется метаданными целевого свойства (формально — его свойства `FrameworkPropertyMetadata.DefaultUpdateSourceTrigger`). Для большинства свойств поведением по умолчанию будет `PropertyChanged`, хотя свойство `TextBox.Text` обладает поведением по умолчанию `LostFocus`

Помните, что эти значения не оказывают эффекта на обновление цели. Они просто управляют тем, как обновляется источник в привязках `TwoWay` и `OneWayToSource`.

Вооружившись этим знанием, можно усовершенствовать пример с текстовым полем, чтобы изменения применялись к размеру шрифта по мере их ввода в текстовое поле:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
       Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

Поведением по умолчанию свойства `TextBox.Text` является `LostFocus` просто потому, что текст в текстовом поле будет изменяться непрерывно в процессе пользовательского ввода, вызывая множественные обновления. В зависимости от того, как исходный элемент управления обновляет себя, режим обновления `PropertyChanged` может сделать приложение более медлительным. Вдобавок это может заставить исходный объект обновлять себя до завершения редактирования, что создаст проблемы при проверке достоверности.

Для полного контроля над моментом обновления исходного объекта можно выбрать режим `UpdateSourceTrigger.Explicit`. Если воспользоваться этим подходом в примере с текстовым полем, то когда текстовое поле утратит фокус, ничего не произойдет.

Вместо этого код должен будет вручную инициировать обновление. Например, можно было бы добавить кнопку Add (Добавить), которая вызовет метод **`BindingExpression.UpdateSource()`**, инициируя немедленное обновление размера шрифта. Разумеется, прежде чем можно будет вызвать метод `BindingExpression.UpdateSource()`, нужен способ получения объекта `BindingExpression`. Объект `BindingExpression` — это тонкая упаковка, которая содержит в себе две вещи: уже известный объект `Binding` (предоставленный через свойство `BindingExpression.ParentBinding`) и объект, привязанный от источника (`BindingExpression.DataItem`).

Вдобавок объект `BindingExpression` предоставляет два метода для запуска немедленного обновления одной части привязки: `UpdateSource()` и `UpdateTarget()`.

Для получения объекта `BindingExpression` используется метод `GetBindingExpression()`, унаследованный каждым элементом от базового класса `FrameworkElement`, которому передается целевое свойство, имеющее привязку.

#### Привязка к объектам
[67ef67e35040133e8429f2e5](https://professorweb.ru/my/WPF/binding_and_styles_WPF/level8/8_6.php)

До сих пор добавлялись привязки, которые устанавливали связь между двумя элементами. Однако в приложениях, управляемых данными, чаще создаются выражения привязки, которые извлекают данные из невизуальных объектов. Единственное требование, которое должно при этом соблюдаться — информация, которую необходимо отобразить, должны храниться в *общедоступных свойствах*. Инфраструктура привязки данных WPF не может извлекать приватную информацию или читать общедоступные поля.

При привязке к объекту, не являющемуся элементом, следует отказаться от свойства `Binding.ElementName` и применять вместо него одно из следующих свойств:

- **`Source`**

    Ссылка, указывающая на исходный объект; другими словами, это объект, поставляющий данные.

- **`RelativeSource`**

    Указывает на исходный объект, использующий объект `RelativeSource`, который позволяет базировать ссылку на текущем элементе. Это специализированный инструмент, который удобен при написании шаблонов элементов управления и шаблонов данных.

- **`DataContext`**

    Если источник не был указан с помощью свойства `Source` или `RelativeSource`, то среда WPF производит поиск в дереве элементов, начиная с текущего элемента. Она проверяет свойство `DataContext` каждого элемента и использует первый из них, который не равен `null`. Свойство `DataContext` исключительно полезно, когда нужно привязать несколько свойств одного объекта к разным элементам, потому что можно установить свойство `DataContext` высокоуровневого объекта контейнера, вместо его установки непосредственно на целевой элемент.

Ниже эти варианты описаны более подробно.

##### Свойство Source
Свойство `Source` достаточно прямолинейно. Единственный момент, который следует учитывать — объект данных должен быть сделан удобным для привязки. Как будет показано, для получения объекта данных существует несколько подходов: извлечь его из ресурса, генерировать программно или получить от поставщика данных.

Простейший вариант — установить `Source` в некоторый готовый и доступный статический объект. Например, можно создать статический объект в коде и использовать его. Или же можно применить ингредиент из библиотеки классов .NET, как показано ниже:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        FontFamily="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"
        Text="Текст"></TextBox>
```

Это выражение привязки получает объект `FontFamily`, который предоставлен свойством `SystemFonts.IconFontFamily`. (Обратите внимание, что для установки свойства `Binding.Source` понадобится помощь расширения разметки `Static`.) Затем свойство `Binding.Path` устанавливается в свойство `FontFamily.Source`, которое выдает имя семейства шрифтов. Результатом будет единственная строка текста. В Windows Vista или Windows 7 имя шрифта выглядит как Segoe UI.

Другой вариант состоит в привязке к объекту, который ранее создавался в виде ресурса. Например, следующая разметка создает объект `FontFamily`, указывающий на шрифт `Calibri`:
```xml
<Window.Resources>
        <FontFamily x:Key="CustomFont">Calibri</FontFamily>
</Window.Resources>
    ...
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           FontFamily="{Binding Source={StaticResource CustomFont}, Path=Source}"
           Text="Текст"></TextBox>
```

##### Свойство RelativeSource
Свойство `RelativeSource` позволяет установить его в исходный объект на основе его отношения к целевому объекту. Например, свойством `RelativeSource` можно воспользоваться для привязки элемента к самому себе или для привязки к родительскому элементу, который находится в неизвестном количестве уровней выше в дереве элементов.

Для установки свойства `Binding.RelativeSource` применяется объект `RelativeSource`. Это несколько усложняет синтаксис, поскольку нужно создать объект `Binding` и внутри него — вложенный объект `RelativeSource`. Один вариант состоит в использовании синтаксиса установки свойства вместо расширения разметки `Binding`.

Например, в следующем коде создается объект `Binding` для свойства `TextBlock.Text`. Объект `Binding` использует `RelativeSource`, которое ищет родительское окно и отображает заголовок окна:
```xml
<TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}">
           <TextBlock.Text>
                    <Binding Path="Title">
                        <Binding.RelativeSource>
                            <RelativeSource Mode="FindAncestor" AncestorType="{x:Type Window}"></RelativeSource>
                        </Binding.RelativeSource>
                    </Binding>
           </TextBlock.Text>
</TextBlock>
```

Для объекта `RelativeSource` выбран режим `FindAncestor`, который заставляет его осуществлять поиск вверх по дереву элементов до тех пор, пока не будет найден тип элемента, определенный свойством `AncestorType`.

Наиболее общий способ записи этой привязки состоит в комбинировании ее в одну строку, используя расширения разметки `Binding` и `RelativeSource`, как показано ниже:
```xml
Text="{Binding Path=Title, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
```

Режим `FindAncestor` — один из четырех возможных вариантов при создании объекта `RelativeSource`. Все варианты кратко описаны ниже:

- **`Self`**

    Выражение привязывается к другому свойству того же элемента

- **`FindAncestor`**

    Выражение привязывается к родительскому элементу. WPF будет проводить поиск вверх по дереву элементов, пока не найдет нужный родительский элемент. Чтобы указать родителя, необходимо также установить свойство `AncestorType` для индикации типа родительского элемента, который должен быть найден. Дополнительно с помощью свойства `AncestorLevel` можно пропустить определенное количество совпадений указанного элемента. Например, если требуется привязка к третьему элементу типа `ListBoxItem` при восхождении вверх по дереву, то следует установить `AncestorType={x:Type ListBoxItem}` и `AncestorLevel=3`, тем самым пропуская первые два `ListBoxItem`. По умолчанию `AncestorLevel` равен 1, и поиск прекращается на первом найденном элементе.

- **`PreviousData`**

    Выражение осуществляет привязку к предыдущему элементу данных в списке, привязанном к данным. Это можно использовать в элементе списка

- **`TemplatedParent`**

    Выражение осуществляет привязку к элементу, к которому применен шаблон. Этот режим работает, только если привязка находится внутри шаблона элемента управления или шаблона данных

На первый взгляд свойство `RelativeSource` может показаться излишним усложнением разметки. В конце концов, почему бы просто не привязаться непосредственно к необходимому источнику, используя свойство `Source` или `ElementName`? Однако, это не всегда возможно, и обычно потому, что объект-источник и целевой объект находятся в разных частях разметки. Так получается при создании шаблонов элементов управления и шаблонов данных. Например, при построении шаблона данных, который изменяет способ представления элементов в списке, может понадобиться доступ к объекту `ListBox` верхнего уровня, чтобы прочитать какое-то его свойство.

##### Свойство DataContext
В некоторых случаях имеется множество элементов, привязанных к одному объекту. Например, рассмотрим следующую группу элементов `TextBlock`, каждый из которых использует исходное выражение привязки для извлечения различных деталей о шрифте, значков по умолчанию, включая промежутки между строками, стиль и вес первой гарнитуры (то и другое — просто Regular). Можете воспользоваться свойством `Source` для каждого из них, но это приводит к довольно длинной разметке:
```xml
<StackPanel Margin="10">
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=LineSpacing}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Weight}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Style}"></TextBlock>
</StackPanel>
```

В такой ситуации было бы яснее и удобнее определить источник привязки один раз с помощью свойства `FrameworkElement.DataContext`. В данном примере имеет смысл установить свойство `DataContext` элемента `StackPanel`, содержащего в себе все элементы `TextBlock`. (Можно было бы также установить свойство `DataContext` на еще более высоком уровне, например, на уровне всего окна, но лучше определить его насколько возможно уже, чтобы яснее выразить намерения.)

Установить свойство `DataContext` элемента можно таким же образом, как устанавливается свойство `Binding.Source`. Другими словами, можно встроить объект, извлечь его из статического свойства либо получить из ресурса, как показано ниже:
```xml
<StackPanel DataContext="{х:Static SystemFonts.IconFontFamily}">
```

После этого выражения привязки упрощаются за счет исключения некоторой информации об источнике:
```xml
<TextBlock Margin="5" Text="{Binding Path=Source}"></TextBlock>
```

Когда информация об источнике отсутствует в выражении привязки, WPF проверяет свойство `DataContext` элемента. Если оно равно `null`, WPF ищет в дереве элементов первый контекст данных, отличный от `null`. (Изначально свойства `DataContext` всех элементов равны `null`.) Если подходящий контекст данных обнаружен, то он используется для привязки. Если же нет, то выражение привязки не передает никакого значения целевому свойству.

### Привязка данных
<dfn title="привязка данных">Привязка данных</dfn> (data binding) в графической системе WPF представляет собою отношение, которое сообщает WPF о необходимости извлечения данных из свойства исходного объекта (Source) и использования её для задания значения некоторого свойства целевого объекта (Target) (и, в некоторых случаях, наоборот).

Объектом-источником может быть как элемент WPF, так и объект ADO.NET или пользовательский объект, хранящий данные.

#### Режимы привязки
В выражении привязки с помощью параметра `Mode` можно задать одно из следующих пяти значений режима привязки:
1) `OneWay` – целевое свойство обновляется при изменении исходного свойства.

2) `OneTime` – первоначально значение исходного свойства копируется в целевое свойство, но дальнейшие изменения исходного свойства не учитываются.

3) `TwoWay` — целевое свойство обновляется при изменении исходного свойства, исходное свойство обновляется при изменении целевое свойства.

4) `OneWayToSource` – исходное свойство обновляется при изменении целевое свойства.

5) `Default` – значение по умолчанию. Если целевое свойство устанавливается пользователем (например, `TextBox.Text`, `Slider.Value`, `CheckBox.IsChecked`, …), то это `TwoWay`, в остальных случаях – это `OneWay`.

Пример выражения привязки с параметром Mode: `{Binding ElementName=slider1, Path=Value, Mode=OneTime}`.

#### Особенности
Свойство `EditingMode` (тип данных `InkCanvasEditingMode`) элемента управления `InkCanvas` нельзя напрямую связать с текстовым свойством выпадающего списка `ComboBox` или списка `ListBox`, т.к. в этом случае будет несовпадение типов. Для привязки данных необходимо, чтобы тип элементов списка совпадал с типом свойства `EditingMode`. Для этой цели необходимо добавить в  ресурсы окна приложения (элемент `Windows.Resources`) массив (элемент `x:Array`) элементов типа `InkCanvasEditingMode` (атрибут `x:Type`), данному ресурсу необходимо задать ключ (атрибут `x:Key`), который необходимо указать в свойстве `ItemSource` списка `ListBox` или выпадающего списка `ComboBox`. В этом случае можно будет осуществить привязку данных между свойством `EditingMode` и выделенным элементом списка:
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyEditingModes" x:Type="{x:Type InkCanvasEditingMode}">
      <x:Static Member="InkCanvasEditingMode.Ink"/>
      <x:Static Member="InkCanvasEditingMode.Select"/>
      <x:Static Member="InkCanvasEditingMode.EraseByPoint"/>
      <x:Static Member="InkCanvasEditingMode.EraseByStroke"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas EditingMode="{Binding ElementName=lbEditingModes, Path=SelectedValue}" />
    <ListBox x:Name="lbEditingModes" ItemsSource="{StaticResource MyEditingModes}" />
  </StackPanel>
</Window>
```

Аналогичным образом можно задать привязку данных между свойством  `DefaultDrawingAttributes` и выделенным элементом списка (в данном случае массив  `x:Array` будет содержать элементы типа `DrawingAttributes`):
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyDrawingAttributes" x:Type="{x:Type DrawingAttributes}">
      <DrawingAttributes Color="Red" Width="3" Height="3"/>
      <DrawingAttributes Color="Green" Width="10" Height="10"/>
      <DrawingAttributes Color="Blue" Width="15" Height="15"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas DefaultDrawingAttributes="{Binding ElementName=lbColors, Path=SelectedValue}" />
    <ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}" />
  </StackPanel>
</Window>
```

Недостатком последнего примера является то, что все элементы в списке выводятся с текстом «System.Windows.Ink.DrawingAttributes». Для придания элементам списка осмысленного содержания, необходимо определить шаблон элементов (`ListBox.ItemTemplate`), в котором определить, каким образом элементы списка будут отображены на экране (например, в виде текстового блока, содержащего поле `Color`):
```xml
<ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Path=Color}"></TextBlock>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

#### Привязка к данным в отделенном коде
Чтобы привязать разметку к данным из CodeBehind в WPF, вы можете использовать несколько подходов:

1. **Привязка через `DataContext`**. Один из наиболее распространенных способов привязать данные к разметке — это использовать свойство `DataContext`. Вы можете задать `DataContext` для окна или любого другого элемента в CodeBehind и затем использовать привязку в XAML.

    C#:
    ```cs
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // Создание объекта с данными
            var data = new MyData { Name = "John", Age = 30 };

            // Установка DataContext
            DataContext = data;
        }
    }

    public class MyData
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    ```

    XAML:
    ```xml
    <Window x:Class="MyApp.MainWindow"
            xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            Title="MainWindow" Height="350" Width="525">
        <StackPanel>
            <TextBlock Text="{Binding Name}" />
            <TextBlock Text="{Binding Age}" />
        </StackPanel>
    </Window>
    ```

2. **Привязка с помощью объекта `Binding`**. Вы также можете создать привязку программно, используя объект `Binding`. Это может быть полезно, когда вам нужно динамически изменять привязку или когда вы не можете использовать XAML.

    C#:
    ```cs
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // Создание объекта с данными
            var data = new MyData { Name = "John", Age = 30 };

            // Создание привязки
            Binding binding = new Binding("Name");
            binding.Source = data;

            // Применение привязки
            txtName.SetBinding(TextBlock.TextProperty, binding);
        }
    }

    public class MyData
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    ```

    XAML:
    ```xml
    <Window x:Class="MyApp.MainWindow"
            xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            Title="MainWindow" Height="350" Width="525">
        <StackPanel>
            <TextBlock x:Name="txtName" />
        </StackPanel>
    </Window>
    ```

3. **Использование `INotifyPropertyChanged`**. Если ваши данные могут изменяться во время выполнения приложения, вы должны реализовать интерфейс `INotifyPropertyChanged`, чтобы уведомлять привязку об изменениях.

    C#:
    ```cs
    public class MyData : INotifyPropertyChanged
    {
        private string _name;

        public string Name
        {
            get { return _name; }
            set
            {
                _name = value;
                OnPropertyChanged("Name");
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
    ```

    Этот подход позволяет поддерживать актуальность данных в интерфейсе при их изменении.

### Интерфейс INotifyPropertyChanged
В прошлой теме использовался объект `Phone` для привязки к текстовым блокам. Однако если мы изменим его, содержимое текстовых блоков не изменится. Например, добавим в окно приложения кнопку:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black" DataContext="{StaticResource nexusPhone}" TextBlock.Foreground="White">
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <TextBlock Text="Модель" />
        <TextBlock Text="{Binding Title}" Grid.Row="1" />
        <TextBlock Text="Производитель" Grid.Column="1"/>
        <TextBlock Text="{Binding Company}" Grid.Column="1" Grid.Row="1" />
        <TextBlock Text="Цена" Grid.Column="2" />
        <TextBlock Text="{Binding Price}" Grid.Column="2" Grid.Row="1" />

        <Button Foreground="White" Content="Изменить" Click="Button_Click" Background="Black"
            BorderBrush="Silver" Grid.Column="2" Grid.Row="2" />
    </Grid>
</Window>
```

И в файле кода для этой кнопки определим обработчик, в котором будет меняться свойства ресурса:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    Phone phone = (Phone)this.Resources["nexusPhone"];
    phone.Company = "LG"; // Меняем с Google на LG
}
```

Сколько бы мы не нажимали на кнопку, текстовые блоки, привязанные к ресурсу, не изменятся. Чтобы объект мог полноценно реализовать механизм привязки, нам надо реализовать в его классе интерфейс `INotifyPropertyChanged`. И для этого изменим класс `Phone` следующим образом:
```cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

class Phone : INotifyPropertyChanged
{
    private string title;
    private string company;
    private int price;

    public string Title
    {
        get { return title; }
        set
        {
            title = value;
            OnPropertyChanged("Title");
        }
    }
    public string Company
    {
        get { return company; }
        set
        {
            company = value;
            OnPropertyChanged("Company");
        }
    }
    public int Price
    {
        get { return price; }
        set
        {
            price = value;
            OnPropertyChanged("Price");
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    public void OnPropertyChanged([CallerMemberName]string prop = "")
    {
        if (PropertyChanged != null)
            PropertyChanged(this, new PropertyChangedEventArgs(prop));
    }
}
```

Объяснение изменений:
1. **Реализация `INotifyPropertyChanged`**: Класс `Phone` теперь реализует интерфейс `INotifyPropertyChanged`, что позволяет ему уведомлять другие компоненты об изменениях свойств.

2. **Полные свойства**: Свойства теперь используют приватные поля для хранения значений. Это позволяет проверять, изменилось ли значение свойства перед вызовом `OnPropertyChanged`.

3. **Метод `OnPropertyChanged`**: Этот метод вызывается всякий раз, когда изменяется свойство. Он уведомляет всех подписчиков события `PropertyChanged` об изменении свойства.

4. **Событие `PropertyChanged`**: Это событие вызывается методом `OnPropertyChanged`. Оно позволяет другим компонентам подписываться на уведомления об изменениях свойств объекта `Phone`.

В этом примере когда объект класса изменяет значение свойства, то он через событие `PropertyChanged` извещает систему об изменении свойства. А система обновляет все привязанные объекты.

#### Дополнительные возможности
Добавление дополнительного кода в каждое свойство для реализации `INotifyPropertyChanged` является традиционным подходом, но это не единственный способ. Есть несколько альтернатив, которые позволяют избежать повторения кода:

1. **Использование аспектно-ориентированного программирования (AOP)**:

    Инструменты как PostSharp и Fody позволяют автоматически добавлять код для реализации `INotifyPropertyChanged` во время компиляции или выполнения. Это уменьшает количество кода, который нужно писать вручную.

2. **Использование атрибутов и генераторов кода**:

    Community Toolkit for .NET предлагает атрибуты, которые могут генерировать код для реализации `INotifyPropertyChanged`. Эти атрибуты позволяют автоматически добавлять необходимый код в классы.

3. **Объектно-ориентированное проектирование**:

    Можно создать классы, которые сами заботятся о генерации событий. Например, использовать классы-свойства, которые автоматически вызывают `OnPropertyChanged` при изменении значения.

4. **Использование сторонних библиотек и инструментов**:

    Инструменты как ReSharper или другие плагины для IDE могут автоматически генерировать код для `INotifyPropertyChanged`, что также уменьшает ручной труд.

Таким образом, хотя традиционный подход требует добавления кода в каждое свойство, существуют альтернативы, которые позволяют автоматизировать этот процесс и уменьшить количество повторяющегося кода.

#### Использование объектно-ориентированного проектирования
Третий подход к реализации `INotifyPropertyChanged` без добавления дополнительного кода в каждое свойство предполагает использование объектно-ориентированного проектирования. Этот подход заключается в создании базового класса или вспомогательного класса, который сам заботится о генерации событий `PropertyChanged`. Таким образом, вам не нужно писать повторяющийся код для каждого свойства в ваших классах.

Пример реализации:
1. **Базовый класс**: создайте базовый класс, который реализует `INotifyPropertyChanged`. Этот класс будет содержать методы для обновления свойств и вызова события `PropertyChanged`.

    ```cs
    public abstract class NotifyPropertyChangedBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (Equals(storage, value))
            {
                return false;
            }

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
    ```

2. **Использование базового класса**: теперь ваши классы могут наследовать этот базовый класс и использовать его методы для обновления свойств.

    ```cs
    public class Phone : NotifyPropertyChangedBase
    {
        private string _title;
        private string _brand;
        private decimal _price;
        private decimal? _discount;

        public string Title
        {
            get => _title;
            set => SetProperty(ref _title, value);
        }

        public string Brand
        {
            get => _brand;
            set => SetProperty(ref _brand, value);
        }

        public decimal Price
        {
            get => _price;
            set => SetProperty(ref _price, value);
        }

        public decimal? Discount
        {
            get => _discount;
            set => SetProperty(ref _discount, value);
        }
    }
    ```

Преимущества:
- **Меньше повторяющегося кода**: Вам не нужно писать код для вызова OnPropertyChanged в каждом свойстве.

- **Удобство поддержки**: Если вам нужно изменить логику обновления свойств, вы можете сделать это в одном месте — в базовом классе.

Этот подход позволяет избежать повторения кода и упрощает поддержку ваших классов.

### Форматирование привязанных данных

#### Преобразование данных
При обычной привязке информация путешествует от источника к цели без каких-либо изменений. Это кажется логичным, но такое поведение не всегда подходит. Часто источник данных может использовать низкоуровневое представление, которое не нужно отображать непосредственно в пользовательском интерфейсе.

Например, может понадобиться, чтобы числовые коды заменялись читабельными для человека строками, числа представлялись в укороченном виде, даты отображались в длинном формате и т.д. Если это так, то нужен какой-то способ преобразования этих значений в корректную отображаемую форму. И если применяется двунаправленная привязка, то также понадобится обратная операция — преобразование введенных пользователем данных в представление, подходящее для хранения в соответствующем объекте данных.

К счастью, в WPF доступны два средства, которые могут оказать помощь:

- **Форматирование строк**

    Это средство позволяет преобразовать данные, представленные в виде текста — например, строки, которые содержат даты и числа, — за счет установки свойства `Binding.StringFormat`. Это удобный прием, который справляется, по крайней мере, с половиной задач форматирования.

- **Конвертеры значений**

    Это намного более мощное (и в некотором отношении более сложное) средство, позволяющее преобразовывать любой тип исходных данных в любой тип представления объекта, который может быть передан связанному элементу управления.

Оба подхода рассматриваются в последующих разделах.

##### Свойство StringFormat
Форматирование строк — блестящий инструмент для форматирования чисел, которые нужно отобразить в виде текста. Например, возьмем свойство `Cost` из класса `CarTable`. `Cost` хранится как `double`, и в результате его отображения в текстовом поле можно наблюдать значение вроде 150000. Такой формат пропускает символ валюты и не слишком удобен для чтения. Интуитивно понятное представление должно выглядеть как $150.000 или 150.000 руб.

Простейшее решение состоит в установке свойства `Binding.StringFormat`. Для преобразования неформатированного текста в его отображаемое значение непосредственно перед его появлением в элементе управления WPF использует форматную строку. Не менее важно, что WPF в большинстве случаев применяет эту строку для обратного преобразования, взяв любые отредактированные данные и используя их для обновления привязанного свойства.

При установке свойства `Binding.StringFormat` применяются стандартные форматные строки .NET вида `{0:С}`. Здесь `0` представляет первое значение, а `С` ссылается на строку формата, которой в данном случае является стандартный, специфичный для локали формат валюты, который преобразует 3.99 в $3.99 на компьютере, находящемся в США.

Все выражение помещается в фигурные скобки. Ниже приведен пример применения форматной строки к полю `Cost`, чтобы его значение отображалось как денежное:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, StringFormat={}{0:C}}" ...
```

Значение `StringFormat` предварено еще одной парой фигурных скобок `{}`. Вместе получается `{}{0:С}`, а не просто `{0:С}`. Эта несколько неуклюжая конструкция необходима, чтобы защитить строку. В противном случае анализатор XAML может быть введен в заблуждение фигурной скобкой в начале `{0:С}`. Кстати, управляющая последовательность `{}` необходима, только когда значение `StringFormat` начинается со скобки.

Т.к. в базе данных стоимость хранится в рублях, а не в долларах давайте модифицируем выражение привязки:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, StringFormat={}{0} руб.}" ...
```

Однако эта форматная строка работает только в одном направлении. Если пользователь попытается применить отредактированное значение, включающее литеральный текст, обновление потерпит неудачу. С другой стороны, если пользователь выполнит редактирование, введя только числовое значение, то редактирование удастся, и выражение привязки преобразует его в отображаемый текст.

Чтобы получить нужный результат с помощью свойства `StringFormat`, понадобится правильная строка формата. Все доступные форматные строки можно найти в справочной системе Visual Studio. Ниже перечислены наиболее часто используемые опции, которые будут применять для числовых данных и дат соответственно.

*Строки формата для числовых данных*
Тип | Строка формата | Пример
-- | -- | --
Валюта | `C` | `$1,234.50`<br>Отрицательные значения представляются в скобках: `($1,234.50)`. Знак валюты специфичен для локали.
Научный (экспоненциальный) | `E` | `1.234.50Е+004`
Процентный | `P` | `45.6%`
Десятичный с фиксированной точкой | `F?` | Зависит от количества установленных десятичных разрядов. `F3` форматирует значения в виде `123.400`, a `F0` форматирует значения подобно `123`

*Строки формата для времени и дат*
Тип | Строка формата | Пример
-- | -- | --
Короткая дата | `d` | `M/d/yyyy`. Например: `10/30/2010`.
Длинная дата | `D` | `dddd, MMMM dd, yyyy`. Например: `Monday, January 31, 2011`.
Длинная дата и короткое время | `f` | `dddd, MMMM dd, yyyy HH:mm aa`. Например: `Monday, January 31, 2011 10:00 AM`.
Длинная дата и длинное время | `F` | `dddd, MMMM dd, yyyy HH:mm:ss aa`. Например: `Monday, January 31, 2011 10:00:23 AM`.
Сортируемый стандарт ISO | `s` | `yyyy-MM-dd HH:mm:ss`. Например: `2011-01-31 10:00:23`.
Месяц и день | `M` | `MMMM dd`. Например: `January 31`.
Общий | `G` | `M/d/yyyy HH:mm:ss aa` (зависит от локальных установок). Например: `10/30/2010 10:00:23 AM`.

Списочные элементы управления WPF также поддерживают строковое форматирование для своих элементов. Чтобы использовать его, нужно просто установить свойство **`ItemStringFormat`** списка (унаследованное от базового класса `ItemsControl`). Ниже приведен пример со списком машин:
```xml
<ListBox Name="lstCars" Margin="5" ItemStringFormat="Марка: {0}" />
```

Форматированная строка автоматически передается привязке, которая захватывает текст каждого элемента списка.

##### Конвертеры значений
Свойство `Binding.StringFormat` создано для простого стандартного форматирования чисел и дат. Но во многих сценариях привязки требуется более мощный инструмент, который называется классом конвертера значений.

Роль конвертера значений довольно очевидна. Он отвечает за преобразование исходных данных непосредственно перед их отображением в целевом элементе и (в случае двунаправленной привязки) преобразование нового целевого значения непосредственно перед его применением к источнику.

Конвертеры значений — исключительно удобная часть инфраструктуры привязки данных WPF. Их можно использовать несколькими удобными способами, которые перечислены ниже:

- *Форматирование данных для строкового представления*. Например, можно преобразовывать число в строку валюты. Это — наиболее очевидное применение конвертеров значений, но, конечно же, не единственное.

- *Создание специфических типов объектов WPF*. Например, можно прочитать блок двоичных данных и создать объект `BitmapImage`, который затем привязать к элементу `Image`.

- *Условное изменение свойства в элементе на основе привязанных данных*. Например, можно создать конвертер значений, который изменяет цвет фона элемента для выделения значений из определенного диапазона.

##### Форматирование строк с помощью конвертера значений
Чтобы получить базовое представление о работе конвертера значений, вернемся к примеру форматирования денежной величины из предыдущего раздела. Хотя там использовалось свойство `Binding.StringFormat`, аналогичного (и даже большего) результата можно добиться с помощью конвертера значений. Например, можно округлять или усекать значения, использовать словесное описание числа (изменив 600000 на 600 тыс. руб.). Можно даже настроить работу обратного преобразования, заменяя введенные пользователем значения правильными значениями в привязанном объекте (чтобы избавиться от ошибки, возникающей при редактировании данных).

Для создания конвертера значений потребуется выполнить четыре шага:

1. Создать класс, реализующий `IValueConverter`.

2. Добавить атрибут `ValueConversion` в объявление класса и указать исходный и целевой типы данных.

3. Реализовать метод `Convert()`, преобразующий данные из исходного формата в отображаемый формат.

4. Реализовать метод `ConvertBack()`, выполняющий обратное преобразование значения из отображаемого формата в его "родной" формат.

Ниже приведен полный код конвертера значений, который имеет дело со значениями цены, хранимыми в свойстве `CarTable.Cost`:
```cs
[ValueConversion(typeof(double), typeof(string))]
public class CostConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        // Возвращаем строку в формате 123.456.789 руб.
        return ((double)value).ToString("#,###", culture) + " руб.";
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        double result;
        if (Double.TryParse(value.ToString(), System.Globalization.NumberStyles.Any,
                        culture, out result))
        {
            return result;
        }
        else if (Double.TryParse(value.ToString().Replace(" руб.", ""), System.Globalization.NumberStyles.Any,
                        culture, out result))
        {
            return result;
        }
        return value;
    }
}
```

Чтобы ввести в действие этот конвертер, надо начать с отображения пространства имен проекта на префикс пространства имен XML, который можно применять в коде разметки. Если вы используете старый пример, то такой префикс уже существует:
```xml
<Window ...
xmlns:databinding="clr-namespace:DataBinding"
```

Далее нужно добавить объект конвертора в ресурсы окна:
```xml
<Window.Resources>
        <databinding:CostConverter x:Key="CostConverter"></databinding:CostConverter>
</Window.Resources>
```

Затем можно указывать на него в привязке, используя ссылку `StaticResource`:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, Converter={StaticResource CostConverter}}"
         LostFocus="textChange_Event"></TextBox>
```

Теперь значения, введенные пользователем в указанном формате будут корректно преобразовываться и записываться в базу данных.

##### Создание объектов с конвертером значений
Конвертеры значений незаменимы, когда необходимо преодолеть зазор между способом сохранения данных в классах и способом их отображения в окне. Например, предположим, что есть графические данные, хранящиеся в виде массива байт в поле базы данных.

Существует возможность преобразования двоичных данных в объект `System.Windows.Media.Imaging.BitmapImage` и сохранения его как части объекта данных. Однако такое проектное решение может не подойти.

Например, может понадобиться гибкость для создания более одного объектного представления изображения — возможно, потому, что библиотека данных используется как в приложениях WPF, так и в приложениях Windows Forms (где вместо этого применяется класс `System.Drawing.Bitmap`). В таком случае имеет смысл хранить низкоуровневую двоичную информацию в объекте данных и преобразовывать ее в WPF-объект `BitmapImage` с помощью конвертера значений.

Таблица `CarTable` из базы данных *AutoShop* не включает двоичных графических данных, но содержит поле `ImageCar`, хранящее имя файла с изображением машины.

Во-первых, изображение может быть недоступным в зависимости от расхода памяти при работе приложения. Во-вторых, нет смысла в расходе дополнительной памяти для хранения изображения, если вы не собираетесь его показывать.

Поле `ImageCar` включает имя файла и относительный путь, но не полный путь к этому файлу изображения, что дает определенную гибкость для размещения таких файлов в любом подходящем месте. Перед конвертером значений стоит задача создания URI, указывающего на файл изображения, на основе поля `CarImage` и каталога, который будет использоваться для хранения таких файлов. Ниже приведен полный код `ImagePathConverter`, выполняющий преобразование:
```cs
public class ImagePathConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return new BitmapImage(
            new Uri(
                System.IO.Directory.GetCurrentDirectory() + "\\" + (string)value));
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return null;
    }
}
```

Давайте немного изменим компоновку нашего проекта и добавим выражение привязки, использующее этот конвертер значений, в объект `Image` (не забудьте добавить этот конвертор в ресурсы окна, например, под именем `ImageConverter`):
```xml
<!-- Файл MainWindow.xaml -->

...

<Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="110"/>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition/>
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
    </Grid.RowDefinitions>

    <Image Margin="5,0" Grid.RowSpan="3"
            Source="{Binding Path=ImageCar, Converter={StaticResource ImageConverter}}"/>
    <TextBlock Margin="7" Grid.Column="1">Марка:</TextBlock>
    <TextBox Margin="5" Grid.Column="2" LostFocus="textChange_Event">
        <TextBox.Text>
            <Binding Path="ModelName" UpdateSourceTrigger="PropertyChanged">
                <Binding.ValidationRules>
                    <databinding:EmptyRule></databinding:EmptyRule>
                </Binding.ValidationRules>
            </Binding>
        </TextBox.Text>
    </TextBox>
    <TextBlock Margin="7" Grid.Row="1" Grid.Column="1">Модель:</TextBlock>
    <TextBox Margin="5" Grid.Row="1" Grid.Column="2" LostFocus="textChange_Event">
        <TextBox.Text>
            <Binding Path="ModelNumber" UpdateSourceTrigger="PropertyChanged">
                <Binding.ValidationRules>
                    <databinding:EmptyRule></databinding:EmptyRule>
                </Binding.ValidationRules>
            </Binding>
        </TextBox.Text>
    </TextBox>
    <TextBlock Margin="7" Grid.Row="2" Grid.Column="1">Цена (руб):</TextBlock>
    <TextBox Margin="5" Grid.Row="2" Grid.Column="2"
                Text="{Binding Cost, ValidatesOnExceptions=True, Converter={StaticResource CostConverter}}"
                LostFocus="textChange_Event"></TextBox>
    <TextBlock Margin="7,7,7,0" Grid.Row="3">Описание:</TextBlock>
    <TextBox Margin="7" Grid.Row="4" Grid.ColumnSpan="3"
                VerticalScrollBarVisibility="Visible" TextWrapping="Wrap"
                Text="{Binding Path=Description, TargetNullValue=Описание не доступно}" LostFocus="textChange_Event"/>
</Grid>
```

Данный код (в частности привязка свойства `Source` объекта `Image`) работает, поскольку свойство `Image.Source` ожидает объекта `ImageSource`, a класс `BitmapImage` унаследован от `ImageSource`.

Этот пример можно усовершенствовать несколькими способами. Попытка создать `BitmapImage`, указывающий на несуществующий файл, вызовет исключение, которое будет получено при установке свойств `DataContext`, `ItemsSource` или `Source`.

В качестве альтернативы можно добавить свойства в класс `ImagePathConverter`, которые позволят настроить это поведение. Например, можно предусмотреть свойство `SuppressExceptions` булевского типа. Если оно установлено в `true`, можно перехватывать исключения в методе `Convert()` и затем возвращать значение `Binding.DoNothing` (которое укажет WPF действовать так, как будто никакой привязки данных не установлено).

Или же можно добавить свойство `DefaultImage`, которое будет принимать `BitmapImage`. Тогда в случае возникновения исключений `ImagePathConverter` сможет вернуть изображение, выбранное по умолчанию.

Также следует отметить, что этот конвертер поддерживает только однонаправленное преобразование. Причина в том, что изменить объект `BitmapImage` невозможно и применять его для обновления пути к изображению. Однако можно воспользоваться альтернативным подходом. Вместо возврата `BitmapImage` из `ImagePathConverter` можно просто вернуть полностью квалифицированный URI из метода `Convert()`.

##### Применение условного форматирования
Некоторые из наиболее интересных конвертеров значений не предназначены для форматирования данных для целей презентации. Вместо этого они служат для форматирования ряда других связанных с внешним видом аспектов элемента на основе правила данных.

Например, предположим, что требуется выделить самые дорогостоящие машины, окрасив фон другим цветом. Эту логику легко инкапсулировать в следующем конвертере значений:
```cs
public class CostToBackgroundConverter : IValueConverter
{
    public double MinimumCostRichCar { get; set; }
    public Brush HighlughtBrush { get; set; }
    public Brush DefaultBrush { get; set; }

    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        if ((double)value >= MinimumCostRichCar)
            return HighlughtBrush;
        else
            return DefaultBrush;
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return null;
    }
}
```

Этот конвертер значений тщательно спроектирован с учетом возможности повторного использования. Вместо жесткого кодирования, цвета для выделения задаются в XAML-размете кодом, который использует этот конвертер:
```xml
<Window.Resources>
        ...
        <databinding:CostToBackgroundConverter x:Key="bgConverter" MinimumCostRichCar="1000000"
                                               DefaultBrush="{x:Null}" HighlughtBrush="LightSalmon"/>
        <Style x:Key="myLBIStyle" TargetType="{x:Type ListBoxItem}">
            <Setter Property="Background" Value="{Binding Path=Cost, Converter={StaticResource bgConverter}}"/>
        </Style>
    </Window.Resources>

...

<!-- Добавили стиль для элементов ListBoxItem -->
<ListBox Name="lstCars" Margin="5" ItemContainerStyle="{StaticResource myLBIStyle}"/>

...
```

Вместо цветов применяются кисти, так что можно создавать и более совершенные эффекты выделения, применяя градиенты и фоновые изображения. Чтобы сохранить стандартный прозрачный фон (таким образом, будет использоваться фон родительского элемента), просто установите свойство `DefaultBrush` или `HighlightBrush` в `Null`, как показано выше. Теперь машины, стоящие выше 1 млн. руб. будут подсвечены в списке.

##### Оценка множества свойств
До сих пор выражения привязки использовались для преобразования одной части исходных данных в единый форматированный результат. И хотя изменить вторую часть уравнения (результат) не удастся, приложив немного усилий, можно создать привязку, которая вычисляет или комбинирует информацию из более чем одного исходного свойства.

Первый трюк состоит в замене объекта `Binding` на **`MultiBinding`**. Затем в свойстве `MultiBinding.StringFormat` определяется организация привязанных свойств. Ниже приведен пример, который объединяет фамилию с именем и отображает результат в `TextBlock`:
```xml
<TextBlock>
   <TextBlock.Text>
       <MultiBinding StringFormat="{}{1}, {0}">
           <Binding Path="FirstName"></Binding>
           <Binding Path="LastName"></Binding>
       </MultiBinding>
   </TextBlock.Text>
</TextBlock>
```

В этом примере два поля используются, как они есть, в свойстве `StringFormat`. В качестве альтернативы можно применять форматные строки, чтобы изменить это. Например, при комбинировании с помощью `MultiBinding` текстового значения и значения валюты можно установить `StringFormat` в "{0} затраты {1:C}".

Если хотите сделать с этими двумя исходными полями что-то более изощренное, чем просто соединить их вместе, понадобится помощь конвертера значений. Такой прием позволяет производить вычисления либо применять форматирование, которое принимает во внимание несколько деталей (таких как подсветка всех товаров с наивысшей ценой в указанной категории). Однако для этого конвертер значений должен реализовывать интерфейс **`IMultiValueConverter`** вместо `IValueConverter`.

#### Форматирование значений
Привязка представляет очень простой механизм, однако иногда этому механизму требуется некоторая кастомизация. Так, нам может потребоваться небольшое форматирование значение. Для примера возьмем класс `Phone` из прошлых тем:
```cs
class Phone
{
    public string Title { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
```

Допустим, нам надо в текстовый блок вывести не только цену, но и еще какой-нибудь текст:
```xml
<Window x:Class="ValueConventerApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:ValueConventerApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid>
        <TextBlock Text="{Binding StringFormat=Итоговая цена {0} рублей, Source={StaticResource nexusPhone}, Path=Price}" />
    </Grid>
</Window>
```

Свойство **`StringFormat`** получает набор параметров в фигурных скобках. Фигурные скобки (`{0}`) передают собственно то значение, к которому идет привязка. Можно сказать, что действие свойства `StringFormat` аналогично методу `String.Format()`, который выполняет форматирование строк.

При необходимости мы можем использовать дополнительные опции форматирования, например, `{0:C}` для вывода валюты, `{0:P}` для вывода процентов и т.д.:
```xml
<TextBlock Text="{Binding StringFormat={}{0:C}, Source={StaticResource nexusPhone}, Path=Price}" />
```

При этом если у нас значение в `StringFormat` начинается с фигурных скобок, например, `"{0:C}"`, то перед ними ставятся еще пара фигурных скобок, как в данном случае. По сути они ничего важно не несут, просто служат для корректной интерпретации строки.

Либо в этом случае нам надо экранировать скобки слешами:
```xml
<TextBlock Text="{Binding StringFormat=\{0:C\}, Source={StaticResource nexusPhone}, Path=Price}" />
```

В зависимости от типа элемента доступны различные типы форматировщиков значений:

- **`StringFormat`**: используется для класса `Binding`

- **`ContentStringFormat`**: используется для классов `ContentControl`, `ContentPresenter`, `TabControl`

- **`ItemStringFormat`**: используется для класса `ItemsControl`

- **`HeaderStringFormat`**: используется для класса `HeaderContentControl`

- **`ColumnHeaderStringFormat`**: используется для классов `GridView`, `GridViewHeaderRowPresenter`

- **`SelectionBoxItemStringFormat`**: используется для классов `ComboBox`, `RibbonComboBox`

Их применение аналогично. Например, так как `Button` представляет `ContentControl`, то для этого элемента надо использовать `ContentStringFormat`:
```xml
<Button ContentStringFormat="{}{0:C}"
    Content="{Binding Source={StaticResource nexusPhone}, Path=Price}" />
```

#### Конвертеры значений
Конвертеры значений (value converter) также позволяют преобразовать значение из источника привязки к типу, который понятен приемнику привязки. Так как не всегда два связываемых привязкой свойства могут иметь совместимые типы. И в этом случае как раз и нужен конвертер значений.

Допустим, нам надо вывести дату в определенном формате. Для этой задачи создадим в проекте класс конвертера значений:
```cs
using System;
using System.ComponentModel;
using System.Globalization;
using System.Windows.Data;

public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,CultureInfo culture)
    {
        return ((DateTime)value).ToString("dd.MM.yyyy");
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return DependencyProperty.UnsetValue;
    }
}
```

Конвертер значений должен реализовать интерфейс **`System.Windows.Data.IValueConverter`**. Этот интерфейс определяет два метода: `Convert()`, который преобразует пришедшее от привязки значение в тот тип, который понимается приемником привязки, и `ConvertBack()`, который выполняет противоположную операцию.

Оба метода принимают четыре параметра:

- `object value`: значение, которое надо преобразовать

- `Type targetType`: тип, к которому надо преобразовать значение `value`

- `object parameter`: вспомогательный параметр

- `CultureInfo culture`: текущая культура приложения

В данном случае метод `Convert` возвращает строковое представление даты в формате "dd.MM.yyyy". То есть мы ожидаем, что в качестве параметра `value` будет передаваться объект `DateTime`.

Метод `ConvertBack` в данном случае не имеет значения, поэтому он просто возвращает пустое значение для свойства. В другом случае мы бы здесь получали строковое значение и преобразовывали его в `DateTime`.

Теперь применим этот конвертер в xaml:
```xml
<Window x:Class="ValueConventerApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:ValueConventerApp"
        xmlns:sys="clr-namespace:System;assembly=mscorlib"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <sys:DateTime x:Key="myDate">2/12/2016</sys:DateTime>
        <local:DateTimeToDateConverter x:Key="myDateConverter" />
    </Window.Resources>
    <StackPanel>
        <TextBlock Text="{Binding Source={StaticResource myDate},Converter={StaticResource myDateConverter}}" />
        <TextBlock Text="{Binding Source={StaticResource myDate}}" />
    </StackPanel>
</Window>
```

Здесь искомая дата, которая выводится в текстовые блоки, задана в ресурсах. Также в ресурсах задан конвертер значений. Чтобы применить этот конвертер в конструкции привязки используется параметр **`Converter`** с указанием на ресурс: `Converter={StaticResource myDateConverter}`.

Для сравнения я здесь определил два текстовых блока. Но поскольку к одному из них применяется конвертер, то отображение даты будет отличаться.

Немного изменим код конвертера и используем передаваемый параметр:
```cs
public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if(parameter!=null && parameter.ToString()=="EN")
            return ((DateTime)value).ToString("MM-dd-yyyy");

        return ((DateTime)value).ToString("dd.MM.yyyy");
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return DependencyProperty.UnsetValue;
    }
}
```

В качестве параметра может передаваться любой объект. Если параметр в xaml не используется, то передается `null`. В данном случае мы проверяем, равен ли параметр строке "EN", то есть мы ожидаем, что параметр будет передавать строковое значение. И если равен, то возвращаем дату немного в другом формате.

Для применения параметра изменим код xaml:
```xml
<StackPanel>
    <TextBlock Text="{Binding Source={StaticResource myDate},Converter={StaticResource myDateConverter}}" />
    <TextBlock Text="{Binding Source={StaticResource myDate}, ConverterParameter=EN, Converter={StaticResource myDateConverter}}" />
    <TextBlock Text="{Binding Source={StaticResource myDate}}" />
</StackPanel>
```

Параметр привязки задается с помощью свойства **`ConverterParameter`**. Итак, у нас тут три текстовых блока, и применяя конвертер, мы получим три разных отображения даты.

Также мы можем использовать передаваемые в конвертер параметры культуры и типа, к которому надо преобразовать. Например, мы можем смотреть на тип целевого значения и в зависимости от результатов производить определенные действия:
```cs
public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (targetType != typeof(Brush))
        {
            //....
        }
//...................
```

В данном случае предполагается, что тип объекта, к которому надо преобразовать, представляет тип `Brush`.

#### Списочные элементы управления
Форматирование строки и конвертеры значений — это все, что нужно для применения гибкого форматирования к индивидуальным привязанным значениям. Но привязанным спискам требуется нечто большее. К счастью, WPF предлагает несколько решений форматирования. Большинство из них встроено в базовый класс `ItemsControl`, от которого наследуются все списочные элементы управления, так что именно отсюда следует начать исследование форматирования списков.

Как известно, класс `ItemsControl` определяет базовую функциональность для элементов управления, которые содержат в себе список элементов. Этими элементами могут быть вхождения в списке, узлы дерева, команды меню, кнопки в панели инструментов и т.п.

Некоторые оболочки элементов списков появляются в иерархии классов, унаследованных от `ItemsControl`. Например, здесь будут не только ожидаемые классы `Menu` и `TreeView`, но также `MenuItem` и `TreeViewItem`. Причина в том, что эти классы обладают способностью содержать собственные коллекции подэлементов — именно это обеспечивает деревьям и меню их вложенную иерархическую структуру. С другой стороны, вы не найдете здесь `ComboBoxItem` и `ListBoxItem`, поскольку они не содержат коллекций вложенных элементов, и потому не наследуются от `ItemsControl`.

В `ItemsControl` определены свойства, которые поддерживают привязку данных, и два ключевых средства форматирования: стили и шаблоны данных. В таблице ниже содержится краткий обзор свойств `ItemsControl`. (Свойства перечисляются от самых базовых до наиболее сложных.)

Следующий элемент иерархии наследования `ItemsControl` — класс `Selector`, который добавляет простой набор свойств для определения (и установки) выбранного элемента. Не все классы `ItemsControl` поддерживают выбор. Например, выбор не имеет никакого значения для `ToolBar` или `Menu`, потому эти классы наследуются от `ItemsControl`, а не от `Selector`.

*Свойства класса `ItemsControl`, относящиеся к форматированию*
Наименование | Описание
-- | --
`ItemsSource` | Привязанный источник данных (коллекция `DataView`, которую необходимо отобразить в списке).
`DisplayMemberPath` | Свойство, которое должно отображаться для каждого элемента данных. Для более сложного представления или комбинирования свойств используйте вместо него `ItemsTemplate`.
`ItemsStringFormat` | Строка формата .NET, которая, будучи установленной, используется для форматирования текста каждого элемента. Обычно этот прием используется для преобразования числовых значений или значений дат в подходящее видимое представление — точно так же, как это делает свойство `Binding.StringFormat`.
`ItemContainerStyle` | Стиль, позволяющий устанавливать свойства контейнера, который включает в себя каждый элемент. Контейнер зависит от типа списка (например, это `ListBoxItem` для класса `ListBox` и `ComboBoxItem` — для класса `ComboBox`).Объекты-оболочки создаются автоматически при наполнении списка.
`ItemContainerStyleSelector` | `StyleSelector`, использующий код для выбора стиля оболочки каждого элемента в списке. Это позволяет назначать разным элементам списка различные стили. Специальный класс `StyleSelector` должен быть создан самостоятельно.
`AlternationCount` | Число чередующихся наборов для данных. Например, при значении `AlternationCount`, равном 2, варьируется 2 стиля строк, при `AlternationCount`, равном 3, существует три чередующихся стиля строк и т.д.
`ItemTemplate` | Шаблон, извлекающий соответствующие данные из привязанного объекта и организующий их в соответствующую комбинацию элементов управления.
`ItemTemplateSelector` | `DataTemplateSelector`, использующий код для выбора шаблона каждого элемента в списке. Это позволяет назначать разным элементам различные шаблоны. Специальный класс `DataTemplateSelector` должен быть создан самостоятельно.
`ItemsPanel` | Определяет панель, созданную для хранения всех элементов списка. Все оболочки элементов добавляются в этот контейнер. Обычно для вертикальной ориентации списка (сверху вниз) применяется `VirtualizingStackPanel`.
`GroupStyle` | Если используется группирование, это стиль, определяющий, как должна быть сформатирована каждая группа. При использовании группирования оболочки элементов (`ListBoxItem`, `ComboBoxItem` и т.п.) добавляются к оболочкам `GroupItem`, представляющим каждую группу, и эти группы затем добавляются в список.
`GroupStyleSelector` | `StyleSelector`, использующий код для выбора стиля каждой группы. Это позволяет назначать разным группам различные стили. Специальный класс `StyleSelector` должен быть создан самостоятельно.

К свойствам, которые добавляет класс `Selector`, относятся **`SelectedItem`** (выбранный объект данных), **`SelectedIndex`** (позиция выбранного элемента) и **`SelectedValue`** (свойство "значения" выбранного объекта данных, которое указывается установкой `SelectedValuePath`). Обратите внимание, что класс `Selector` не поддерживает множественный выбор — это добавляется к `ListBox` посредством свойств `SelectionMode` и `SelectionItems` (что по существу и все, что класс `ListBox` добавляет к этой модели).
