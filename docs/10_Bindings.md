## Bindings / Привязки

- [Bindings / Привязки](#bindings--привязки)
  - [Введение в привязку](#введение-в-привязку)
    - [Классификация привязок](#классификация-привязок)
    - [Работа с привязкой в C#](#работа-с-привязкой-в-c)
    - [Режимы привязки](#режимы-привязки)
    - [Обновление привязки. UpdateSourceTrigger](#обновление-привязки-updatesourcetrigger)
    - [Свойство Source](#свойство-source)
    - [Свойство TargetNullValue](#свойство-targetnullvalue)
    - [Свойство RelativeSource](#свойство-relativesource)
    - [Свойство IsAsync](#свойство-isasync)
    - [Свойство DataContext](#свойство-datacontext)
  - [Привязка элементов](#привязка-элементов)
    - [Связывание элементов](#связывание-элементов)
      - [Ошибки привязки](#ошибки-привязки)
    - [Режимы привязки](#режимы-привязки-1)
    - [Создание привязки в коде](#создание-привязки-в-коде)
    - [Множественные привязки](#множественные-привязки)
    - [Обновление привязок](#обновление-привязок)
    - [Привязка к объектам](#привязка-к-объектам)
      - [Свойство Source](#свойство-source-1)
      - [Свойство RelativeSource](#свойство-relativesource-1)
      - [Свойство DataContext](#свойство-datacontext-1)
  - [Привязка данных](#привязка-данных)
    - [Режимы привязки](#режимы-привязки-2)
    - [Особенности](#особенности)
    - [Привязка к данным в отделенном коде](#привязка-к-данным-в-отделенном-коде)
    - [Привязка данных из базы](#привязка-данных-из-базы)
      - [Запрос из базы данных](#запрос-из-базы-данных)
      - [Обновление базы данных](#обновление-базы-данных)
    - [Привязка к коллекции объектов](#привязка-к-коллекции-объектов)
      - [Отображение и редактирование элементов коллекции](#отображение-и-редактирование-элементов-коллекции)
      - [Вставка и удаление элементов коллекций](#вставка-и-удаление-элементов-коллекций)
    - [Проверка достоверности](#проверка-достоверности)
      - [Проверка достоверности в объекте данных](#проверка-достоверности-в-объекте-данных)
      - [Класс ExceptionValidationRule](#класс-exceptionvalidationrule)
      - [Специальные правила проверки достоверности](#специальные-правила-проверки-достоверности)
      - [Отображение отличающегося индикатора ошибки](#отображение-отличающегося-индикатора-ошибки)
      - [Получение списка ошибок](#получение-списка-ошибок)
    - [Поставщики данных](#поставщики-данных)
      - [ObjectDataProvider](#objectdataprovider)
      - [Обработка ошибок](#обработка-ошибок)
      - [Асинхронная поддержка](#асинхронная-поддержка)
      - [XmlDataProvider](#xmldataprovider)
    - [Привязка данных и LINQ](#привязка-данных-и-linq)
  - [Интерфейс INotifyPropertyChanged](#интерфейс-inotifypropertychanged)
    - [Дополнительные возможности](#дополнительные-возможности)
    - [Использование объектно-ориентированного проектирования](#использование-объектно-ориентированного-проектирования)
  - [Форматирование привязанных данных](#форматирование-привязанных-данных)
    - [Преобразование данных](#преобразование-данных)
      - [Свойство StringFormat](#свойство-stringformat)
      - [Конвертеры значений](#конвертеры-значений)
      - [Форматирование строк с помощью конвертера значений](#форматирование-строк-с-помощью-конвертера-значений)
      - [Создание объектов с конвертером значений](#создание-объектов-с-конвертером-значений)
      - [Применение условного форматирования](#применение-условного-форматирования)
      - [Оценка множества свойств](#оценка-множества-свойств)
    - [Форматирование значений](#форматирование-значений)
    - [Конвертеры значений](#конвертеры-значений-1)
    - [Списочные элементы управления](#списочные-элементы-управления)

### Введение в привязку
В WPF привязка (binding) является мощным инструментом программирования, без которого не обходится ни одно серьезное приложение. <dfn title="привязка">Привязка</dfn> в WPF — это мощный механизм, позволяющий связывать свойства элементов управления с данными из различных источников. Это позволяет синхронизировать значения свойств двух разных объектов, что упрощает представление и взаимодействие с данными в приложениях.

Привязка подразумевает взаимодействие двух объектов: *источника* и *приемника*. Объект-приемник создает привязку к определенному свойству объекта-источника. В случае модификации объекта-источника, объект-приемник также будет модифицирован.

Например, простейшая форма с использованием привязки:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="250" Width="300">
    <StackPanel>
        <TextBox x:Name="myTextBox" Height="30" />
        <TextBlock x:Name="myTextBlock" Text="{Binding ElementName=myTextBox,Path=Text}" Height="30" />
    </StackPanel>
</Window>
```

Для определения привязки используется выражение типа:
```xml
{Binding ElementName=Имя_объекта-источника, Path=Свойство_объекта-источника}
```

То есть в данном случае у нас элемент `TextBox` является источником, а `TextBlock` — приемником привязки. Свойство `Text` элемента `TextBlock` привязывается к свойству `Text` элемента `TextBox`. В итоге при осуществлении ввода в текстовое поле синхронно будут происходить изменения в текстовом блоке.

#### Классификация привязок
В WPF существует несколько видов привязок, которые позволяют связывать свойства элементов управления с данными из различных источников. Основные виды привязок включают:

1. <dfn title="привязка элементов">Привязка элементов</dfn> — это механизм, позволяющий связывать свойства различных элементов управления между собой. Привязка элементов — это простейший сценарий, когда источником данных является другой элемент WPF, а целевым свойством — свойство зависимости другого элемента. Это позволяет синхронизировать значения свойств элементов, что упрощает создание динамического и отзывчивого пользовательского интерфейса. Пример:

    ```xml
    <TextBox x:Name="textBox1" />
    <TextBlock Text="{Binding ElementName=textBox1, Path=Text}" />
    ```

2. <dfn title="привязка объектов">Привязка объектов</dfn> предполагает связывание свойств элементов WPF с свойствами объектов .NET. Это может быть любой объект, который содержит данные, например, класс с публичными свойствами. Чтобы использовать этот подход, вы должны определить объект в ресурсах или задать его как `DataContext` для элемента.

    ```xml
    <Window.Resources>
        <local:MyData x:Key="myData" ColorName="Red" />
    </Window.Resources>

    <Grid DataContext="{StaticResource myData}">
        <TextBlock Text="{Binding Path=ColorName}" />
    </Grid>
    ```

3. <dfn title="привязка данных">Привязка данных</dfn> — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными. Привязка данных — это более широкое понятие, которое включает в себя привязку элементов WPF к различным источникам данных, таким как коллекции, объекты ADO.NET или XML-данные. Привязка данных позволяет автоматически обновлять интерфейс при изменении данных и наоборот. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения. Пример:

    ```xml
    <ListBox ItemsSource="{Binding Path=Employees}" />
    ```

4. <dfn title="вложенная привязка">Вложенные привязки</dfn> позволяют использовать несколько привязок одновременно для одного свойства. В WPF существуют три вида вложенных привязок:

   - **`Binding`**: Стандартная привязка.

   - **`PriorityBinding`**: Выполняет привязку к нескольким источникам с приоритетом.

   - **`MultiBinding`**: Объединяет несколько значений из разных источников в одно.

   Пример `MultiBinding`:
   ```xml
   <TextBlock>
       <TextBlock.Text>
           <MultiBinding StringFormat="{}{0} {1}">
               <Binding Path="FirstName" />
               <Binding Path="LastName" />
           </MultiBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

#### Работа с привязкой в C#
Ключевым объектом при создании привязки является объект `System.Windows.Data.Binding`.

Определение:
```cs
public class Binding : System.Windows.Data.BindingBase
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding?view=windowsdesktop-9.0

Используя этот объект мы можем получить уже имеющуюся привязку для элемента:
```cs
Binding binding = BindingOperations.GetBinding(myTextBlock, TextBlock.TextProperty);
```

В данном случае получаем привязку для свойства зависимостей `TextProperty` элемента `myTextBlock`.

Также можно полностью установить привязку в коде C#:
```cs
public MainWindow()
{
    InitializeComponent();

    Binding binding = new Binding();

    binding.ElementName = "myTextBox"; // элемент-источник
    binding.Path = new PropertyPath("Text"); // свойство элемента-источника
    myTextBlock.SetBinding(TextBlock.TextProperty, binding); // установка привязки для элемента-приемника
}
```

Если в дальнейшем нам станет не нужна привязка, то мы можем воспользоваться классом **`BindingOperations`** и его методами **`ClearBinding()`** (удаляет одну привязку) и **`ClearAllBindings()`** (удаляет все привязки для данного элемента)
```cs
BindingOperations.ClearBinding(myTextBlock, TextBlock.TextProperty);
```

или
```cs
BindingOperations.ClearAllBindings(myTextBlock);
```

Некоторые свойства класса **`Binding`**:

- **`ElementName`**: имя элемента, к которому создается привязка

- **`IsAsync`**: если установлено в `True`, то использует асинхронный режим получения данных из объекта. По умолчанию равно `False`

- **`Mode`**: режим привязки

- **`Path`**: ссылка на свойство объекта, к которому идет привязка

- **`TargetNullValue`**: устанавливает значение по умолчанию, если привязанное свойство источника привязки имеет значение `null`

- **`RelativeSource`**: создает привязку относительно текущего объекта

- **`Source`**: указывает на объект-источник, если он не является элементом управления.

- **`XPath`**: используется вместо свойства `path` для указания пути к xml-данным

#### Режимы привязки
Свойство **`Mode`** объекта `Binding`, которое представляет режим привязки, может принимать следующие значения:

- **`OneWay`**: свойство объекта-приемника изменяется после модификации свойства объекта-источника.

- **`OneTime`**: свойство объекта-приемника устанавливается по свойству объекта-источника только один раз. В дальнейшем изменения в источнике никак не влияют на объект-приемник.

- **`TwoWay`**: оба объекта — приемник и источник — могут изменять привязанные свойства друг друга.

- **`OneWayToSource`**: объект-приемник, в котором объявлена привязка, меняет объект-источник.

- **`Default`**: по умолчанию (если меняется свойство `TextBox.Text`, то имеет значение `TwoWay`, в остальных случаях `OneWay`).

Применение режима привязки:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30" Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay}" />
</StackPanel>
```

#### Обновление привязки. UpdateSourceTrigger
Односторонняя привязка от источника к приемнику практически мгновенно изменяет свойство приемника. Но если мы используем двустороннюю привязку в случае с текстовыми полями (как в примере выше), то при изменении приемника свойство источника не изменяется мгновенно. Так, в примере выше, чтобы текстовое поле-источник изменилось, нам надо перевести фокус с текстового поля-приемника. И в данном случае в дело вступает свойство **`UpdateSourceTrigger`** класса `Binding`, которое задает, как будет происходить обновление. Это свойство в качестве принимает одно из значений перечисления `UpdateSourceTrigger`:

- `PropertyChanged`: источник привязки обновляется сразу после обновления свойства в приемнике

- `LostFocus`: источник привязки обновляется только после потери фокуса приемником

- `Explicit`: источник не обновляется до тех пор, пока не будет вызван метод `BindingExpression.UpdateSource()`

- `Default`: значение по умолчанию. Для большинства свойств это значение `PropertyChanged`. А для свойства `Text` элемента `TextBox` это значение `LostFocus`

В данном случае речь идет об обновлении источника привязки после изменения приемника в режимах `OneWayToSource` или `TwoWay`. То есть чтобы у нас оба текстовых поля, которые связаны режимом `TwoWay`, моментально обновлялись после изменения одного из них, надо использовать значение `UpdateSourceTrigger.PropertyChanged`:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30"
        Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
</StackPanel>
```

#### Свойство Source
Свойство `Source` позволяет установить привязку даже к тем объектам, которые не являются элементами управления WPF. Например, определим класс `Phone`:
```cs
class Phone
{
    public string Title { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
```

Теперь создадим объект этого класса и определим к нему привязку:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black">
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <TextBlock Text="Модель:" Foreground="White"/>
        <TextBlock x:Name="titleTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Title}"
                        Foreground="White" Grid.Column="1"/>
        <TextBlock Text="Цена:" Foreground="White" Grid.Row="1"/>
        <TextBlock x:Name="priceTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Price}"
                        Foreground="White" Grid.Column="1" Grid.Row="1"/>
    </Grid>
</Window>
```

#### Свойство TargetNullValue
На случай, если свойство в источнике привязки вдруг имеет значение `null`, то есть оно не установлено, мы можем задать некоторое значение по умолчанию. Например:
```xml
<Window.Resources>
    <local:Phone x:Key="nexusPhone" Company="Google" Price="25000" />
</Window.Resources>
<StackPanel>
    <TextBlock x:Name="titleTextBlock"
        Text="{Binding Source={StaticResource nexusPhone}, Path=Title, TargetNullValue=Текст по умолчанию}" />
</StackPanel>
```

#### Свойство RelativeSource
Свойство **`RelativeSource`** позволяет установить привязку относительно элемента-источника, который связан какими-нибудь отношениями с элементом-приемником. Например, элемент-источник может быть одним из внешних контейнеров для элемента-приемника. Либо источником и приемником может быть один и тот же элемент.

Для установки этого свойства используется одноименный объект **`RelativeSource`**. У этого объекта есть свойство **`Mode`**, которое задает способ привязки. Оно принимает одно из значений перечисления **`RelativeSourceMode`**:

- `Self`: привязка осуществляется к свойству этого же элемента. То есть элемент-источник привязки в то же время является и приемником привязки.

- `FindAncestor`: привязка осуществляется к свойству элемента-контейнера.

Например, совместим источник и приемник привязке в самом элементе:
```xml
<TextBox Text="{Binding RelativeSource={RelativeSource Mode=Self}, Path=Background, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
```

Здесь текст и фоновый цвет текстового поля связаны двусторонней привязкой. В итоге мы можем увидеть в поле числовое значение цвета, поменять его, и вместе с ним изменится и фон поля.

Привязка к свойствам контейнера:
```xml
<Grid Background="Black">
    <TextBlock Foreground="White"
        Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType={x:Type Grid}}, Path=Background}" />
</Grid>
```

При использовании режима `FindAncestor`, то есть привязке к контейнеру, необходимо еще указывать параметр **`AncestorType`** и передавать ему тип контейнера в виде выражения `AncestorType={x:Type Тип_элемента-контейнера}`. При этом в качестве контейнера мы могли бы выбрать любой контейнер в дереве элементов, в частности, в данном случае кроме `Grid` таким контейнером также является элемент `Window`.

#### Свойство IsAsync
Свойство `IsAsync` класса `Binding` в WPF используется для указания, следует ли получать и задавать значения привязки асинхронно. Это означает, что если `IsAsync` установлено в `true`, привязка будет выполняться в асинхронном режиме, что может быть полезно для предотвращения блокировки интерфейса пользователя при работе с медленными операциями, такими как загрузка данных из внешних источников.

Однако, стоит отметить, что использование `IsAsync` может не всегда быть самым эффективным или правильным решением для всех сценариев. Например, если источник данных доступен быстро, использование асинхронной привязки может не дать заметных преимуществ и может даже привести к дополнительной сложности.

Пример использования `IsAsync` в XAML:
```xml
<Run Text="{Binding Source={StaticResource nexusPhone}, Path=Discount, IsAsync=True}" />
```

В коде-behind это можно установить так:
```cs
var binding = new Binding("Discount") { IsAsync = true };
```

Несмотря на то, что `IsAsync` может быть полезен в определенных ситуациях, его применение должно быть тщательно обосновано, чтобы избежать ненужной сложности и потенциальных проблем с синхронизацией данных.

Кроме того, стоит отметить, что для более сложных асинхронных операций, таких как загрузка данных из внешних источников, могут быть более подходящими другие механизмы, такие как использование `ObjectDataProvider` с `IsAsynchronous=true` или реализация асинхронных команд в MVVM-паттерне.

#### Свойство DataContext
У объекта `FrameworkElement`, от которого наследуются элементы управления, есть интересное свойство `DataContext`. Оно позволяет задавать для элемента и вложенных в него элементов некоторый контекст данных. Тогда вложенные элементы могут использовать объект `Binding` для привязки к конкретным свойствам этого контекста. Например, используем ранее определенный класс `Phone` и создадим контекст данных из объекта этого класса:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black" DataContext="{StaticResource nexusPhone}" TextBlock.Foreground="White">
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <TextBlock Text="Модель" />
        <TextBlock Text="{Binding Title}" Grid.Row="1" />
        <TextBlock Text="Производитель" Grid.Column="1"/>
        <TextBlock Text="{Binding Company}" Grid.Column="1" Grid.Row="1" />
        <TextBlock Text="Цена" Grid.Column="2" />
        <TextBlock Text="{Binding Price}" Grid.Column="2" Grid.Row="1" />
    </Grid>
</Window>
```

![Picture 10.4](./img/67d423945040133e8429f1a8-10.4.png)

Таким образом мы задаем свойству `DataContext` некоторый динамический или статический ресурс. Затем осуществляем привязку к этому ресурсу.

### Привязка элементов

#### Связывание элементов
Простейший сценарий привязки данных подразумевает ситуацию, когда исходным объектом является элемент WPF, а исходным свойством — свойство зависимости. Причина в том, что свойство зависимости имеет встроенную поддержку уведомлений об изменениях. В результате, когда значение свойства зависимости изменяется в исходном объекте, привязанное свойство целевого объекта немедленно обновляется. Это именно то, что требуется, и происходит оно без необходимости построения любой дополнительной инфраструктуры.

Хотя привязка элемента к элементу является простейшим подходом, большинство разработчиков заинтересовано в нахождении самого общего подхода для реальных приложений. В общем, большая часть работы по привязке данных будет тратиться на привязку элементов к объектам данных. Это позволит отображать информацию, извлекаемую из внешнего источника (такого как база данных или файл). Однако привязка элемента к элементу также часто бывает полезной.

Например, ее можно использовать для автоматизации способа, которым элементы взаимодействуют, так что когда пользователь модифицирует один элемент управления, другой элемент обновляется автоматически. Это ценное сокращение, которое избавляет от написания громоздкого и рутинного кода (и это прием, не доступный в предыдущем поколении приложений Windows Forms).

Рассмотрим пример приложения из двух элементов управления: ползунка (`Slider`) и текстового блока (`TextBlock`). При изменении положения ползунка размер шрифта текстового блока должен меняться. Такое поведение можно реализовать за счет обработки события изменения положения ползунка `ValueChaned`:
```xml
<Slider Minimum="8" Maximum="30" ValueChanged="Slider_ValueChanged"></Slider>
<TextBlock x:Name="Message" FontSize="20">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

```cs
private void Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
{
    if (Message != null)
        Message.FontSize = ((Slider)sender).Value;
}
```

Как видно из исходного кода, возникает необходимость проверки существования объекта `Message`, т.к. первый вызов обработчика `Slider_ValueChanged` происходит в момент обработки элемента `Slider` XAML-файла, когда элемент `TextBlock` еще не обработан и, соответственно, объект `Message` еще не создан. Второй проблемой является несоответствие начального значения ползунка и начального размера шрифта.

Для решения поставленной задачи можно задействовать связывание элементов управления WPF. Для использования привязки данных необходимо  указать в качестве значения свойства `FontSize` текстового блока следующее выражение привязки:
```cs
{Binding ElementName=SliderFontSize, Path=Value}`
```

Выражение привязки данных задается в виде расширения разметки XAML в фигурных скобках.

Составляющие выражения привязки:
- **`Binding`** – означает, что будет создан объект класса `System.Windows.Data.Binding`
- **`ElementName`** – имя исходного объекта,
- **`Path`** – имя свойства (или путь до свойства) исходного объекта. Пример пути до свойства: `Background.Opacity`

```xml
<Slider Minimum="8" Maximum="30" x:Name="SliderFontSize"></Slider>
<TextBlock x:Name="Message" FontSize="{Binding ElementName=SliderFontSize, Path=Value}">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

В данном примере отсутствуют проблемы, обнаруженные в предыдущем примере. Начальные значения связанных свойств будут согласованы даже в том случае, если элемент `TextBlock` будет предшествовать элементу `Slider`.

Чтобы понять, как привязывать один элемент к другому, рассмотрим простое окно. Оно содержит два элемента управления: `Slider` (ползунок) и `TextBlock` (текстовый блок) с единственной строкой текста. Перемещение ползунка вправо приводит к немедленному увеличению размера шрифта текста, а перемещение влево — к уменьшению размера шрифта.

*XAML*:
```xml
<Slider Margin="5" Minimum="1" Maximum="72" Value="12" Name="sld"
                TickFrequency="5" TickPlacement="BottomRight"></Slider>
<TextBlock Margin="5" Text="Какой-то текст"
            FontSize="{Binding ElementName=sld, Path=Value}"></TextBlock>
```

Привязка определена в элементе `TextBlock`. Вместо установки `FontSize` с использованием литерального значения применяется выражение привязки.

Выражения привязки данных используют расширение разметки XAML (и потому помещаются в фигурные скобки). В начале идет слово `Binding`, потому что создается экземпляр класса **`System.Windows.Data.Binding`**. Хотя объект `Binding` может быть сконфигурирован различными способами, в данной ситуации необходимо установить только два свойства: `ElementName`, которое указывает исходный элемент, и `Path`, указывающее свойство в исходном элементе.

Вместо `Property` используется `Path`, потому что `Path` может указывать на свойство свойства (например, `FontFamily.Source`) или индексатор, используемый свойством (например, `Content.Children[0]`). Путь может включать множество фрагментов, переходящих от свойства к свойству, и т.д.

Чтобы сослаться на присоединенное свойство (свойство, которое определено в другом классе, но применяется к привязанному элементу), имя свойства должно быть указано в круглых скобках. Например, в случае привязки к элементу, помещенному в `Grid`, путь `(Grid.Row)` извлекает номер строки, в которой он находится.

##### Ошибки привязки
WPF не генерирует исключения для уведомления о проблемах привязки данных. Если указан несуществующий элемент или свойство, никакого сообщения об этом не будет; вместо этого данные просто не попадут в целевое свойство. На первый взгляд это может показаться кошмаром для отладки. К счастью, WPF выводит трассировочную информацию, которая детализирует сбои в привязке. Во время отладки приложения эта информация появляется в выходном окне Visual Studio.

Например, попытка привязки к несуществующему свойству приводит к выводу в выходное окно следующего сообщения:
```
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.App"
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.InitializeComponent"
System.Windows.Data Error: 40 : BindingExpression path error:
'SliderValue' property not found on 'object' ''Slider' (Name='sld')'
.BindingExpression:Path=SliderValue; DataItem='Slider' (Name='sld'); target element
is 'TextBlock' (Name=''); target property is 'FontSize' (type 'Double')
```

Среда WPF также игнорирует любые исключения, которые генерируются при попытке читать исходное свойство, и молча поглощает исключение, возникающее, если исходные данные не могут быть приведены к типу данных целевого свойства. Однако есть и другой способ справиться с этой проблемой — можно сообщить WPF о необходимости изменения внешнего вида исходного элемента для индикации возникшей ошибки. Например, неверный ввод можно пометить значком с восклицательным знаком или рамкой красного цвета.

#### Режимы привязки
Одной из ценных особенностей привязки данных является то, что цель обновляется автоматически, независимо от того, как модифицируется источник. В примере из предыдущей статьи источник может быть модифицирован только в одном направлении — через взаимодействие пользователя с ползунком. Однако рассмотрим несколько усложненную версию этого примера, в которой добавляется кнопка, при щелчке на которой изменяется положение ползунка:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    sld.Value += 5;
}
```

Этот код перемещает значение ползунка на 5 единиц, который, в свою очередь, изменяет размер шрифта текста через привязку данных. Это то же самое, как если бы вы двигали ползунок вручную. В этом и заключается основная сила привязки элементов.

Интересно, что существует способ заставить данные перемещаться в обоих направлениях: от источника к цели и от цели к источнику. Трюк заключается в установке свойства **`Mode`** объекта `Binding`. Ниже приведена усовершенствованная двунаправленная привязка, которая позволяет применять значения либо к источнику, либо к цели, и заставит противоположную часть привязки обновлять себя автоматически:
```xml
<TextBlock Margin="5" Text="Какой-то текст"
      FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBlock>
```

В рассматриваемом примере нет причин применять двунаправленную привязку (которая требует больше накладных расходов), поскольку эту проблему можно решить с помощью кода. Однако рассмотрим вариант этого примера, включающий текстовое поле, в котором пользователь может точно устанавливать размер шрифта. Этому текстовому полю понадобится двунаправленная привязка, чтобы оно могло как применять пользовательские изменения, так и отражать последнее значение размера, когда оно изменяется другим путем.

При установке свойства `Binding.Mode` можно использовать одно из пяти значений перечисления `System.Windows.Data.BindingMode`. Ниже приведен их полный список:

- **`OneWay`**

    Целевое свойство обновляется при изменениях исходного свойства

- **`TwoWay`**

    Целевое свойство обновляется при изменениях исходного свойства, а исходное свойство обновляется при изменении целевого свойства

- **`OneTime`**

    Целевое свойство устанавливается изначально на основе значения исходного свойства. Однако с этого момента изменения игнорируются (если только привязка не устанавливается на совершенно другой объект или не вызывается `BindingExpression.UpdateTarget()`). Обычно этот режим используется для сокращения накладных расходов, если известно, что целевое свойство не изменится

- **`OneWayToSource`**

    Подобно `OneWay`, но действует в обратном направлении. Исходное свойство обновляется, когда изменяется целевое свойство (что может показаться несколько странным), но целевое свойство никогда не обновляется

- **`Default`**

    Этот тип привязки зависит от целевого свойства. Это либо `TwoWay` (для устанавливаемых пользователем свойств, таких как `TextBox.Text`), либо `OneWay` (для всего остального). Все привязки используют данный подход, если только не указано иное

Вы уже видели `OneWay` и `TwoWay`. Значение `OneTime` достаточно очевидно. Оставшиеся два варианта требуют ряда дополнительных исследований.

Может возникнуть вопрос: зачем нужны две опции — и `OneWay`, и `OneWayToSource`? В конце концов, оба значения создают однонаправленную привязку, которая работает одинаковым образом. Единственное отличие в том, куда помещено выражение привязки. По сути, `OneWayToSource` позволяет поменять местами источник и цель, поместив выражение в то, что обычно считается источником привязки.

Наиболее общая причина использования этого трюка состоит в установке свойства, которое не является свойством зависимости. Как упоминалось, выражения привязки могут применяться только для установки свойств зависимости. Однако с помощью `OneWayToSource` это ограничение можно обойти, предоставляя в качестве свойства, поставляющего значение, свойство зависимости.

Изначально кажется логичным предположить, что все привязки однонаправленные, если только явно не указано иное. (В конце концов, именно так работает простой пример с ползунком.) Но на самом деле это не так. Чтобы убедиться в этом, вернемся к примеру с привязанным текстовым полем и позволим редактировать текущий размер шрифта. Если убрать установку `Mode=TwoWay`, этот пример все равно будет работать точно также. Причина в том, что WPF использует разные значения `Mode` по умолчанию, в зависимости от привязываемого свойства. (Формально в каждом свойстве зависимости присутствует фрагмент метаданных — флаг `FrameworkPropertyMetadata.BindsTwoWayByDefault`, который указывает, какую привязку должно использовать свойство: однонаправленную или двунаправленную).

Часто значение по умолчанию — именно то, что и нужно. Тем не менее, можно представить пример с текстовым полем только для чтения, которое пользователь не может изменять. В этом случае удается слегка сократить накладные расходы, установив режим однонаправленной привязки.

В качестве общего эмпирического правила: всегда неплохо явно устанавливать режим. Даже в случае текстового поля стоит подчеркнуть, что нужна двунаправленная привязка, включив свойство `Mode`.

#### Создание привязки в коде
При построении окна обычно наиболее эффективно объявлять выражение привязки в разметке XAML с помощью расширения разметки `Binding`. Тем не менее, допускается также создавать привязку и в коде.

Вот как можно создать привязку для элемента `TextBlock`, показанного в примере из предыдущей статьи:
```cs
Binding bind = new Binding();
bind.Source = sld;
bind.Path = new PropertyPath("Value");
bind.Mode = BindingMode.TwoWay;
txb.SetBinding(TextBlock.FontSizeProperty, bind);
```

Для удаления привязки в коде предусмотрены два статических метода класса **`BindingOperations`**. Метод `ClearBinding()` принимает ссылку на свойство зависимости, которое имеет привязку, подлежащую удалению, а метод `ClearAllBindings()` удаляет все привязки данных элемента:
```cs
BindingOperations.ClearAllBindings(txb);
```

И `ClearBinding()`, и `ClearAllBindings()` используют метод `ClearValue()`, который каждый элемент наследует от базового класса `DependencyObject`. Метод `ClearValue()` просто удаляет локальное значение свойства (которым в данном случае является выражение привязки).

Привязка на основе разметки применяется намного чаще, чем программная привязка, потому что она яснее и требует меньше работы. Однако код может применяться для создания привязки в некоторых специализированных сценариях:

- **Создание динамических привязок**

    Если необходимо тонко настраивать привязку на основе другой информации времени выполнения или создавать разные привязки в зависимости от обстоятельств, имеет смысл делать это в коде. (В качестве альтернативы можно было бы определить все необходимые привязки в коллекции `Resources` окна и просто добавить код, который вызывает `SetBinding()` с соответствующим объектом привязки.)

- **Удаление привязки**

    Чтобы удалить привязку и получить возможность установки свойства обычным образом, понадобится помощь метода `ClearBinding()` или `ClearAllBindings()`. Недостаточно просто присвоить новое значение свойству. В случае использования двунаправленной привязки установленное значение распространится на привязанный объект, и оба свойства останутся синхронизированными.

    С помощью методов `ClearBinding()` и `ClearAllBindings()` можно удалить любую привязку. Не имеет значения, применялась привязка программно или в коде XAML.

- **Создание специальных элементов управления**

    Чтобы облегчить для других модификацию визуального представления специального элемента управления, который разрабатывается, определенные детали (такие как обработчики событий и выражения привязки данных) понадобится перенести в код разметки.

#### Множественные привязки
В WPF в одном элементе управления разрешается использовать сколько угодно привязок. Можно модифицировать пример из предыдущей статьи, добавив к элементу `TextBlock` еще несколько привязок:
```xml
<StackPanel>
            <Slider Name="sld" Minimum="1" Maximum="72" Margin="10"
                TickFrequency="5" TickPlacement="BottomRight" Value="12"></Slider>
            <TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"></TextBox>
            <ListBox Margin="10" Name="lst">
                <ListBoxItem Tag="DarkBlue">
                    <Label>Dark Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="Blue">
                    <Label>Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="LightBlue">
                    <Label>Light Blue</Label>
                </ListBoxItem>
            </ListBox>
            <!-- Используем несколько привязок -->
            <TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Text="{Binding ElementName=txt, Path=Text}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}"></TextBlock>
</StackPanel>
```

Допускается также реализовать привязку данных. Например, можно создать выражение привязки для свойства `TextBox.Text`, связывающее его со свойством `TextBlock.FontSize`, которое содержит выражение привязки, связывающее со свойством `Slider.Value`. В этом случае, когда пользователь перетаскивает ползунок в новую позицию, значение передается от `Slider` в `TextBlock` и затем из `TextBlock` в `TextBox`.

Хотя все работает прозрачно, более ясный подход состоит в том, чтобы привязать элементы как можно ближе к данным, которые они используют. В описанном здесь примере необходимо предусмотреть привязку и `TextBlock`, и `TextBox` непосредственно к свойству `Slider.Value`.

Все становится немного более интересно, когда на целевое свойство должны оказывать влияние более одного источника, например, если нужно иметь две равноправные привязки, устанавливающие одно и то же свойство. На первый взгляд это кажется невозможным. Однако существует несколько способов решения.

Простейший подход состоит в изменении режима привязки данных. Как уже известно, свойство `Mode` позволяет модифицировать способ работы привязки так, что данные передаются не только от источника к цели, но и от цели к источнику. С помощью такого приема можно создать несколько выражений привязки, устанавливающих одно и то же свойство. Последнее из них будет иметь эффект.

Чтобы понять, как это работает, рассмотрим вариацию примера элемента — панели с ползунком, который включает текстовое поле, куда можно поместить точное значение размера шрифта. В этом примере свойство `TextBlock.FontSize` может быть установлено двумя путями: перетаскиванием ползунка или вводом в текстовом поле размера шрифта. Все элементы управления синхронизированы так, что если вводится новое число в текстовом поле, размер шрифта текста примера изменяется и ползунок перемещается в соответствующую позицию.

Как уже упоминалось, к свойству `TextBlock.FontSize` можно применять только одну привязку данных. Поэтому имеет смысл оставить свойство `TextBlock.FontSize` в том виде, как оно есть, чтобы оно привязывалось прямо к ползунку.

Хотя добавить другую привязку к свойству `FontSize` нельзя, можно привязать новый элемент управления `TextBox` к свойству `TextBlock.FontSize`. Ниже показана необходимая для этого разметка:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        Text="{Binding ElementName=txb, Path=FontSize, Mode=TwoWay}"></TextBox>
```

Теперь при каждом изменении свойства `TextBlock.FontSize` текущее значение будет вставляться в текстовое поле. Более того, значение в текстовом поле можно редактировать, применяя указанный размер шрифта. Обратите внимание, что для того, чтобы пример работал, свойство `TextBox.Text` должно использовать двунаправленную привязку, передающую данные в обоих направлениях. В противном случае текстовое поле сможет отображать значение `TextBlock.FontSize`, но не позволит изменять его.

С этим примером связано несколько нюансов:

- Поскольку значение свойства `Slider.Value` имеет тип `double`, при перетаскивании ползунка получается дробное значение размера. Установив свойство `TickFrequency` в 1 (или в некоторый целочисленный интервал), a свойство `IsSnapToTickEnabled` в `true`, можно ограничить значение ползунка только целыми величинами.

- Текстовое поле позволяет вводить буквы и другие нечисловые символы. В таком случае значение текстового поля не сможет быть интерпретировано как число. В результате привязка данных молча потерпит неудачу, а значение размера шрифта станет равно 0. Другой подход мог бы состоять в обработке нажатий клавиш в текстовом поле, чтобы вообще предотвратить неправильный ввод, либо в использовании проверки достоверности.

- Изменения, которые вносятся в текстовое поле, не будут применены до тех пор, пока текстовое поле не потеряет фокус (например, когда с помощью клавиши `<Tab>` происходит переход на другой элемент управления). Если такое поведение не подходит, можно обеспечить непрерывное обновление, используя свойство `UpdateSourceTrigger` объекта `Binding`.

Интересно, что показанное здесь решение — не единственный способ привязки текстового поля. Столь же разумно конфигурировать текстовое поле таким образом, чтобы оно изменяло значение свойства `Slider.Value` вместо свойства `TextBlock.FontSize`:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBox>
```

Теперь изменение текстового поля инициирует изменение положения ползунка, которое затем установит новый размер шрифта текста. Опять-таки, данный подход работает только с двунаправленной привязкой данных.

И, наконец, можно поменять местами роли ползунка и текстового поля, чтобы ползунок привязывался к текстовому полю.

В случае привязки `Slider.Value` текстовое поле ведет себя несколько иначе, чем в предыдущих двух примерах. Любые изменения, которые вносятся в текстовое поле, применяются немедленно, вместо того, чтобы ожидать момента утери фокуса.

Как видно из примера, двунаправленные привязки обеспечивает значительную гибкость. Их можно использовать для применения изменений от источника к цели и от цели к источнику. Допускается их применение в комбинации, что позволяет создать неожиданно сложные окна без какого-либо кода.

Обычно решение относительно того, куда применять выражение привязки, диктуется логикой модели кодирования. В предыдущем примере, возможно, было бы больше смысла поместить привязку в свойство `TextBox.Text` вместо свойства `Slider.Value`, потому что текстовое поле — это необязательное дополнение к вполне готовому примеру, а не основной ингредиент, на который полагается ползунок.

Также имело бы больше смысла привязать текстовое поле непосредственно к свойству `TextBlock.FontSize` вместо свойства `Slider.Value`. (Концептуально вы заинтересованы в том, чтобы видеть текущий размер шрифта, и ползунок — только один из способов его установки. Даже несмотря на то, что положение ползунка совпадает с размером шрифта, это — необязательная дополнительная деталь, если вы пытаетесь написать максимально ясную разметку.) Конечно, эти решения субъективны и определяются стилем кодирования. Наиболее важный урок состоит в том, что три подхода могут обеспечить одинаковое поведение.

В следующих статьях мы рассмотрим две детали, касающиеся этого примера. Во-первых, речь пойдет о возможных выборах при установке направления привязки. Во-вторых, будет показано, каким образом точно указать WPF, когда имеет смысл обновлять исходное свойство при двунаправленной привязке.

#### Обновление привязок
В примере из предыдущей статьи (где `TextBox.Text` привязывается к `TextBlock.FontSize`) имеется еще один нюанс. При попытке изменить отображаемый размер шрифта, вводя значение в текстовое поле, ничего не происходит. Изменение не применяется до тех пор, пока не будет совершен переход на другой элемент. Это поведение отличается от поведения, которое демонстрировалось в примере с ползунком. Там новый размер шрифта применялся после перетаскивания ползунка в другую позицию, т.е. в переходе на другой элемент вообще не было необходимости.

Чтобы понять это различие, следует повнимательнее присмотреться к выражениям привязки, которые используются этими двумя элементами управления. Когда применяется привязка `OneWay` или `TwoWay`, измененное значение распространяется от источника к цели немедленно. В случае с ползунком есть однонаправленное выражение привязки в `TextBlock`. Таким образом, изменения в свойстве `Slider.Value` немедленно отражаются в свойстве `TextBlock.FontSize`. То же поведение имеет место в примере с текстовым полем: изменения в источнике (которым является `TextBlock.FontSize`) немедленно влияют на цель (`TextBox.Text`).

Однако изменения, протекающие в обратном направлении — от цели к источнику — не обязательно происходят немедленно. Вместо этого их поведение управляется свойством **`Binding.UpdateSourceTrigger`**, которое принимает одно из значений, описанных ниже. Когда текст берется из текстового поля и используется для обновления свойства `TextBlock.FontSize`, это пример обновления цель-источник, которое использует поведение `UpdateSourceTrigger.LostFocus`.

- **`PropertyChanged`**

    Источник обновляется немедленно, когда изменяется целевое свойство

- **`LostFocus`**

    Источник обновляется немедленно, когда изменяется целевое свойство и цель теряет фокус

- **`Explicit`**

    Источник не обновляется, пока не будет вызван метод `BindingExpression.UpdateSource()`

- **`Default`**

    Поведение обновления определяется метаданными целевого свойства (формально — его свойства `FrameworkPropertyMetadata.DefaultUpdateSourceTrigger`). Для большинства свойств поведением по умолчанию будет `PropertyChanged`, хотя свойство `TextBox.Text` обладает поведением по умолчанию `LostFocus`

Помните, что эти значения не оказывают эффекта на обновление цели. Они просто управляют тем, как обновляется источник в привязках `TwoWay` и `OneWayToSource`.

Вооружившись этим знанием, можно усовершенствовать пример с текстовым полем, чтобы изменения применялись к размеру шрифта по мере их ввода в текстовое поле:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
       Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

Поведением по умолчанию свойства `TextBox.Text` является `LostFocus` просто потому, что текст в текстовом поле будет изменяться непрерывно в процессе пользовательского ввода, вызывая множественные обновления. В зависимости от того, как исходный элемент управления обновляет себя, режим обновления `PropertyChanged` может сделать приложение более медлительным. Вдобавок это может заставить исходный объект обновлять себя до завершения редактирования, что создаст проблемы при проверке достоверности.

Для полного контроля над моментом обновления исходного объекта можно выбрать режим `UpdateSourceTrigger.Explicit`. Если воспользоваться этим подходом в примере с текстовым полем, то когда текстовое поле утратит фокус, ничего не произойдет.

Вместо этого код должен будет вручную инициировать обновление. Например, можно было бы добавить кнопку Add (Добавить), которая вызовет метод **`BindingExpression.UpdateSource()`**, инициируя немедленное обновление размера шрифта. Разумеется, прежде чем можно будет вызвать метод `BindingExpression.UpdateSource()`, нужен способ получения объекта `BindingExpression`. Объект `BindingExpression` — это тонкая упаковка, которая содержит в себе две вещи: уже известный объект `Binding` (предоставленный через свойство `BindingExpression.ParentBinding`) и объект, привязанный от источника (`BindingExpression.DataItem`).

Вдобавок объект `BindingExpression` предоставляет два метода для запуска немедленного обновления одной части привязки: `UpdateSource()` и `UpdateTarget()`.

Для получения объекта `BindingExpression` используется метод `GetBindingExpression()`, унаследованный каждым элементом от базового класса `FrameworkElement`, которому передается целевое свойство, имеющее привязку.

#### Привязка к объектам
[67ef67e35040133e8429f2e5](https://professorweb.ru/my/WPF/binding_and_styles_WPF/level8/8_6.php)

До сих пор добавлялись привязки, которые устанавливали связь между двумя элементами. Однако в приложениях, управляемых данными, чаще создаются выражения привязки, которые извлекают данные из невизуальных объектов. Единственное требование, которое должно при этом соблюдаться — информация, которую необходимо отобразить, должны храниться в *общедоступных свойствах*. Инфраструктура привязки данных WPF не может извлекать приватную информацию или читать общедоступные поля.

При привязке к объекту, не являющемуся элементом, следует отказаться от свойства `Binding.ElementName` и применять вместо него одно из следующих свойств:

- **`Source`**

    Ссылка, указывающая на исходный объект; другими словами, это объект, поставляющий данные.

- **`RelativeSource`**

    Указывает на исходный объект, использующий объект `RelativeSource`, который позволяет базировать ссылку на текущем элементе. Это специализированный инструмент, который удобен при написании шаблонов элементов управления и шаблонов данных.

- **`DataContext`**

    Если источник не был указан с помощью свойства `Source` или `RelativeSource`, то среда WPF производит поиск в дереве элементов, начиная с текущего элемента. Она проверяет свойство `DataContext` каждого элемента и использует первый из них, который не равен `null`. Свойство `DataContext` исключительно полезно, когда нужно привязать несколько свойств одного объекта к разным элементам, потому что можно установить свойство `DataContext` высокоуровневого объекта контейнера, вместо его установки непосредственно на целевой элемент.

Ниже эти варианты описаны более подробно.

##### Свойство Source
Свойство `Source` достаточно прямолинейно. Единственный момент, который следует учитывать — объект данных должен быть сделан удобным для привязки. Как будет показано, для получения объекта данных существует несколько подходов: извлечь его из ресурса, генерировать программно или получить от поставщика данных.

Простейший вариант — установить `Source` в некоторый готовый и доступный статический объект. Например, можно создать статический объект в коде и использовать его. Или же можно применить ингредиент из библиотеки классов .NET, как показано ниже:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        FontFamily="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"
        Text="Текст"></TextBox>
```

Это выражение привязки получает объект `FontFamily`, который предоставлен свойством `SystemFonts.IconFontFamily`. (Обратите внимание, что для установки свойства `Binding.Source` понадобится помощь расширения разметки `Static`.) Затем свойство `Binding.Path` устанавливается в свойство `FontFamily.Source`, которое выдает имя семейства шрифтов. Результатом будет единственная строка текста. В Windows Vista или Windows 7 имя шрифта выглядит как Segoe UI.

Другой вариант состоит в привязке к объекту, который ранее создавался в виде ресурса. Например, следующая разметка создает объект `FontFamily`, указывающий на шрифт `Calibri`:
```xml
<Window.Resources>
        <FontFamily x:Key="CustomFont">Calibri</FontFamily>
</Window.Resources>
    ...
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           FontFamily="{Binding Source={StaticResource CustomFont}, Path=Source}"
           Text="Текст"></TextBox>
```

##### Свойство RelativeSource
Свойство `RelativeSource` позволяет установить его в исходный объект на основе его отношения к целевому объекту. Например, свойством `RelativeSource` можно воспользоваться для привязки элемента к самому себе или для привязки к родительскому элементу, который находится в неизвестном количестве уровней выше в дереве элементов.

Для установки свойства `Binding.RelativeSource` применяется объект `RelativeSource`. Это несколько усложняет синтаксис, поскольку нужно создать объект `Binding` и внутри него — вложенный объект `RelativeSource`. Один вариант состоит в использовании синтаксиса установки свойства вместо расширения разметки `Binding`.

Например, в следующем коде создается объект `Binding` для свойства `TextBlock.Text`. Объект `Binding` использует `RelativeSource`, которое ищет родительское окно и отображает заголовок окна:
```xml
<TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}">
           <TextBlock.Text>
                    <Binding Path="Title">
                        <Binding.RelativeSource>
                            <RelativeSource Mode="FindAncestor" AncestorType="{x:Type Window}"></RelativeSource>
                        </Binding.RelativeSource>
                    </Binding>
           </TextBlock.Text>
</TextBlock>
```

Для объекта `RelativeSource` выбран режим `FindAncestor`, который заставляет его осуществлять поиск вверх по дереву элементов до тех пор, пока не будет найден тип элемента, определенный свойством `AncestorType`.

Наиболее общий способ записи этой привязки состоит в комбинировании ее в одну строку, используя расширения разметки `Binding` и `RelativeSource`, как показано ниже:
```xml
Text="{Binding Path=Title, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
```

Режим `FindAncestor` — один из четырех возможных вариантов при создании объекта `RelativeSource`. Все варианты кратко описаны ниже:

- **`Self`**

    Выражение привязывается к другому свойству того же элемента

- **`FindAncestor`**

    Выражение привязывается к родительскому элементу. WPF будет проводить поиск вверх по дереву элементов, пока не найдет нужный родительский элемент. Чтобы указать родителя, необходимо также установить свойство `AncestorType` для индикации типа родительского элемента, который должен быть найден. Дополнительно с помощью свойства `AncestorLevel` можно пропустить определенное количество совпадений указанного элемента. Например, если требуется привязка к третьему элементу типа `ListBoxItem` при восхождении вверх по дереву, то следует установить `AncestorType={x:Type ListBoxItem}` и `AncestorLevel=3`, тем самым пропуская первые два `ListBoxItem`. По умолчанию `AncestorLevel` равен 1, и поиск прекращается на первом найденном элементе.

- **`PreviousData`**

    Выражение осуществляет привязку к предыдущему элементу данных в списке, привязанном к данным. Это можно использовать в элементе списка

- **`TemplatedParent`**

    Выражение осуществляет привязку к элементу, к которому применен шаблон. Этот режим работает, только если привязка находится внутри шаблона элемента управления или шаблона данных

На первый взгляд свойство `RelativeSource` может показаться излишним усложнением разметки. В конце концов, почему бы просто не привязаться непосредственно к необходимому источнику, используя свойство `Source` или `ElementName`? Однако, это не всегда возможно, и обычно потому, что объект-источник и целевой объект находятся в разных частях разметки. Так получается при создании шаблонов элементов управления и шаблонов данных. Например, при построении шаблона данных, который изменяет способ представления элементов в списке, может понадобиться доступ к объекту `ListBox` верхнего уровня, чтобы прочитать какое-то его свойство.

##### Свойство DataContext
В некоторых случаях имеется множество элементов, привязанных к одному объекту. Например, рассмотрим следующую группу элементов `TextBlock`, каждый из которых использует исходное выражение привязки для извлечения различных деталей о шрифте, значков по умолчанию, включая промежутки между строками, стиль и вес первой гарнитуры (то и другое — просто Regular). Можете воспользоваться свойством `Source` для каждого из них, но это приводит к довольно длинной разметке:
```xml
<StackPanel Margin="10">
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=LineSpacing}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Weight}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Style}"></TextBlock>
</StackPanel>
```

В такой ситуации было бы яснее и удобнее определить источник привязки один раз с помощью свойства `FrameworkElement.DataContext`. В данном примере имеет смысл установить свойство `DataContext` элемента `StackPanel`, содержащего в себе все элементы `TextBlock`. (Можно было бы также установить свойство `DataContext` на еще более высоком уровне, например, на уровне всего окна, но лучше определить его насколько возможно уже, чтобы яснее выразить намерения.)

Установить свойство `DataContext` элемента можно таким же образом, как устанавливается свойство `Binding.Source`. Другими словами, можно встроить объект, извлечь его из статического свойства либо получить из ресурса, как показано ниже:
```xml
<StackPanel DataContext="{х:Static SystemFonts.IconFontFamily}">
```

После этого выражения привязки упрощаются за счет исключения некоторой информации об источнике:
```xml
<TextBlock Margin="5" Text="{Binding Path=Source}"></TextBlock>
```

Когда информация об источнике отсутствует в выражении привязки, WPF проверяет свойство `DataContext` элемента. Если оно равно `null`, WPF ищет в дереве элементов первый контекст данных, отличный от `null`. (Изначально свойства `DataContext` всех элементов равны `null`.) Если подходящий контекст данных обнаружен, то он используется для привязки. Если же нет, то выражение привязки не передает никакого значения целевому свойству.

### Привязка данных
<dfn title="привязка данных">Привязка данных</dfn> (data binding) в графической системе WPF представляет собою отношение, которое сообщает WPF о необходимости извлечения данных из свойства исходного объекта (Source) и использования её для задания значения некоторого свойства целевого объекта (Target) (и, в некоторых случаях, наоборот).

Объектом-источником может быть как элемент WPF, так и объект ADO.NET или пользовательский объект, хранящий данные.

#### Режимы привязки
В выражении привязки с помощью параметра `Mode` можно задать одно из следующих пяти значений режима привязки:
1) `OneWay` – целевое свойство обновляется при изменении исходного свойства.

2) `OneTime` – первоначально значение исходного свойства копируется в целевое свойство, но дальнейшие изменения исходного свойства не учитываются.

3) `TwoWay` — целевое свойство обновляется при изменении исходного свойства, исходное свойство обновляется при изменении целевое свойства.

4) `OneWayToSource` – исходное свойство обновляется при изменении целевое свойства.

5) `Default` – значение по умолчанию. Если целевое свойство устанавливается пользователем (например, `TextBox.Text`, `Slider.Value`, `CheckBox.IsChecked`, …), то это `TwoWay`, в остальных случаях – это `OneWay`.

Пример выражения привязки с параметром Mode: `{Binding ElementName=slider1, Path=Value, Mode=OneTime}`.

#### Особенности
Свойство `EditingMode` (тип данных `InkCanvasEditingMode`) элемента управления `InkCanvas` нельзя напрямую связать с текстовым свойством выпадающего списка `ComboBox` или списка `ListBox`, т.к. в этом случае будет несовпадение типов. Для привязки данных необходимо, чтобы тип элементов списка совпадал с типом свойства `EditingMode`. Для этой цели необходимо добавить в  ресурсы окна приложения (элемент `Windows.Resources`) массив (элемент `x:Array`) элементов типа `InkCanvasEditingMode` (атрибут `x:Type`), данному ресурсу необходимо задать ключ (атрибут `x:Key`), который необходимо указать в свойстве `ItemSource` списка `ListBox` или выпадающего списка `ComboBox`. В этом случае можно будет осуществить привязку данных между свойством `EditingMode` и выделенным элементом списка:
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyEditingModes" x:Type="{x:Type InkCanvasEditingMode}">
      <x:Static Member="InkCanvasEditingMode.Ink"/>
      <x:Static Member="InkCanvasEditingMode.Select"/>
      <x:Static Member="InkCanvasEditingMode.EraseByPoint"/>
      <x:Static Member="InkCanvasEditingMode.EraseByStroke"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas EditingMode="{Binding ElementName=lbEditingModes, Path=SelectedValue}" />
    <ListBox x:Name="lbEditingModes" ItemsSource="{StaticResource MyEditingModes}" />
  </StackPanel>
</Window>
```

Аналогичным образом можно задать привязку данных между свойством  `DefaultDrawingAttributes` и выделенным элементом списка (в данном случае массив  `x:Array` будет содержать элементы типа `DrawingAttributes`):
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyDrawingAttributes" x:Type="{x:Type DrawingAttributes}">
      <DrawingAttributes Color="Red" Width="3" Height="3"/>
      <DrawingAttributes Color="Green" Width="10" Height="10"/>
      <DrawingAttributes Color="Blue" Width="15" Height="15"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas DefaultDrawingAttributes="{Binding ElementName=lbColors, Path=SelectedValue}" />
    <ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}" />
  </StackPanel>
</Window>
```

Недостатком последнего примера является то, что все элементы в списке выводятся с текстом «System.Windows.Ink.DrawingAttributes». Для придания элементам списка осмысленного содержания, необходимо определить шаблон элементов (`ListBox.ItemTemplate`), в котором определить, каким образом элементы списка будут отображены на экране (например, в виде текстового блока, содержащего поле `Color`):
```xml
<ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Path=Color}"></TextBlock>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```

#### Привязка к данным в отделенном коде
Чтобы привязать разметку к данным из CodeBehind в WPF, вы можете использовать несколько подходов:

1. **Привязка через `DataContext`**. Один из наиболее распространенных способов привязать данные к разметке — это использовать свойство `DataContext`. Вы можете задать `DataContext` для окна или любого другого элемента в CodeBehind и затем использовать привязку в XAML.

    C#:
    ```cs
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // Создание объекта с данными
            var data = new MyData { Name = "John", Age = 30 };

            // Установка DataContext
            DataContext = data;
        }
    }

    public class MyData
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    ```

    XAML:
    ```xml
    <Window x:Class="MyApp.MainWindow"
            xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            Title="MainWindow" Height="350" Width="525">
        <StackPanel>
            <TextBlock Text="{Binding Name}" />
            <TextBlock Text="{Binding Age}" />
        </StackPanel>
    </Window>
    ```

2. **Привязка с помощью объекта `Binding`**. Вы также можете создать привязку программно, используя объект `Binding`. Это может быть полезно, когда вам нужно динамически изменять привязку или когда вы не можете использовать XAML.

    C#:
    ```cs
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // Создание объекта с данными
            var data = new MyData { Name = "John", Age = 30 };

            // Создание привязки
            Binding binding = new Binding("Name");
            binding.Source = data;

            // Применение привязки
            txtName.SetBinding(TextBlock.TextProperty, binding);
        }
    }

    public class MyData
    {
        public string Name { get; set; }
        public int Age { get; set; }
    }
    ```

    XAML:
    ```xml
    <Window x:Class="MyApp.MainWindow"
            xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
            xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
            Title="MainWindow" Height="350" Width="525">
        <StackPanel>
            <TextBlock x:Name="txtName" />
        </StackPanel>
    </Window>
    ```

3. **Использование `INotifyPropertyChanged`**. Если ваши данные могут изменяться во время выполнения приложения, вы должны реализовать интерфейс `INotifyPropertyChanged`, чтобы уведомлять привязку об изменениях.

    C#:
    ```cs
    public class MyData : INotifyPropertyChanged
    {
        private string _name;

        public string Name
        {
            get { return _name; }
            set
            {
                _name = value;
                OnPropertyChanged("Name");
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
    ```

    Этот подход позволяет поддерживать актуальность данных в интерфейсе при их изменении.

#### Привязка данных из базы

##### Запрос из базы данных
Рассмотрим простое окно. Оно позволяет пользователю указывать код машины, после чего отображает соответствующую информацию о машине в контейнере `Grid` (в нижней части окна).

Во время проектирования этого окна нет доступа к объекту `CarTable`, который поставит данные во время выполнения. Тем не менее, создавать привязки можно и без указания источника данных. Необходимо просто указать свойство класса `CarTable`, которое будет использовать каждый элемент.

Ниже приведен код разметки для отображения объекта `CarTable`:
```xml
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
    </Grid.RowDefinitions>

    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"></ColumnDefinition>
            <ColumnDefinition></ColumnDefinition>
            <ColumnDefinition Width="Auto"></ColumnDefinition>
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"></RowDefinition>
        </Grid.RowDefinitions>

        <TextBlock Margin="7">Car ID:</TextBlock>
        <TextBox Name="txtID" Margin="5" Grid.Column="1"/>
        <Button Click="cmdGetCar_Click" Margin="5" Padding="2" Grid.Column="2">Получить данные</Button>
    </Grid>

    <Border Grid.Row="1" Padding="7" Margin="7" Background="LightSteelBlue">
        <Grid  Name="gridCarDetails">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"></ColumnDefinition>
                <ColumnDefinition></ColumnDefinition>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="*"></RowDefinition>
            </Grid.RowDefinitions>

            <TextBlock Margin="7">Марка:</TextBlock>
            <TextBox Margin="5" Grid.Column="1" Text="{Binding Path=ModelName}"></TextBox>
            <TextBlock Margin="7" Grid.Row="1">Модель:</TextBlock>
            <TextBox Margin="5" Grid.Row="1" Grid.Column="1" Text="{Binding Path=ModelNumber}"></TextBox>
            <TextBlock Margin="7" Grid.Row="2">Цена (руб):</TextBlock>
            <TextBox Margin="5" Grid.Row="2" Grid.Column="1" Text="{Binding Path=Cost}"></TextBox>
            <TextBlock Margin="7,7,7,0" Grid.Row="3">Описание:</TextBlock>
            <TextBox Margin="7" Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="2"
                        VerticalScrollBarVisibility="Visible" TextWrapping="Wrap" Text="{Binding Path=Description}"></TextBox>
        </Grid>
    </Border>
</Grid>
```

Обратите внимание, что контейнер `Grid`, служащий оболочкой для всех этих деталей, имеет имя, так что им можно манипулировать в коде и завершить привязку данных.

При первом запуске приложения никакая информация не отображается. Даже если определить необходимые привязки, никакого объекта источника не доступно. Когда пользователь щелкает на кнопке во время выполнения, извлекаются данные о соответствующей модели машины. Хотя каждую привязку можно создать программно, это не имеет особого смысла (и не сэкономит много кода по сравнению с заполнением элементов управления вручную).

Однако свойство `DataContext` предлагает блестящую альтернативу. Если установить его для контейнера `Grid`, содержащего все выражения привязки данных, то все выражения будут использовать его для заполнения себя данными.

Ниже приведен код обработки событий щелчка на кнопке пользователем:
```cs
private void cmdGetCar_Click(object sender, RoutedEventArgs e)
{
    int id;

    if (Int32.TryParse(txtID.Text, out id))
        gridCarDetails.DataContext = MainWindow.GetAutoById(id);
    else
        MessageBox.Show("Неверный формат ID");
}
```

Текущий класс `CarTable` предполагает получение полного комплекта данных о машине. Однако таблицы базы данных часто включают поля, допускающие значения `null`, которые указывают на отсутствующую или неприменимую информацию. Это отражается в классах данных с помощью допускающих `null` типов данных для простых числовых значений или дат. Например, в сущностном классе `CarTable` можно использовать `int?` вместо `int`. Естественно, ссылочные типы, такие как строки и полноценные объекты, всегда поддерживают значения `null`.

Результат привязки значения `null` предсказуем — целевой элемент вообще ничего не отображает. Для числовых полей это поведение полезно, поскольку позволяет отличать отсутствующее значение (когда элемент не показывает ничего) от нулевого значения (когда показывается текст 0). Тем не менее, следует отметить, что есть возможность изменить способ отображения WPF значений `null`, устанавливая свойство `TargetNullValue` в выражении привязки. Если сделать это, то вместо `null` будет отображаться указанное значение. Вот пример отображения текста `[Описание не предоставлено]`, когда свойство `CarTable.Decription` равно `null`:
```xml
Text="{Binding Path=Description, TargetNullValue=[Описание не предоставлено]}"
```

Квадратные скобки в тексте `TargetNullValue` не обязательны. В данном случае они служат для подсказки пользователю, что отображаемый текст не взят из базы данных.

##### Обновление базы данных
Для того чтобы включить обновления базы данных в этом примере, дополнительно ничего делать не понадобится. Свойство `TextBox.Text` использует двустороннюю привязку по умолчанию. В результате объект `CarTable` модифицируется в случае редактирования содержимого текстовых полей. (Формально каждое свойство обновляется при переходе на новое поле, поскольку в качестве режима обновления источника по умолчанию для свойства `TextBox.Text` установлен `LostFocus`.)

Зафиксировать изменения в базе данных можно в любой момент. Все, что для этого понадобится — добавление метода обновления в обработчик события клика кнопки *Обновить*. При щелчке на ней код может получить текущий объект `CarTable` из контекста данных и воспользоваться им для фиксации обновления. Давайте добавим эту кнопку, видоизменив часть разметки:

XAML:
```xml
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
    </Grid.RowDefinitions>

    <Button Grid.Row="2" HorizontalAlignment="Left" Margin="7,0,7,5" Padding="2" Click="cmdUpdateCar_Click"
            Content="Обновить"></Button>

...
```

C#:
```cs
private void cmdUpdateCar_Click(object sender, RoutedEventArgs e)
{
    CarTable ct = (CarTable)gridCarDetails.DataContext;

    // Используем LINQ to Entities для обновления базы данных
    AutoShopEntities context = new AutoShopEntities();

    CarTable ct1 = context.CarTables
                            .Where(p => p.ID == ct.ID)
                            .Single<CarTable>();

    ct1.ModelName = ct.ModelName;
    ct1.ModelNumber = ct.ModelNumber;
    ct1.Cost = ct.Cost;
    ct1.Description = ct.Description;

    context.SaveChanges();
}
```

С этим примером связана одна потенциальная загвоздка. После щелчка на кнопке *Обновить* фокус переходит к этой кнопке и все незафиксированные изменения в текстовых полях применяются к объекту `CarTable`. Однако если сделать кнопку *Обновить* кнопкой по умолчанию (установив свойство `IsDefault` в `true`), появится другая возможность. Пользователь сможет внести изменения в одно из полей и нажать клавишу <kbd>Enter</kbd>, чтобы запустить процесс обновления без фиксации последнего изменения. Во избежание такой ситуации необходимо явно передать фокус, прежде чем выполнять любой код базы данных:
```cs
FocusManager.SetFocusedElement(this, (Button)sender);
```

#### Привязка к коллекции объектов
Привязка к единственному объекту довольно проста. Но все становится намного интереснее, когда нужно привязаться к некоторой коллекции объектов, например, ко всем машинам в таблице.

Хотя каждое свойство зависимости поддерживает привязку к одному значению, которая применялась до сих пор, привязка к коллекции требует несколько более интеллектуального элемента. В WPF все классы, унаследованные от **`ItemsControl`**, способны отображать целый список элементов. Возможностью привязки данных обладают `ListBox`, `ComboBox`, `ListView` и `DataGrid` (а также `Menu` и `TreeView` — для иерархических данных).

Хотя может показаться, что WPF предлагает относительно небольшой набор списочных элементов управления, тем не менее, эти элементы предоставляют почти неограниченные возможности по отображению данных. Это связано с тем, что списочные элементы управления поддерживают шаблоны данных, которые позволяют непосредственно управлять отображением элементов списка.

Для поддержки привязки коллекций в классе `ItemsControl` определены три ключевых свойства:

- **`ItemsSource`**

    Указывает на коллекцию, содержащую все объекты, которые будут показаны в списке

- **`DisplayMemberPath`**

    Идентифицирует свойство, которое будет применяться для создания отображаемого текста каждого элемента коллекции

- **`ItemTemplate`**

    Принимает шаблон данных, который будет использован для создания визуального представления каждого элемента. Это свойство намного мощнее, чем `DisplayMemberPath`

Здесь, возможно, возникает вопрос, какой именно тип коллекции можно поместить в свойство `ItemSource`? K счастью, практически любой. Все, что понадобится — это поддержка интерфейса `IEnumerable`, которую обеспечивают массивы, все типы коллекций и многие другие специализированные объекты, служащие оболочками для групп элементов.

Однако поддержка, получаемая от базового интерфейса `IEnumerable`, ограничена привязкой только для чтения. Для редактирования коллекции (например, вставки и удаления), как вскоре будет показано, понадобится немного более сложная инфраструктура.

##### Отображение и редактирование элементов коллекции
Рассмотрим окно, которое отображает список машин. Когда модель машины выбрана, информация о ней отображается в нижней части окна, где ее можно редактировать. (В данном примере `GridSplitter` позволяет подкорректировать место, выделенное для верхней и нижней части окна.)

Чтобы создать этот пример, необходимо начать с построения логики доступа к данным. В данном случае метод `MainWindow.GetCars` извлекает список всех машин из базы данных, используя LINQ to Entities. Для каждой записи создается объект `CarTable`, который добавляется в обобщенную коллекцию `List`. (Здесь можно использовать любую коллекцию — например, массив или слабо типизированный `ArrayList` будут работать одинаково.)

Ниже показана видоизмененная разметка окна и необходимый код для получения списка элементов:

XAML:
```xml
<Grid>
    <Grid.RowDefinitions>
        <RowDefinition Height="*"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
    </Grid.RowDefinitions>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"></RowDefinition>
            <RowDefinition Height="Auto"></RowDefinition>
        </Grid.RowDefinitions>

        <ListBox Name="lstCars" Margin="5" />

        <StackPanel Grid.Row="1" HorizontalAlignment="Right" Orientation="Horizontal" Margin="5,2,5,10">
            <Button Margin="2,0,0,0"  Padding="2" Content="Получить список машин" Click="cmdGetCar_Click"/>
            <Button Margin="2,0,0,0"  Padding="2" Content="Удалить" Click="cmdDeleteCar_Click"/>
            <Button Margin="2,0,0,0"  Padding="2" Content="Добавить" Click="cmdAddCar_Click"/>
        </StackPanel>
    </Grid>

    <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch" VerticalAlignment="Bottom" ResizeBehavior="PreviousAndNext" Height="5"/>

    <Border Grid.Row="2" Padding="7" Margin="7" Background="LightSteelBlue">
        <Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"></ColumnDefinition>
                <ColumnDefinition></ColumnDefinition>
            </Grid.ColumnDefinitions>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="*"></RowDefinition>
            </Grid.RowDefinitions>

            <TextBlock Margin="7">Марка:</TextBlock>
            <TextBox Margin="5" Grid.Column="1" Text="{Binding Path=ModelName}"></TextBox>
            <TextBlock Margin="7" Grid.Row="1">Модель:</TextBlock>
            <TextBox Margin="5" Grid.Row="1" Grid.Column="1" Text="{Binding Path=ModelNumber}"></TextBox>
            <TextBlock Margin="7" Grid.Row="2">Цена (руб):</TextBlock>
            <TextBox Margin="5" Grid.Row="2" Grid.Column="1" Text="{Binding Path=Cost}"></TextBox>
            <TextBlock Margin="7,7,7,0" Grid.Row="3">Описание:</TextBlock>
            <TextBox Margin="7" Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="2"
                        VerticalScrollBarVisibility="Visible" TextWrapping="Wrap"
                        Text="{Binding Path=Description, TargetNullValue=[Описание не предоставлено]}"></TextBox>
        </Grid>
    </Border>
</Grid>
```

C#:
```cs
public static List<CarTable> GetCars()
{
            AutoShopEntities context = new AutoShopEntities();

            return context.CarTables.Select(p => p).ToList<CarTable>();
}

private List<CarTable> cars;

private void cmdGetCar_Click(object sender, RoutedEventArgs e)
{
            cars = MainWindow.GetCars();
            lstCars.ItemsSource = cars;
}

// Обработчики удаления и добавления будут показаны ниже
private void cmdDeleteCar_Click(object sender, RoutedEventArgs e)
{

}

private void cmdAddCar_Click(object sender, RoutedEventArgs e)
{

}
```

Для корректного вывода названия модели придется переопределить метод `ToString()` сущностного класса `CarTable` находящегося в файле *AutoShopDataModel.Designer.cs* (если вы следовали моим рекомендациям при создании сущностной модели базы данных):
```cs
[EdmEntityTypeAttribute(NamespaceName="AutoShopModel", Name="CarTable")]
[Serializable()]
[DataContractAttribute(IsReference=true)]
public partial class CarTable : EntityObject
{
    public override string ToString()
    {
        return ModelName + " " + ModelNumber;
    }

...
```

Приняв решение, как будет отображаться информация в списке, можно заняться следующей проблемой — отображением подробностей текущего выбранного элемента списка в сетке, которая появляется под этим списком. С этой задачей можно справиться, реагируя на событие **`SelectionChanged`** и вручную изменяя контекст данных сетки, но есть более быстрый способ, который вообще не требует никакого кода. Нужно просто установить выражение привязки для свойства `Grid.DataContext`, которое извлечет выбранный в списке объект `Product`, как показано ниже:
```xml
<Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}">
```

Когда окно отображается в первый раз, в списке ничего не выбрано. Свойство `ListBox.SelectedItem` равно `null`, а потому `Grid.DataContext` также равно `null`, и никакой информации не появляется. Как только выбран элемент в списке, контекст данных устанавливается в соответствующий объект, и вся информация тут же отображается.

На удивление этот пример уже полностью функционален. Имеется возможность редактировать товары, перемещаться по списку и затем, вернувшись к предыдущей записи, удостовериться, что изменения были успешно зафиксированы.

Фактически, можно даже изменить значение, которое затрагивает отображаемый в списке текст. Если модифицировать наименование модели и перейти с помощью клавиши <kbd>Tab</kbd> на другой элемент управления, то соответствующая позиция в списке автоматически обновится. (Опытные разработчики оценят это преимущество, которого так не хватает приложениям Windows Forms.)

Чтобы предотвратить возможность редактирования поля, установите свойство **`IsLocked`** текстового поля в `true` или, что лучше — воспользуйтесь элементом управления, который разрешает только чтение (вроде `TextBlock`).

Разумеется, чтобы завершить этот пример с точки зрения приложения, нужно еще добавить некоторый код. Например, может понадобиться метод `UpdateProducts()`, принимающий коллекцию товаров и выполняющий соответствующие операторы. Реализация обновления базы данных была показана в предыдущей статье.

##### Вставка и удаление элементов коллекций
Одно из ограничений предыдущего примера заключается в том, что он не может отобразить изменения, внесенные в коллекцию. Он замечает измененные объекты `CarTable`, но не может обновить список в случае добавления нового элемента или удаления элемента в коде.

Например, предположим, что добавлена кнопка *Удалить*, которая выполняет следующий код:
```cs
private void cmdDeleteCar_Click(object sender, RoutedEventArgs e)
{
    cars.Remove((CarTable)lstCars.SelectedItem);
}
```

Удаленный элемент исключается из коллекции, но упорно остается видимым в привязанном списке.

Чтобы включить отслеживание изменений коллекции, необходимо использовать коллекцию, реализующую **интерфейс `INotifyCollectionChanged`**. Большинство обобщенных коллекций этого не делают, в том числе и `List<T>`, которая применяется в приведенном примере. Фактически WPF включает единственную коллекцию, реализующую `INotifyCollectionChanged` — это класс **`ObservableCollection`**.

Можно унаследовать собственную коллекцию от `ObservableCollection`, чтобы настроить по своему усмотрению ее работу, хотя это не обязательно. В данном примере достаточно заменить объект `List<CarTable>` на `ObservableCollection<CarTable>`, как показано ниже:
```cs
public static ObservableCollection<CarTable> GetCars()
{
    AutoShopEntities context = new AutoShopEntities();

    return new ObservableCollection<CarTable>(
            context.CarTables.Select(p => p).ToList<CarTable>());
}

private ObservableCollection<CarTable> cars;

private void cmdGetCar_Click(object sender, RoutedEventArgs e)
{
    cars = MainWindow.GetCars();
    lstCars.ItemsSource = cars;
}

private void cmdDeleteCar_Click(object sender, RoutedEventArgs e)
{
    cars.Remove((CarTable)lstCars.SelectedItem);
}
```

Теперь, если программно удалить или добавить элемент в коллекцию, список будет соответствующим образом обновлен. Естественно, по-прежнему придется создавать код доступа к данным, который происходит перед модификацией коллекции — например, код, удаляющий запись о товаре из лежащей в основе базы данных.

#### Проверка достоверности
Еще одной ключевой составляющей любого сценария привязки данных является ***проверка достоверности***. Другими словами, это логика, перехватывающая некорректные значения и отклоняющая их.

Проверку достоверности можно встраивать непосредственно в элементы управления (например, реагируя на ввод в текстовом поле и отклоняя недопустимые символы), но такой низкоуровневый подход ограничивает гибкость.

К счастью, WPF предоставляет средство проверки достоверности, работающее подобно системе привязки данных. Проверка достоверности предлагает два дополнительных варианта выбора для перехвата неверных значений:

- *Можно генерировать ошибки в своем объекте данных*. Чтобы уведомить WPF об ошибке, просто сгенерируйте исключение в процедуре установки свойства. Обычно WPF игнорирует любые исключения, которые возбуждаются при установке свойств, но можно сконфигурировать его для отображения более полезных сведений. Другой выбор — реализовать интерфейс **`IDataErrorInfo`** в классе данных, что даст возможность обозначать ошибки, не генерируя исключений.

- *Можно определить проверку достоверности на уровне привязки*. Это обеспечивает гибкость для использования одной и той же проверки достоверности, независимо от элемента управления вводом. Еще лучше, что поскольку проверка достоверности определяется в отдельном классе, можно легко повторно использовать ее с множеством привязок, которые имеют дело с однотипными данными.

Обычно первый подход применяется, если объекты данных уже обладают встроенной логикой проверки достоверности в своих процедурах установки свойств, и нужно воспользоваться преимуществами этой логики. Второй подход используется, когда логика проверки достоверности реализуется впервые, и ее необходимо многократно применять в разных контекстах с различными элементами управления.

Однако некоторые разработчики пользуются обоими приемами. Они применяют проверку достоверности в объекте данных для защиты от небольшого набора фундаментальных ошибок и реализуют проверку достоверности привязки для перехвата более широкого диапазона ошибок пользовательского ввода.

Проверка достоверности применяется только тогда, когда значение из целевого элемента используется для обновления источника. Другими словами, в ситуациях с привязкой `TwoWay` или `OneWayToSource`.

##### Проверка достоверности в объекте данных
Некоторые разработчики встраивают проверку ошибок непосредственно в свои объекты данных. Например, ниже приведена модифицированная версия свойства `CarTable.Cost`, которая отклоняет отрицательные числа:
```cs
public Nullable<global::System.Double> Cost
{
    get
    {
        return _Cost;
    }
    set
    {
        if (value < 0)
            throw new ArgumentException("Стоимость не может быть отрицательной");
        else
        {
            OnCostChanging(value);
            ReportPropertyChanging("Cost");
            _Cost = StructuralObject.SetValidValue(value);
            ReportPropertyChanged("Cost");
            OnCostChanged();
        }
    }
}
```

Логика проверки достоверности, показанная в предыдущем примере, предотвращает отрицательные значения для цены, но не дает пользователю никакой информации о причинах проблемы. Как уже известно, WPF молча игнорирует ошибки привязки данных, которые происходят при установке и чтении свойств. В этом случае некорректное значение останется в текстовом поле — оно просто не появится в привязанном объекте данных. Чтобы изменить эту ситуацию, понадобится помощь класса `ExceptionValidationRule`, который рассматривается ниже.

##### Класс ExceptionValidationRule
Класс `ExceptionValidationRule` — это предварительно построенное правило проверки достоверности, которое заставляет WPF сообщать обо всех исключениях. Чтобы использовать `ExceptionValidationRule`, его понадобится добавить в коллекцию `Binding.ValidationRules`, как показано ниже:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1">
      <TextBox.Text>
           <Binding Path="Cost">
                 <Binding.ValidationRules>
                       <ExceptionValidationRule/>
                 </Binding.ValidationRules>
           </Binding>
      </TextBox.Text>
</TextBox>
```

Итак, что же произойдет, если проверка достоверности не прошла? Ошибки проверки достоверности записываются с использованием присоединенных свойств класса **`System.Windows.Controls.Validation`**. Для каждого нарушенного правила проверки достоверности WPF предпринимает описанные ниже шаги:

- Устанавливает присоединенное свойство **`Validation.HasError`** в `true` нa связанном элементе (в данном случае — элементе управления `TextBox`).

- Создает объект **`ValidationError`** с подробностями об ошибке (возвращенными из метода `ValidationRule.Validate()`) и добавляет его в присоединенную коллекцию `Validation.Errors`.

- Если свойство `Binding.NotifyOnValidationError` установлено в `true`, WPF инициирует в элементе событие `Validation.Error`.

В случае возникновения ошибки визуальное представление элемента управления также изменяется. WPF автоматически переключает шаблон, используемый элементом управления, когда его свойство `Validation.HasError` принимает значение `true`, на шаблон, определенный в свойстве `Validation.ErrorTemplate`. В текстовом поле новый шаблон окрашивает контур рамки в красный цвет.

Для корректной работы примера потребуется также отключить вызов исключений среды CLR (*Debug* --> *Exceptions...*).

В большинстве случаев возникнет желание как-то усилить индикацию ошибки и выдать определенную информацию об ошибке, послужившей причиной проблемы. Можно использовать код, обрабатывающий событие `Error`, или же применить собственный шаблон элемента управления, который обеспечивает другую визуальную индикацию.

Итак, в выражении привязки задайте свойство `NotifyOnValidationError` в `True`, которое будет создавать событие `Validation.Error`:
```xml
<Binding Path="Cost" NotifyOnValidationError="True">
   ...
```

Событие `Error` является маршрутизируемым и использует пузырьковое распространение, так что его можно обработать для многих элементов управления, присоединив обработчик событий к родительскому контейнеру, как показано ниже:
```xml
<Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}"
            Validation.Error="validationError">
...
```

Далее представлен код, реагирующий на это событие и отображающий окно сообщения с информацией об ошибке. (Более мягкий вариант реакции может предусматривать отображение всплывающей подсказки либо выдачу сообщения об ошибке где-то в другом месте окна.)

```cs
private void validationError(object sender, ValidationErrorEventArgs e)
{
     if (e.Action == ValidationErrorEventAction.Added)
     {
           MessageBox.Show(e.Error.ErrorContent.ToString());
     }
}
```

Свойство `ValidationErrorEventArgs.Error` предоставляет объект `ValidationError`, соединяющий воедино несколько полезных деталей, в том числе исключение, вызвавшее проблему (`Exception`), нарушенное правило проверки достоверности (`ValidationRule`), ассоциированный объект `Binding` (`BindinglnError`) и любую специальную информацию, возвращенную объектом `ValidationRule` (`ErrorContent`).

Теперь при возникновении ошибки достоверности будет показано модальное окно с предупреждающим сообщением.

##### Специальные правила проверки достоверности
Подход с применением специального правила проверки достоверности подобен использованию специального конвертера. В этом случае определяется класс-наследник `ValidationRule` (из пространства имен `System.Windows.Controls`) и его метод `Validate()` переопределяется для выполнения требуемой проверки достоверности. При необходимости можно добавить свойства, принимающие другие детали, которые влияют на проверку достоверности (например, правило, определяющее, что текст может включать свойство `CaseSensitive` булевского типа).

Ниже приведен полный код правила проверки достоверности, ограничивающего значения некоторым диапазоном. По умолчанию минимум устанавливается в 100000, а максимум — в наибольшее число, которое умещается в тип данных `Double`:
```cs
public class PriceRule : ValidationRule
{
    private double min = 100000;
    private double max = Double.MaxValue;

    public double Min
    {
        get { return min; }
        set { min = value; }
    }

    public double Max
    {
        get { return max; }
        set { max = value; }
    }


    public override ValidationResult Validate(object value, System.Globalization.CultureInfo ci)
    {
        double price = 0;

        try
        {
            price = Double.Parse((string)value);
        }
        catch
        {
            return new ValidationResult(false, "Недопустимые символы.");
        }

        if ((price < Min) || (price > Max))
        {
            return new ValidationResult(false,
                "Стоимость не входит в диапазон " + Min + " до " + Max + ".");
        }
        else
        {
            return new ValidationResult(true, null);
        }
    }
}
```

Как только правило проверки достоверности завершено, его можно применить к элементу, добавив в коллекцию `Binding.ValidationRules`. Ниже показан пример использования правила `PriceRule` с установкой значения `Maximum` в 20.000.000:
```xml
<Window x:Class="DataBinding.MainWindow"
        xmlns:myns="clr-namespace:DataBinding"
        ...
        >

   ...

<TextBox.Text>
    <Binding Path="Cost" NotifyOnValidationError="True">
            <Binding.ValidationRules>
                    <myns:PriceRule Max="20000000"/>
                    <ExceptionValidationRule/>
            </Binding.ValidationRules>
    </Binding>
</TextBox.Text>
```

Часто отдельный объект правила проверки достоверности будет определяться для каждого элемента, использующего тот же самый тип правила. Это объясняется тем, что может понадобиться настраивать свойства проверки достоверности (такие как минимальное и максимальное значения в `PriceRule`) для разных элементов индивидуально.

Если известно, что нужно использовать абсолютно одинаковые правила проверки достоверности для более чем одной привязки, можно определить правило в виде ресурса и просто указывать на него в каждой привязке с помощью расширения разметки `StaticResource`.

Коллекция `Binding.ValidationRules` может принимать неограниченное количество правил. Когда значение фиксируется в источнике, WPF проверяет каждое правило проверки достоверности по порядку. (Вспомните, что значение в текстовом поле фиксируется в источнике, когда текстовое поле теряет фокус, если только в свойстве `UpdateSourceTrigger` не указано иначе.) Если все проверки достоверности прошли успешно, то WPF затем вызывает конвертер (если он есть) и применяет значение к источнику.

В случае проверки достоверности с помощью `PriceRule` поведение будет таким же, как и при использовании `ExceptionValidationRule` — текстовое поле помечается красным, устанавливаются свойства `HasError` и `Error`, генерируется событие `Error`. Чтобы снабдить пользователя каким-нибудь полезным откликом, потребуется добавить немного кода для настройки `ErrorTemplate`.

##### Отображение отличающегося индикатора ошибки
Чтобы получить максимальную отдачу от проверки достоверности WPF, наверняка захочется создать собственный шаблон ошибок, который будет помечать ошибки соответствующим образом. На первый взгляд это может показаться довольно низкоуровневым способом сообщать об ошибках — в конце концов, стандартные шаблоны элементов управления предоставляют возможность настройки композиции элемента за считанные минуты. Однако шаблон ошибок не похож на обычный шаблон элемента управления.

Шаблоны ошибок используют ***декоративный слой*** (***adorner layer***), который является слоем рисования, существующим прямо над обычным содержимым окна. Используя этот слой, можно добавлять визуальные украшения для сигнализации об ошибке, не подменяя шаблона элемента управления и не изменяя компоновки окна.

Стандартный шаблон ошибок для текстового поля работает, добавляя элемент `Border` красного цвета, который "парит" прямо над соответствующим текстовым полем (поле под ним остается неизменным).

Шаблон ошибок можно использовать для добавления таких деталей, как изображения, текст либо графика иного рода, привлекающая внимание к проблеме. Ниже показан пример. Он определяет шаблон ошибки, использующий зеленую рамку, и добавляет звездочку рядом с элементом управления с неправильным вводом:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1">
    <TextBox.Text>
        <Binding Path="Cost" NotifyOnValidationError="True">
            <Binding.ValidationRules>
                <myns:PriceRule Max="20000000"/>
                <ExceptionValidationRule/>
            </Binding.ValidationRules>
        </Binding>
    </TextBox.Text>
    <TextBox.Style>
        <Style TargetType="{x:Type TextBox}">
            <Setter Property="Validation.ErrorTemplate">
                <Setter.Value>
                    <ControlTemplate>
                        <DockPanel LastChildFill="True">
                            <TextBlock DockPanel.Dock="Right" Foreground="Red" FontSize="14" FontWeight="Bold"
                                        Text="*"/>
                            <Border BorderBrush="Green" BorderThickness="1">
                                <AdornedElementPlaceholder Name="adornerPlaceholder"/>
                            </Border>
                        </DockPanel>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                <Trigger Property="Validation.HasError" Value="True">
                    <Setter Property="Foreground" Value="Red"/>
                </Trigger>
            </Style.Triggers>
        </Style>
    </TextBox.Style>
</TextBox>
```

Функционирование этого приема обеспечивается **`AdornedElementPlaceholder`**. Он представляет сам элемент управления, который существует в слое элементов. Используя `AdornedElementPlaceholder`, можно упорядочить содержимое относительно лежащего ниже текстового поля.

В результате рамка в этом примере размещается прямо поверх текстового поля, независимо от его размеров. Звездочка в этом примере помещается сразу справа.

Лучше всего то, что содержимое нового шаблона ошибки накладывается поверх существующего содержимого, не вызывая никаких изменений в компоновке исходного окна. (Фактически неосмотрительное добавление в декоративный слой слишком большого объема содержимого приводит к перекрытию прочих частей окна.)

Если нужно, чтобы шаблон ошибок появлялся над элементом (а не где-то возле него), можно поместить и содержимое, и `AdornerElementPlaceholder` в одну ячейку `Grid`. В качестве альтернативы можно вообще опустить `AdornerElementPlaceholder`, но тогда утрачивается возможность точного позиционирования содержимого по отношению к лежащему ниже элементу.

Чтобы показать дополнительную информацию по ошибке, понадобится извлечь её с помощью привязки данных. Хорошим подходом может быть такой: взять содержимое первой ошибки и использовать его для текста всплывающей подсказки индикатора ошибки. Ниже приведен шаблон, который именно это и делает:
```xml
<DockPanel LastChildFill="True">
<TextBlock DockPanel.Dock="Right" Foreground="Red" FontSize="14" FontWeight="Bold"
            ToolTip="{Binding ElementName=adornerPlaceholder,
                    Path=AdornedElement.(Validation.Errors)[0].ErrorContent}"
Text="*"/>
...
```

Теперь при перемещении курсора мыши над звездочкой будет отображаться сообщение об ошибке.

В качестве альтернативы можно отображать сообщение об ошибке в `ToolTip` из `Border` или самого `TextBox`, так что сообщение об ошибке появится, когда пользователь поместит курсор мыши над любой частью элемента управления. Этот трюк можно выполнить без помощи специального шаблона ошибок; все, что понадобится — это триггер на элементе управления `TextBox`, который отреагирует на присваивание `Validation.HasError` значения `true` и применит `ToolTip` с сообщением об ошибке. Вот пример:
```xml
...

<Style.Triggers>
    <Trigger Property="Validation.HasError" Value="True">
        <Setter Property="Foreground" Value="Red"/>
        <Setter Property="ToolTip"
                Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}"/>
    </Trigger>
</Style.Triggers>
```

##### Получение списка ошибок
В определенный момент может потребоваться список отложенных ошибок в текущем окне (или заданном контейнере из этого окна). Эта задача довольно проста, все, что нужно сделать — это пройтись по дереву элементов и проверить свойство `Validation.HasError` каждого элемента.

Код следующей процедуры демонстрирует пример, который целенаправленно ищет недопустимые данные в объектах `TextBox`. В нем используется рекурсия для прохода по всей иерархии элементов. При этом информация об ошибках накапливается в единственном сообщении, которое отображается пользователю:
```cs
private void cmdGetExceptions_Click(object sender, RoutedEventArgs e)
{
    StringBuilder sb = new StringBuilder();
    GetErrors(sb, gridCarDetails);
    string message = sb.ToString();
    if (message != "") MessageBox.Show(message);
}

private void GetErrors(StringBuilder sb, DependencyObject obj)
{
    foreach (object child in LogicalTreeHelper.GetChildren(obj))
    {
        TextBox element = child as TextBox;
        if (element == null) continue;

        if (Validation.GetHasError(element))
        {
            sb.Append(element.Text + " найдена ошибка:\r\n");
            foreach (ValidationError error in Validation.GetErrors(element))
            {
                sb.Append("  " + error.ErrorContent.ToString());
                sb.Append("\r\n");
            }
        }

        GetErrors(sb, element);
    }
}
```

#### Поставщики данных
В большинстве продемонстрированных до сих пор примеров источник данных верхнего уровня применялся за счет программной установки свойства `DataContext` простого элемента или свойства `ItemsSource` списочного элемента. Вообще это наиболее гибкий подход, особенно, если объект данных конструируется другим классом (таким как сущностный класс `CarTable`). Однако доступны и другие варианты.

Один из возможных приемов состоит в определении объекта данных как ресурса окна (или другого контейнера). Это хорошо работает, если есть возможность сконструировать объект декларативно, но имеет гораздо меньше смысла, если во время выполнения нужно подключаться к внешнему хранилищу данных (подобному базе данных).

***Поставщики данных*** дают возможность привязаться непосредственно к объекту, который определен в разделе ресурсов разметки. Однако вместо привязки к самому объекту данных осуществляется привязка к поставщику данных, который может извлечь или сконструировать этот объект. Такой подход имеет смысл в случае полноценного поставщика данных, обладающего способностью инициировать события в ответ на исключения и предоставляющего свойства, которые позволяют конфигурировать другие детали операции.

К сожалению, поставщики данных, которые включены в WPF, пока не отвечают этому стандарту. Они слишком ограничены, чтобы возиться с ними в ситуациях с внешними данными (например, при извлечении информации из базы данных или файла). Они могут иметь смысл в более простых сценариях, например, поставщик данных мог бы использоваться для соединения вместе нескольких элементов управления, которые передают входную информацию в класс, вычисляющий результат. Однако в данной ситуации от них относительно мало толку, помимо возможности сократить код обработки событий в пользу кода разметки.

Все поставщики данных унаследованы от класса **`System.Windows.Data.DataSourceProvider`**. В настоящее время WPF предлагает только два поставщика данных:

- **`ObjectDataProvider`**

    Получает информацию, вызывая метод другого класса.

- **`XmlDataProvider`**

    Получает информацию непосредственно из файла XML.

Целью обоих этих объектов является возможность создать экземпляр объекта данных в XAML-разметке, не прибегая к коду обработки событий.

##### ObjectDataProvider
`ObjectDataProvider` позволяет получать информацию из другого класса в приложении. Он добавляет следующие средства:

- Может создать необходимый объект и передать параметры конструктору.

- Может вызвать метод на этом объекте и передать ему параметры метода.

- Может создать объект данных асинхронно. (Другими словами, он может подождать, пока будет создано окно, и затем выполнить свою работу в фоновом режиме.)

Например, вот как выглядит базовый поставщик `ObjectDataProvider`, который создает экземпляр класса `CarTable`, вызывает его метод `GetCars()`, который потребуется добавить в этот сущностный класс и делает данные доступными остальной части окна:

XAML:
```xml
<Window.Resources>
        <ObjectDataProvider x:Key="CarsListProvider" ObjectType="{x:Type myns:CarTable}" MethodName="GetCars"/>
</Window.Resources>
```

C#:
```cs
// В классе CarTable (используем LINQ to Entities)
public static ObservableCollection<CarTable> GetCars()
{
     AutoShopEntities context = new AutoShopEntities();

     return new ObservableCollection<CarTable>(
               context.CarTables.Select(p => p).ToList<CarTable>());
}
```

Теперь можно создать привязку, которая получает источник из `ObjectDataProvider`:
```xml
<ListBox Name="lstCars" Margin="5" ItemsSource="{Binding Source={StaticResource CarsListProvider}}"/>
```

Этот дескриптор выглядит так, будто привязывается к `ObjectDataProvider`, но `ObjectDataProvider` достаточно интеллектуален, чтобы понять, что на самом деле требуется привязка к списку машин, возвращаемому методом `GetCars()`.

Как и все поставщики данных, `ObjectDataProvider` предназначен для извлечения данных, но не обновления их. Другими словами, нет способа заставить `ObjectDataProvider` вызвать другой метод класса `CarTable`, чтобы инициировать обновление. Это лишь один пример недостаточной зрелости классов поставщиков данных WPF по сравнению с другими реализациями в других платформах, таких как элементы управления источниками данных в ASP.NET.

##### Обработка ошибок
В нынешнем виде рассматриваемый пример имеет огромный недостаток. Анализатор XAML создает окно и вызывает метод `GetCars()`, чтобы установить привязку. Все идет гладко, если метод `GetCars()` возвращает нужные данные, но результат не так хорош, если возникает необработанное исключение (например, база данных слишком занята или недоступна). В этот момент исключение распространяется пузырьком вверх от вызова `InitializeComponent()` в конструкторе окна. Код, отображающий окно, должен перехватить эту ошибку, что концептуально запутано. И не существует способа продолжить работу и показать окно — даже если перехватить исключение в конструкторе, остальная часть окна не будет инициализирована правильно.

К сожалению, нет простого способа решить эту проблему. Класс `ObjectDataProvider` включает свойство **`IsInitialLoadEnabled`**, которое можно установить в `false`, чтобы предотвратить вызов `GetCars()` при первоначальном создании окна. Тогда можно будет вызвать `Refresh()` позднее, чтобы инициировать вызов. Однако при использовании такого подхода выражение привязки даст сбой, потому что список не сможет извлечь свой источник данных. (Это отличается от большинства ошибок привязки данных, которые молча проглатываются, не инициируя исключений.)

Так каково же решение? Можно сконструировать `ObjectDataProvider` программно, хотя при этом теряются преимущества от декларативной привязки, что вероятно является главной причиной применения `ObjectDataProvider`. Другое решение состоит в конфигурировании `ObjectDataProvider` для асинхронного выполнения работы, как описано в следующем разделе. В этой ситуации исключения вызывают молчаливый сбой (хотя трассировочное сообщение все равно будет выдано в окно *Debug* (*Отладка*) с детальным описанием ошибки).

##### Асинхронная поддержка
Большинство разработчиков сочтут, что для применения `ObjectDataProvider` есть совсем немного причин. Обычно легче просто привязаться непосредственно к объекту данных и добавить код, который вызовет класс, опрашивающий данные (такой как `CarTable`). Однако есть одна причина, по которой предпочтение отдается `ObjectDataProvider` — для получения преимуществ асинхронного запроса данных:
```xml
<ObjectDataProvider IsAsynchronous="True" ...
```

Разметка обманчиво проста. До тех пор, пока свойство `ObjectDataProvider.IsAsynchronous` установлено в `true`, поставщик `ObjectDataProvider` выполняет свою работу в фоновом потоке. В это время интерфейс ничем не связан. Как только объект данных сконструирован и возвращен из метода, `ObjectDataProvider` делает его доступным для всех привязанных элементов.

Даже не используя `ObjectDataProvider`, все равно можно запустить код доступа к данным асинхронно. Трюк состоит в применении поддержки многопоточных приложений в WPF. В этом поможет компонент `BackgroundWorker`. При использовании `BackgroundWorker` появляется дополнительная поддержка отмены и отображения хода работ. Тем не менее, добавление `BackgroundWorker` в пользовательский интерфейс требует больше работы, чем простая установка свойства `ObjectDataProvider.IsAsynchronous`.

##### XmlDataProvider
Поставщик `XmlDataProvider` предлагает быстрый и простой способ извлечения XML-данных из отдельного файла, местоположения в Интернете или ресурса приложения, а также обеспечения их доступности элементам приложения.

`XmlDataProvider` спроектирован как доступный только для чтения (другими словами, он не предусматривает возможности фиксировать изменения) и не умеет работать с XML-данными, полученными из других ресурсов (таких как запись базы данных, сообщение веб-службы и т.п.). В результате `XmlDataProvider` является исключительно специфическим средством.

Чтобы использовать `XmlDataProvider`, он должен быть определен и ориентирован на нужный файл за счет установки свойства `Source`:
```xml
<XmlDataProvider x:Key="CarListXmlProvider" XPath="/Cars" Source="XmlDataProviderFile.xml" />
```

Можно также установить свойство `Source` программно (что важно, если имя файла заранее не известно). По умолчанию `XmlDataProvider` загружает XML-содержимое асинхронно, если только явно не установить свойство `XmlDataProvider.IsAsynchronous` в `false`.

Ниже приведен фрагмент простого XML-файла, который используется в рассматриваемом примере. Он содержит в себе целый документ в элементе `Cars` верхнего уровня и помещает каждую машину в отдельный элемент `Car` (полный код вы можете найти в исходном коде для примеров):
```xml
<?xml version="1.0" encoding="utf-8"?>
<Cars>
  <Car>
    <ID>1</ID>
    <CategoryID>2</CategoryID>
    <CategoryName>Средний-класс</CategoryName>
    <ModelName>Alfa Romeo</ModelName>
    <ModelNumber>145</ModelNumber>
    <Cost>230000</Cost>
    <Description>В 2000 году выпущена спецсерия Alfa Romeo 145 – «Edizione»...</Description>
    <ImageCar>images/alfaromeo-145.jpg</ImageCar>
  </Car>
  <Car>
    <ID>2</ID>
    <CategoryID>3</CategoryID>
    <CategoryName>Бизнес-класс</CategoryName>
    <ModelName>Alfa Romeo</ModelName>
    <ModelNumber>Spider</ModelNumber>
    <Cost>650000</Cost>
    <Description>В серийное оснащение всех Alfa Romeo Spider ...</Description>
    <ImageCar>images/alfaromeo-spider.jpg</ImageCar>
  </Car>
  ...
```

Для извлечения информации из XML-разметки используются расширения **`XPath`** — мощного стандарта, позволяющего извлекать только интересующие части документа. `XPath` использует нотацию путей файловой системы. Например, путь `/` идентифицирует корень XML-документа, a `/Cars` — корневой элемент по имени `<Cars>`.

При работе с `XmlDataProvider` используется свойство `Binding.XPath` вместо свойства `Binding.Path`. Это позволяет погружаться в XML-разметку настолько глубоко, насколько нужно.
```xml
...
<TextBox Margin="5" Grid.Column="1" Text="{Binding XPath=ModelName}"></TextBox>
<TextBlock Margin="7" Grid.Row="1">Модель:</TextBlock>
<TextBox Margin="5" Grid.Row="1" Grid.Column="1" Text="{Binding XPath=ModelNumber}"></TextBox>
...
```

После внесения этих изменений получается пример на основе XML, который почти идентичен тому, что использует привязку к базе данных через Entity Framework, который рассматривался до сих пор. Единственное отличие в том, что все данные трактуются как обычный текст. Чтобы преобразовать их в другой тип данных или в другое представление, потребуется конвертер значений.

#### Привязка данных и LINQ
В WPF поддерживается язык интегрированных запросов (Language Integrated Query — LINQ), предлагающий синтаксис запросов общего назначения, который работает с широким разнообразием источников данных и тесно интегрирован в язык C#.

Язык LINQ работает с любым источником, для которого имеется соответствующий поставщик LINQ. Поддержка, включенная в .NET, дает возможность использовать одинаково структурированные запросы LINQ для извлечения данных из коллекции, находящейся в памяти, из файла XML либо из базы данных SQL Server. Как и другие языки запросов, LINQ позволяет фильтровать, сортировать и трансформировать извлекаемые данные.

Давайте предположим, что нужно добавить в созданное ранее приложение функциональность сортировки коллекции машин по стоимости. Ниже я приведу развернутый пример, который включает в себя все то, что мы изучили в предыдущих статьях с добавлением новой функциональности посредством LINQ (в проект потребуется добавить окно *AddWindow.xaml*):

*Вспомогательные методы в сущностном классе CarTable (файл AutoShopDataModel.Designer.cs)*:
```cs
// Вспомогательные методы в сущностном классе CarTable (файл AutoShopDataModel.Designer.cs)
public partial class CarTable : EntityObject
{
    // Свойство, содержащее коллекцию объектов CarTable хранящихся в базе данных
    public static ObservableCollection<CarTable> Cars
    {
        get
        {
            AutoShopEntities context = new AutoShopEntities();

            return new ObservableCollection<CarTable>(
                    context.CarTables.Select(s => s).ToList());
        }
    }

    public override string ToString()
    {
        return ModelName + " " + ModelNumber;
    }

    ...
```

*MainWindow.xaml*:
```xml
<!-- MainWindow.xaml -->

<Window x:Class="DataBinding.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:databinding="clr-namespace:DataBinding"
        Title="База данных AutoShop" Height="650" Width="440">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="*"></RowDefinition>
            <RowDefinition Height="Auto"></RowDefinition>
            <RowDefinition Height="*"></RowDefinition>
        </Grid.RowDefinitions>

        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="*"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
                <RowDefinition Height="Auto"></RowDefinition>
            </Grid.RowDefinitions>

            <ListBox Name="lstCars" Margin="5" />

            <StackPanel Grid.Row="1" HorizontalAlignment="Right" Orientation="Horizontal" Margin="5,2,5,10">
                <Button Margin="2,0,0,0"  Padding="2" Content="Удалить" Click="removeCar_Click"/>
                <Button Margin="2,0,0,0"  Padding="2" Content="Добавить" Click="addCar_Click"/>
                <Button Margin="2,0,0,0"  Padding="2" Content="Ошибки" Click="getErrors_Click"/>
            </StackPanel>
            <StackPanel Grid.Row="2" HorizontalAlignment="Right" Orientation="Horizontal" Margin="5,2,5,10">
                <TextBlock>Max стоимость: </TextBlock>
                <TextBox x:Name="txbMaxCost" Width="80" HorizontalContentAlignment="Center" Margin="8,0,8,0"/>
                <Button Content="Получить" Click="getCarsMaxCost_Click"/>
            </StackPanel>
        </Grid>

        <GridSplitter Grid.Row="1" HorizontalAlignment="Stretch" VerticalAlignment="Bottom" ResizeBehavior="PreviousAndNext" Height="5"/>

        <Border Grid.Row="2" Padding="7" Margin="7" Background="LightSteelBlue">
            <Border.Resources>
                <Style TargetType="{x:Type TextBox}">
                    <Setter Property="Validation.ErrorTemplate">
                        <Setter.Value>
                            <ControlTemplate>
                                <DockPanel LastChildFill="True">
                                    <TextBlock DockPanel.Dock="Right" Foreground="Red" FontSize="16" FontWeight="Bold" Text="X"/>
                                    <Border BorderBrush="Green" BorderThickness="1">
                                        <AdornedElementPlaceholder Name="adorner"/>
                                    </Border>
                                </DockPanel>
                            </ControlTemplate>
                        </Setter.Value>
                    </Setter>
                    <Style.Triggers>
                        <Trigger Property="Validation.HasError" Value="True">
                            <Setter Property="Foreground" Value="Red"/>
                            <Setter Property="ToolTip"
                                    Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}"/>
                        </Trigger>
                    </Style.Triggers>
                </Style>
            </Border.Resources>
            <Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"></ColumnDefinition>
                    <ColumnDefinition></ColumnDefinition>
                </Grid.ColumnDefinitions>
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"></RowDefinition>
                    <RowDefinition Height="Auto"></RowDefinition>
                    <RowDefinition Height="Auto"></RowDefinition>
                    <RowDefinition Height="Auto"></RowDefinition>
                    <RowDefinition Height="*"></RowDefinition>
                </Grid.RowDefinitions>

                <TextBlock Margin="7">Марка:</TextBlock>
                <TextBox Margin="5" Grid.Column="1" LostFocus="textChange_Event">
                    <TextBox.Text>
                        <Binding Path="ModelName" UpdateSourceTrigger="PropertyChanged">
                            <Binding.ValidationRules>
                                <databinding:EmptyRule></databinding:EmptyRule>
                            </Binding.ValidationRules>
                        </Binding>
                    </TextBox.Text>
                </TextBox>
                <TextBlock Margin="7" Grid.Row="1">Модель:</TextBlock>
                <TextBox Margin="5" Grid.Row="1" Grid.Column="1" LostFocus="textChange_Event">
                    <TextBox.Text>
                        <Binding Path="ModelNumber" UpdateSourceTrigger="PropertyChanged">
                            <Binding.ValidationRules>
                                <databinding:EmptyRule></databinding:EmptyRule>
                            </Binding.ValidationRules>
                        </Binding>
                    </TextBox.Text>
                </TextBox>
                <TextBlock Margin="7" Grid.Row="2">Цена (руб):</TextBlock>
                <TextBox Margin="5" Grid.Row="2" Grid.Column="1"
                         Text="{Binding Cost, ValidatesOnExceptions=True}"
                         LostFocus="textChange_Event"></TextBox>
                <TextBlock Margin="7,7,7,0" Grid.Row="3">Описание:</TextBlock>
                <TextBox Margin="7" Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="2"
                         VerticalScrollBarVisibility="Visible" TextWrapping="Wrap"
                         Text="{Binding Path=Description, TargetNullValue=Описание не доступно}" LostFocus="textChange_Event"/>
            </Grid>
        </Border>
    </Grid>
</Window>
```

*MainWindow.xaml.cs*:
```cs
// MainWindow.xaml.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.Text;
using System.Windows;
using System.Windows.Data;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Controls;
using System.Collections.ObjectModel;

namespace DataBinding
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            lstCars.ItemsSource = CarTable.Cars;
        }

        // Обновляем список, соответствующий максимальной введенной стоимости
        private void getCarsMaxCost_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                Double d = Double.Parse(txbMaxCost.Text);
                AutoShopEntities context = new AutoShopEntities();

                // Используем LINQ
                lstCars.ItemsSource = new ObservableCollection<CarTable>(
                    context.CarTables.Where(s => s.Cost <= d).Select(p => p));
            }
            catch
            {
            }
        }

        // Удалить запись из списка используя LINQ (без удаления из базы данных)
        private void removeCar_Click(object sender, RoutedEventArgs e)
        {
            ((ObservableCollection<CarTable>)lstCars.ItemsSource).Remove((CarTable)lstCars.SelectedItem);
        }

        // Добавить запись в коллекцию
        private void addCar_Click(object sender, RoutedEventArgs e)
        {
            AddWindow awin = new AddWindow();
            awin.ShowDialog();
            if (awin.AddWinCarTable != null)
            {
                ((ObservableCollection<CarTable>)lstCars.ItemsSource).Add(awin.AddWinCarTable);
            }
        }

        // Запись данных в базу при редактировании полей (LINQ to Entities)
        private void textChange_Event(object sender, RoutedEventArgs e)
        {
            CarTable ct = (CarTable)gridCarDetails.DataContext;

            // Используем LINQ to Entities для обновления базы данных
            AutoShopEntities context = new AutoShopEntities();

            CarTable ct1 = context.CarTables
                                  .Where(p => p.ID == ct.ID)
                                  .Single<CarTable>();

            ct1.ModelName = ct.ModelName;
            ct1.ModelNumber = ct.ModelNumber;
            ct1.Cost = ct.Cost;
            ct1.Description = ct.Description;

            context.SaveChanges();
        }

        // Получение списка ошибок
        private void getErrors_Click(object sender, RoutedEventArgs e)
        {
            StringBuilder sb = new StringBuilder();
            GetErrors(sb, gridCarDetails);
            string message = sb.ToString();
            if (message != "") MessageBox.Show(message);
        }

        private void GetErrors(StringBuilder sb, DependencyObject obj)
        {
            foreach (object child in LogicalTreeHelper.GetChildren(obj))
            {
                TextBox element = child as TextBox;
                if (element == null) continue;

                if (Validation.GetHasError(element))
                {
                    sb.Append(element.Text + " найдена ошибка:\r\n");
                    foreach (ValidationError error in Validation.GetErrors(element))
                    {
                        sb.Append("  " + error.ErrorContent.ToString());
                        sb.Append("\r\n");
                    }
                }

                GetErrors(sb, element);
            }
        }

    }

    // Специальное правило проверки достоверности полей ModelName и ModelNumber
    public class EmptyRule : ValidationRule
    {
        public override ValidationResult Validate(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (((string)value).Length == 0)
                return new ValidationResult(false, "Пустое значение поля");

            return new ValidationResult(true, null);
        }
    }
}
```

*AddWindow.xaml*:
```xml
<!-- AddWindow.xaml -->

<Window x:Class="DataBinding.AddWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="AddWindow" Height="420" Width="360" WindowStyle="None">
    <Grid Background="LightSteelBlue">
        <Grid.ColumnDefinitions>
            <ColumnDefinition/>
            <ColumnDefinition/>
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid.Resources>
            <Style TargetType="{x:Type TextBox}">
                <Setter Property="VerticalContentAlignment" Value="Center"/>
                <Setter Property="Margin" Value="10,5,20,5"/>
            </Style>
            <Style TargetType="{x:Type TextBlock}">
                <Setter Property="VerticalAlignment" Value="Center"/>
                <Setter Property="Margin" Value="10,5,5,5"/>
            </Style>
        </Grid.Resources>
        <TextBlock Text="Id"/><TextBox x:Name="id" Grid.Column="1"/>
        <TextBlock Text="ModelName" Grid.Row="1"/><TextBox x:Name="ModelName" Grid.Column="1" Grid.Row="1"/>
        <TextBlock Text="ModelNumber" Grid.Row="2"/><TextBox x:Name="ModelNumber" Grid.Column="1" Grid.Row="2"/>
        <TextBlock Text="CategoryId" Grid.Row="3"/><TextBox x:Name="CategoryId" Grid.Column="1" Grid.Row="3"/>
        <TextBlock Text="CategoryName" Grid.Row="4"/><TextBox x:Name="CategoryName" Grid.Column="1" Grid.Row="4"/>
        <TextBlock Text="Cost" Grid.Row="5"/><TextBox x:Name="Cost" Grid.Column="1" Grid.Row="5" />
        <TextBlock Text="ImageCar" Grid.Row="6"/><TextBox x:Name="ImageCar" Grid.Column="1" Grid.Row="6"/>
        <TextBlock Text="Description" Grid.Row="7"/><TextBox x:Name="Description" Grid.Column="1" Grid.Row="7" 
                                                             VerticalScrollBarVisibility="Auto" TextWrapping="Wrap" VerticalContentAlignment="Top"/>
        <StackPanel Grid.Row="8" Orientation="Horizontal" HorizontalAlignment="Center" Grid.ColumnSpan="2">
            <Button Margin="8,6" Padding="3" Content="Добавить" Click="Add_Click"/>
            <Button Margin="0,6" Padding="3" Content="Отмена" Click="Cancel_Click"/>
        </StackPanel>
    </Grid>
</Window>
```

*AddWindow.xaml.cs*:
```cs
// AddWindow.xaml.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;

namespace DataBinding
{
    /// <summary>
    /// Interaction logic for AddWindow.xaml
    /// </summary>
    public partial class AddWindow : Window
    {
        public CarTable AddWinCarTable { get; set; }

        public AddWindow()
        {
            InitializeComponent();
        }

        private void Add_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                AddWinCarTable = new CarTable
                {
                    ID = Int32.Parse(id.Text),
                    CategoryID = Byte.Parse(CategoryId.Text),
                    CategoryName = CategoryName.Text,
                    ModelName = ModelName.Text,
                    ModelNumber = ModelNumber.Text,
                    Cost = Double.Parse(Cost.Text),
                    ImageCar = ImageCar.Text,
                    Description = Description.Text
                };
                this.Close();
            }
            catch
            {
                MessageBox.Show("Заданы некорректные данные");
            }
        }

        private void Cancel_Click(object sender, RoutedEventArgs e)
        {
            AddWinCarTable = null;
            this.Close();
        }
    }
}
```

### Интерфейс INotifyPropertyChanged
В прошлой теме использовался объект `Phone` для привязки к текстовым блокам. Однако если мы изменим его, содержимое текстовых блоков не изменится. Например, добавим в окно приложения кнопку:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black" DataContext="{StaticResource nexusPhone}" TextBlock.Foreground="White">
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <TextBlock Text="Модель" />
        <TextBlock Text="{Binding Title}" Grid.Row="1" />
        <TextBlock Text="Производитель" Grid.Column="1"/>
        <TextBlock Text="{Binding Company}" Grid.Column="1" Grid.Row="1" />
        <TextBlock Text="Цена" Grid.Column="2" />
        <TextBlock Text="{Binding Price}" Grid.Column="2" Grid.Row="1" />

        <Button Foreground="White" Content="Изменить" Click="Button_Click" Background="Black"
            BorderBrush="Silver" Grid.Column="2" Grid.Row="2" />
    </Grid>
</Window>
```

И в файле кода для этой кнопки определим обработчик, в котором будет меняться свойства ресурса:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    Phone phone = (Phone)this.Resources["nexusPhone"];
    phone.Company = "LG"; // Меняем с Google на LG
}
```

Сколько бы мы не нажимали на кнопку, текстовые блоки, привязанные к ресурсу, не изменятся. Чтобы объект мог полноценно реализовать механизм привязки, нам надо реализовать в его классе интерфейс `INotifyPropertyChanged`. И для этого изменим класс `Phone` следующим образом:
```cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

class Phone : INotifyPropertyChanged
{
    private string title;
    private string company;
    private int price;

    public string Title
    {
        get { return title; }
        set
        {
            title = value;
            OnPropertyChanged("Title");
        }
    }
    public string Company
    {
        get { return company; }
        set
        {
            company = value;
            OnPropertyChanged("Company");
        }
    }
    public int Price
    {
        get { return price; }
        set
        {
            price = value;
            OnPropertyChanged("Price");
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    public void OnPropertyChanged([CallerMemberName]string prop = "")
    {
        if (PropertyChanged != null)
            PropertyChanged(this, new PropertyChangedEventArgs(prop));
    }
}
```

Объяснение изменений:
1. **Реализация `INotifyPropertyChanged`**: Класс `Phone` теперь реализует интерфейс `INotifyPropertyChanged`, что позволяет ему уведомлять другие компоненты об изменениях свойств.

2. **Полные свойства**: Свойства теперь используют приватные поля для хранения значений. Это позволяет проверять, изменилось ли значение свойства перед вызовом `OnPropertyChanged`.

3. **Метод `OnPropertyChanged`**: Этот метод вызывается всякий раз, когда изменяется свойство. Он уведомляет всех подписчиков события `PropertyChanged` об изменении свойства.

4. **Событие `PropertyChanged`**: Это событие вызывается методом `OnPropertyChanged`. Оно позволяет другим компонентам подписываться на уведомления об изменениях свойств объекта `Phone`.

В этом примере когда объект класса изменяет значение свойства, то он через событие `PropertyChanged` извещает систему об изменении свойства. А система обновляет все привязанные объекты.

#### Дополнительные возможности
Добавление дополнительного кода в каждое свойство для реализации `INotifyPropertyChanged` является традиционным подходом, но это не единственный способ. Есть несколько альтернатив, которые позволяют избежать повторения кода:

1. **Использование аспектно-ориентированного программирования (AOP)**:

    Инструменты как PostSharp и Fody позволяют автоматически добавлять код для реализации `INotifyPropertyChanged` во время компиляции или выполнения. Это уменьшает количество кода, который нужно писать вручную.

2. **Использование атрибутов и генераторов кода**:

    Community Toolkit for .NET предлагает атрибуты, которые могут генерировать код для реализации `INotifyPropertyChanged`. Эти атрибуты позволяют автоматически добавлять необходимый код в классы.

3. **Объектно-ориентированное проектирование**:

    Можно создать классы, которые сами заботятся о генерации событий. Например, использовать классы-свойства, которые автоматически вызывают `OnPropertyChanged` при изменении значения.

4. **Использование сторонних библиотек и инструментов**:

    Инструменты как ReSharper или другие плагины для IDE могут автоматически генерировать код для `INotifyPropertyChanged`, что также уменьшает ручной труд.

Таким образом, хотя традиционный подход требует добавления кода в каждое свойство, существуют альтернативы, которые позволяют автоматизировать этот процесс и уменьшить количество повторяющегося кода.

#### Использование объектно-ориентированного проектирования
Третий подход к реализации `INotifyPropertyChanged` без добавления дополнительного кода в каждое свойство предполагает использование объектно-ориентированного проектирования. Этот подход заключается в создании базового класса или вспомогательного класса, который сам заботится о генерации событий `PropertyChanged`. Таким образом, вам не нужно писать повторяющийся код для каждого свойства в ваших классах.

Пример реализации:
1. **Базовый класс**: создайте базовый класс, который реализует `INotifyPropertyChanged`. Этот класс будет содержать методы для обновления свойств и вызова события `PropertyChanged`.

    ```cs
    public abstract class NotifyPropertyChangedBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (Equals(storage, value))
            {
                return false;
            }

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
    ```

2. **Использование базового класса**: теперь ваши классы могут наследовать этот базовый класс и использовать его методы для обновления свойств.

    ```cs
    public class Phone : NotifyPropertyChangedBase
    {
        private string _title;
        private string _brand;
        private decimal _price;
        private decimal? _discount;

        public string Title
        {
            get => _title;
            set => SetProperty(ref _title, value);
        }

        public string Brand
        {
            get => _brand;
            set => SetProperty(ref _brand, value);
        }

        public decimal Price
        {
            get => _price;
            set => SetProperty(ref _price, value);
        }

        public decimal? Discount
        {
            get => _discount;
            set => SetProperty(ref _discount, value);
        }
    }
    ```

Преимущества:
- **Меньше повторяющегося кода**: Вам не нужно писать код для вызова OnPropertyChanged в каждом свойстве.

- **Удобство поддержки**: Если вам нужно изменить логику обновления свойств, вы можете сделать это в одном месте — в базовом классе.

Этот подход позволяет избежать повторения кода и упрощает поддержку ваших классов.

### Форматирование привязанных данных

#### Преобразование данных
При обычной привязке информация путешествует от источника к цели без каких-либо изменений. Это кажется логичным, но такое поведение не всегда подходит. Часто источник данных может использовать низкоуровневое представление, которое не нужно отображать непосредственно в пользовательском интерфейсе.

Например, может понадобиться, чтобы числовые коды заменялись читабельными для человека строками, числа представлялись в укороченном виде, даты отображались в длинном формате и т.д. Если это так, то нужен какой-то способ преобразования этих значений в корректную отображаемую форму. И если применяется двунаправленная привязка, то также понадобится обратная операция — преобразование введенных пользователем данных в представление, подходящее для хранения в соответствующем объекте данных.

К счастью, в WPF доступны два средства, которые могут оказать помощь:

- **Форматирование строк**

    Это средство позволяет преобразовать данные, представленные в виде текста — например, строки, которые содержат даты и числа, — за счет установки свойства `Binding.StringFormat`. Это удобный прием, который справляется, по крайней мере, с половиной задач форматирования.

- **Конвертеры значений**

    Это намного более мощное (и в некотором отношении более сложное) средство, позволяющее преобразовывать любой тип исходных данных в любой тип представления объекта, который может быть передан связанному элементу управления.

Оба подхода рассматриваются в последующих разделах.

##### Свойство StringFormat
Форматирование строк — блестящий инструмент для форматирования чисел, которые нужно отобразить в виде текста. Например, возьмем свойство `Cost` из класса `CarTable`. `Cost` хранится как `double`, и в результате его отображения в текстовом поле можно наблюдать значение вроде 150000. Такой формат пропускает символ валюты и не слишком удобен для чтения. Интуитивно понятное представление должно выглядеть как $150.000 или 150.000 руб.

Простейшее решение состоит в установке свойства `Binding.StringFormat`. Для преобразования неформатированного текста в его отображаемое значение непосредственно перед его появлением в элементе управления WPF использует форматную строку. Не менее важно, что WPF в большинстве случаев применяет эту строку для обратного преобразования, взяв любые отредактированные данные и используя их для обновления привязанного свойства.

При установке свойства `Binding.StringFormat` применяются стандартные форматные строки .NET вида `{0:С}`. Здесь `0` представляет первое значение, а `С` ссылается на строку формата, которой в данном случае является стандартный, специфичный для локали формат валюты, который преобразует 3.99 в $3.99 на компьютере, находящемся в США.

Все выражение помещается в фигурные скобки. Ниже приведен пример применения форматной строки к полю `Cost`, чтобы его значение отображалось как денежное:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, StringFormat={}{0:C}}" ...
```

Значение `StringFormat` предварено еще одной парой фигурных скобок `{}`. Вместе получается `{}{0:С}`, а не просто `{0:С}`. Эта несколько неуклюжая конструкция необходима, чтобы защитить строку. В противном случае анализатор XAML может быть введен в заблуждение фигурной скобкой в начале `{0:С}`. Кстати, управляющая последовательность `{}` необходима, только когда значение `StringFormat` начинается со скобки.

Т.к. в базе данных стоимость хранится в рублях, а не в долларах давайте модифицируем выражение привязки:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, StringFormat={}{0} руб.}" ...
```

Однако эта форматная строка работает только в одном направлении. Если пользователь попытается применить отредактированное значение, включающее литеральный текст, обновление потерпит неудачу. С другой стороны, если пользователь выполнит редактирование, введя только числовое значение, то редактирование удастся, и выражение привязки преобразует его в отображаемый текст.

Чтобы получить нужный результат с помощью свойства `StringFormat`, понадобится правильная строка формата. Все доступные форматные строки можно найти в справочной системе Visual Studio. Ниже перечислены наиболее часто используемые опции, которые будут применять для числовых данных и дат соответственно.

*Строки формата для числовых данных*
Тип | Строка формата | Пример
-- | -- | --
Валюта | `C` | `$1,234.50`<br>Отрицательные значения представляются в скобках: `($1,234.50)`. Знак валюты специфичен для локали.
Научный (экспоненциальный) | `E` | `1.234.50Е+004`
Процентный | `P` | `45.6%`
Десятичный с фиксированной точкой | `F?` | Зависит от количества установленных десятичных разрядов. `F3` форматирует значения в виде `123.400`, a `F0` форматирует значения подобно `123`

*Строки формата для времени и дат*
Тип | Строка формата | Пример
-- | -- | --
Короткая дата | `d` | `M/d/yyyy`. Например: `10/30/2010`.
Длинная дата | `D` | `dddd, MMMM dd, yyyy`. Например: `Monday, January 31, 2011`.
Длинная дата и короткое время | `f` | `dddd, MMMM dd, yyyy HH:mm aa`. Например: `Monday, January 31, 2011 10:00 AM`.
Длинная дата и длинное время | `F` | `dddd, MMMM dd, yyyy HH:mm:ss aa`. Например: `Monday, January 31, 2011 10:00:23 AM`.
Сортируемый стандарт ISO | `s` | `yyyy-MM-dd HH:mm:ss`. Например: `2011-01-31 10:00:23`.
Месяц и день | `M` | `MMMM dd`. Например: `January 31`.
Общий | `G` | `M/d/yyyy HH:mm:ss aa` (зависит от локальных установок). Например: `10/30/2010 10:00:23 AM`.

Списочные элементы управления WPF также поддерживают строковое форматирование для своих элементов. Чтобы использовать его, нужно просто установить свойство **`ItemStringFormat`** списка (унаследованное от базового класса `ItemsControl`). Ниже приведен пример со списком машин:
```xml
<ListBox Name="lstCars" Margin="5" ItemStringFormat="Марка: {0}" />
```

Форматированная строка автоматически передается привязке, которая захватывает текст каждого элемента списка.

##### Конвертеры значений
Свойство `Binding.StringFormat` создано для простого стандартного форматирования чисел и дат. Но во многих сценариях привязки требуется более мощный инструмент, который называется классом конвертера значений.

Роль конвертера значений довольно очевидна. Он отвечает за преобразование исходных данных непосредственно перед их отображением в целевом элементе и (в случае двунаправленной привязки) преобразование нового целевого значения непосредственно перед его применением к источнику.

Конвертеры значений — исключительно удобная часть инфраструктуры привязки данных WPF. Их можно использовать несколькими удобными способами, которые перечислены ниже:

- *Форматирование данных для строкового представления*. Например, можно преобразовывать число в строку валюты. Это — наиболее очевидное применение конвертеров значений, но, конечно же, не единственное.

- *Создание специфических типов объектов WPF*. Например, можно прочитать блок двоичных данных и создать объект `BitmapImage`, который затем привязать к элементу `Image`.

- *Условное изменение свойства в элементе на основе привязанных данных*. Например, можно создать конвертер значений, который изменяет цвет фона элемента для выделения значений из определенного диапазона.

##### Форматирование строк с помощью конвертера значений
Чтобы получить базовое представление о работе конвертера значений, вернемся к примеру форматирования денежной величины из предыдущего раздела. Хотя там использовалось свойство `Binding.StringFormat`, аналогичного (и даже большего) результата можно добиться с помощью конвертера значений. Например, можно округлять или усекать значения, использовать словесное описание числа (изменив 600000 на 600 тыс. руб.). Можно даже настроить работу обратного преобразования, заменяя введенные пользователем значения правильными значениями в привязанном объекте (чтобы избавиться от ошибки, возникающей при редактировании данных).

Для создания конвертера значений потребуется выполнить четыре шага:

1. Создать класс, реализующий `IValueConverter`.

2. Добавить атрибут `ValueConversion` в объявление класса и указать исходный и целевой типы данных.

3. Реализовать метод `Convert()`, преобразующий данные из исходного формата в отображаемый формат.

4. Реализовать метод `ConvertBack()`, выполняющий обратное преобразование значения из отображаемого формата в его "родной" формат.

Ниже приведен полный код конвертера значений, который имеет дело со значениями цены, хранимыми в свойстве `CarTable.Cost`:
```cs
[ValueConversion(typeof(double), typeof(string))]
public class CostConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        // Возвращаем строку в формате 123.456.789 руб.
        return ((double)value).ToString("#,###", culture) + " руб.";
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        double result;
        if (Double.TryParse(value.ToString(), System.Globalization.NumberStyles.Any,
                        culture, out result))
        {
            return result;
        }
        else if (Double.TryParse(value.ToString().Replace(" руб.", ""), System.Globalization.NumberStyles.Any,
                        culture, out result))
        {
            return result;
        }
        return value;
    }
}
```

Чтобы ввести в действие этот конвертер, надо начать с отображения пространства имен проекта на префикс пространства имен XML, который можно применять в коде разметки. Если вы используете старый пример, то такой префикс уже существует:
```xml
<Window ...
xmlns:databinding="clr-namespace:DataBinding"
```

Далее нужно добавить объект конвертора в ресурсы окна:
```xml
<Window.Resources>
        <databinding:CostConverter x:Key="CostConverter"></databinding:CostConverter>
</Window.Resources>
```

Затем можно указывать на него в привязке, используя ссылку `StaticResource`:
```xml
<TextBox Margin="5" Grid.Row="2" Grid.Column="1"
         Text="{Binding Cost, ValidatesOnExceptions=True, Converter={StaticResource CostConverter}}"
         LostFocus="textChange_Event"></TextBox>
```

Теперь значения, введенные пользователем в указанном формате будут корректно преобразовываться и записываться в базу данных.

##### Создание объектов с конвертером значений
Конвертеры значений незаменимы, когда необходимо преодолеть зазор между способом сохранения данных в классах и способом их отображения в окне. Например, предположим, что есть графические данные, хранящиеся в виде массива байт в поле базы данных.

Существует возможность преобразования двоичных данных в объект `System.Windows.Media.Imaging.BitmapImage` и сохранения его как части объекта данных. Однако такое проектное решение может не подойти.

Например, может понадобиться гибкость для создания более одного объектного представления изображения — возможно, потому, что библиотека данных используется как в приложениях WPF, так и в приложениях Windows Forms (где вместо этого применяется класс `System.Drawing.Bitmap`). В таком случае имеет смысл хранить низкоуровневую двоичную информацию в объекте данных и преобразовывать ее в WPF-объект `BitmapImage` с помощью конвертера значений.

Таблица `CarTable` из базы данных *AutoShop* не включает двоичных графических данных, но содержит поле `ImageCar`, хранящее имя файла с изображением машины.

Во-первых, изображение может быть недоступным в зависимости от расхода памяти при работе приложения. Во-вторых, нет смысла в расходе дополнительной памяти для хранения изображения, если вы не собираетесь его показывать.

Поле `ImageCar` включает имя файла и относительный путь, но не полный путь к этому файлу изображения, что дает определенную гибкость для размещения таких файлов в любом подходящем месте. Перед конвертером значений стоит задача создания URI, указывающего на файл изображения, на основе поля `CarImage` и каталога, который будет использоваться для хранения таких файлов. Ниже приведен полный код `ImagePathConverter`, выполняющий преобразование:
```cs
public class ImagePathConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return new BitmapImage(
            new Uri(
                System.IO.Directory.GetCurrentDirectory() + "\\" + (string)value));
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return null;
    }
}
```

Давайте немного изменим компоновку нашего проекта и добавим выражение привязки, использующее этот конвертер значений, в объект `Image` (не забудьте добавить этот конвертор в ресурсы окна, например, под именем `ImageConverter`):
```xml
<!-- Файл MainWindow.xaml -->

...

<Grid  Name="gridCarDetails" DataContext="{Binding ElementName=lstCars, Path=SelectedItem}">
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="110"/>
        <ColumnDefinition Width="Auto"/>
        <ColumnDefinition/>
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="Auto"></RowDefinition>
        <RowDefinition Height="*"></RowDefinition>
    </Grid.RowDefinitions>

    <Image Margin="5,0" Grid.RowSpan="3"
            Source="{Binding Path=ImageCar, Converter={StaticResource ImageConverter}}"/>
    <TextBlock Margin="7" Grid.Column="1">Марка:</TextBlock>
    <TextBox Margin="5" Grid.Column="2" LostFocus="textChange_Event">
        <TextBox.Text>
            <Binding Path="ModelName" UpdateSourceTrigger="PropertyChanged">
                <Binding.ValidationRules>
                    <databinding:EmptyRule></databinding:EmptyRule>
                </Binding.ValidationRules>
            </Binding>
        </TextBox.Text>
    </TextBox>
    <TextBlock Margin="7" Grid.Row="1" Grid.Column="1">Модель:</TextBlock>
    <TextBox Margin="5" Grid.Row="1" Grid.Column="2" LostFocus="textChange_Event">
        <TextBox.Text>
            <Binding Path="ModelNumber" UpdateSourceTrigger="PropertyChanged">
                <Binding.ValidationRules>
                    <databinding:EmptyRule></databinding:EmptyRule>
                </Binding.ValidationRules>
            </Binding>
        </TextBox.Text>
    </TextBox>
    <TextBlock Margin="7" Grid.Row="2" Grid.Column="1">Цена (руб):</TextBlock>
    <TextBox Margin="5" Grid.Row="2" Grid.Column="2"
                Text="{Binding Cost, ValidatesOnExceptions=True, Converter={StaticResource CostConverter}}"
                LostFocus="textChange_Event"></TextBox>
    <TextBlock Margin="7,7,7,0" Grid.Row="3">Описание:</TextBlock>
    <TextBox Margin="7" Grid.Row="4" Grid.ColumnSpan="3"
                VerticalScrollBarVisibility="Visible" TextWrapping="Wrap"
                Text="{Binding Path=Description, TargetNullValue=Описание не доступно}" LostFocus="textChange_Event"/>
</Grid>
```

Данный код (в частности привязка свойства `Source` объекта `Image`) работает, поскольку свойство `Image.Source` ожидает объекта `ImageSource`, a класс `BitmapImage` унаследован от `ImageSource`.

Этот пример можно усовершенствовать несколькими способами. Попытка создать `BitmapImage`, указывающий на несуществующий файл, вызовет исключение, которое будет получено при установке свойств `DataContext`, `ItemsSource` или `Source`.

В качестве альтернативы можно добавить свойства в класс `ImagePathConverter`, которые позволят настроить это поведение. Например, можно предусмотреть свойство `SuppressExceptions` булевского типа. Если оно установлено в `true`, можно перехватывать исключения в методе `Convert()` и затем возвращать значение `Binding.DoNothing` (которое укажет WPF действовать так, как будто никакой привязки данных не установлено).

Или же можно добавить свойство `DefaultImage`, которое будет принимать `BitmapImage`. Тогда в случае возникновения исключений `ImagePathConverter` сможет вернуть изображение, выбранное по умолчанию.

Также следует отметить, что этот конвертер поддерживает только однонаправленное преобразование. Причина в том, что изменить объект `BitmapImage` невозможно и применять его для обновления пути к изображению. Однако можно воспользоваться альтернативным подходом. Вместо возврата `BitmapImage` из `ImagePathConverter` можно просто вернуть полностью квалифицированный URI из метода `Convert()`.

##### Применение условного форматирования
Некоторые из наиболее интересных конвертеров значений не предназначены для форматирования данных для целей презентации. Вместо этого они служат для форматирования ряда других связанных с внешним видом аспектов элемента на основе правила данных.

Например, предположим, что требуется выделить самые дорогостоящие машины, окрасив фон другим цветом. Эту логику легко инкапсулировать в следующем конвертере значений:
```cs
public class CostToBackgroundConverter : IValueConverter
{
    public double MinimumCostRichCar { get; set; }
    public Brush HighlughtBrush { get; set; }
    public Brush DefaultBrush { get; set; }

    public object Convert(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        if ((double)value >= MinimumCostRichCar)
            return HighlughtBrush;
        else
            return DefaultBrush;
    }

    public object ConvertBack(object value, Type targetType, object parameter,
        System.Globalization.CultureInfo culture)
    {
        return null;
    }
}
```

Этот конвертер значений тщательно спроектирован с учетом возможности повторного использования. Вместо жесткого кодирования, цвета для выделения задаются в XAML-размете кодом, который использует этот конвертер:
```xml
<Window.Resources>
        ...
        <databinding:CostToBackgroundConverter x:Key="bgConverter" MinimumCostRichCar="1000000"
                                               DefaultBrush="{x:Null}" HighlughtBrush="LightSalmon"/>
        <Style x:Key="myLBIStyle" TargetType="{x:Type ListBoxItem}">
            <Setter Property="Background" Value="{Binding Path=Cost, Converter={StaticResource bgConverter}}"/>
        </Style>
    </Window.Resources>

...

<!-- Добавили стиль для элементов ListBoxItem -->
<ListBox Name="lstCars" Margin="5" ItemContainerStyle="{StaticResource myLBIStyle}"/>

...
```

Вместо цветов применяются кисти, так что можно создавать и более совершенные эффекты выделения, применяя градиенты и фоновые изображения. Чтобы сохранить стандартный прозрачный фон (таким образом, будет использоваться фон родительского элемента), просто установите свойство `DefaultBrush` или `HighlightBrush` в `Null`, как показано выше. Теперь машины, стоящие выше 1 млн. руб. будут подсвечены в списке.

##### Оценка множества свойств
До сих пор выражения привязки использовались для преобразования одной части исходных данных в единый форматированный результат. И хотя изменить вторую часть уравнения (результат) не удастся, приложив немного усилий, можно создать привязку, которая вычисляет или комбинирует информацию из более чем одного исходного свойства.

Первый трюк состоит в замене объекта `Binding` на **`MultiBinding`**. Затем в свойстве `MultiBinding.StringFormat` определяется организация привязанных свойств. Ниже приведен пример, который объединяет фамилию с именем и отображает результат в `TextBlock`:
```xml
<TextBlock>
   <TextBlock.Text>
       <MultiBinding StringFormat="{}{1}, {0}">
           <Binding Path="FirstName"></Binding>
           <Binding Path="LastName"></Binding>
       </MultiBinding>
   </TextBlock.Text>
</TextBlock>
```

В этом примере два поля используются, как они есть, в свойстве `StringFormat`. В качестве альтернативы можно применять форматные строки, чтобы изменить это. Например, при комбинировании с помощью `MultiBinding` текстового значения и значения валюты можно установить `StringFormat` в "{0} затраты {1:C}".

Если хотите сделать с этими двумя исходными полями что-то более изощренное, чем просто соединить их вместе, понадобится помощь конвертера значений. Такой прием позволяет производить вычисления либо применять форматирование, которое принимает во внимание несколько деталей (таких как подсветка всех товаров с наивысшей ценой в указанной категории). Однако для этого конвертер значений должен реализовывать интерфейс **`IMultiValueConverter`** вместо `IValueConverter`.

#### Форматирование значений
Привязка представляет очень простой механизм, однако иногда этому механизму требуется некоторая кастомизация. Так, нам может потребоваться небольшое форматирование значение. Для примера возьмем класс `Phone` из прошлых тем:
```cs
class Phone
{
    public string Title { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
```

Допустим, нам надо в текстовый блок вывести не только цену, но и еще какой-нибудь текст:
```xml
<Window x:Class="ValueConventerApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:ValueConventerApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid>
        <TextBlock Text="{Binding StringFormat=Итоговая цена {0} рублей, Source={StaticResource nexusPhone}, Path=Price}" />
    </Grid>
</Window>
```

Свойство **`StringFormat`** получает набор параметров в фигурных скобках. Фигурные скобки (`{0}`) передают собственно то значение, к которому идет привязка. Можно сказать, что действие свойства `StringFormat` аналогично методу `String.Format()`, который выполняет форматирование строк.

При необходимости мы можем использовать дополнительные опции форматирования, например, `{0:C}` для вывода валюты, `{0:P}` для вывода процентов и т.д.:
```xml
<TextBlock Text="{Binding StringFormat={}{0:C}, Source={StaticResource nexusPhone}, Path=Price}" />
```

При этом если у нас значение в `StringFormat` начинается с фигурных скобок, например, `"{0:C}"`, то перед ними ставятся еще пара фигурных скобок, как в данном случае. По сути они ничего важно не несут, просто служат для корректной интерпретации строки.

Либо в этом случае нам надо экранировать скобки слешами:
```xml
<TextBlock Text="{Binding StringFormat=\{0:C\}, Source={StaticResource nexusPhone}, Path=Price}" />
```

В зависимости от типа элемента доступны различные типы форматировщиков значений:

- **`StringFormat`**: используется для класса `Binding`

- **`ContentStringFormat`**: используется для классов `ContentControl`, `ContentPresenter`, `TabControl`

- **`ItemStringFormat`**: используется для класса `ItemsControl`

- **`HeaderStringFormat`**: используется для класса `HeaderContentControl`

- **`ColumnHeaderStringFormat`**: используется для классов `GridView`, `GridViewHeaderRowPresenter`

- **`SelectionBoxItemStringFormat`**: используется для классов `ComboBox`, `RibbonComboBox`

Их применение аналогично. Например, так как `Button` представляет `ContentControl`, то для этого элемента надо использовать `ContentStringFormat`:
```xml
<Button ContentStringFormat="{}{0:C}"
    Content="{Binding Source={StaticResource nexusPhone}, Path=Price}" />
```

#### Конвертеры значений
Конвертеры значений (value converter) также позволяют преобразовать значение из источника привязки к типу, который понятен приемнику привязки. Так как не всегда два связываемых привязкой свойства могут иметь совместимые типы. И в этом случае как раз и нужен конвертер значений.

Допустим, нам надо вывести дату в определенном формате. Для этой задачи создадим в проекте класс конвертера значений:
```cs
using System;
using System.ComponentModel;
using System.Globalization;
using System.Windows.Data;

public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter,CultureInfo culture)
    {
        return ((DateTime)value).ToString("dd.MM.yyyy");
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return DependencyProperty.UnsetValue;
    }
}
```

Конвертер значений должен реализовать интерфейс **`System.Windows.Data.IValueConverter`**. Этот интерфейс определяет два метода: `Convert()`, который преобразует пришедшее от привязки значение в тот тип, который понимается приемником привязки, и `ConvertBack()`, который выполняет противоположную операцию.

Оба метода принимают четыре параметра:

- `object value`: значение, которое надо преобразовать

- `Type targetType`: тип, к которому надо преобразовать значение `value`

- `object parameter`: вспомогательный параметр

- `CultureInfo culture`: текущая культура приложения

В данном случае метод `Convert` возвращает строковое представление даты в формате "dd.MM.yyyy". То есть мы ожидаем, что в качестве параметра `value` будет передаваться объект `DateTime`.

Метод `ConvertBack` в данном случае не имеет значения, поэтому он просто возвращает пустое значение для свойства. В другом случае мы бы здесь получали строковое значение и преобразовывали его в `DateTime`.

Теперь применим этот конвертер в xaml:
```xml
<Window x:Class="ValueConventerApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:ValueConventerApp"
        xmlns:sys="clr-namespace:System;assembly=mscorlib"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <sys:DateTime x:Key="myDate">2/12/2016</sys:DateTime>
        <local:DateTimeToDateConverter x:Key="myDateConverter" />
    </Window.Resources>
    <StackPanel>
        <TextBlock Text="{Binding Source={StaticResource myDate},Converter={StaticResource myDateConverter}}" />
        <TextBlock Text="{Binding Source={StaticResource myDate}}" />
    </StackPanel>
</Window>
```

Здесь искомая дата, которая выводится в текстовые блоки, задана в ресурсах. Также в ресурсах задан конвертер значений. Чтобы применить этот конвертер в конструкции привязки используется параметр **`Converter`** с указанием на ресурс: `Converter={StaticResource myDateConverter}`.

Для сравнения я здесь определил два текстовых блока. Но поскольку к одному из них применяется конвертер, то отображение даты будет отличаться.

Немного изменим код конвертера и используем передаваемый параметр:
```cs
public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if(parameter!=null && parameter.ToString()=="EN")
            return ((DateTime)value).ToString("MM-dd-yyyy");

        return ((DateTime)value).ToString("dd.MM.yyyy");
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return DependencyProperty.UnsetValue;
    }
}
```

В качестве параметра может передаваться любой объект. Если параметр в xaml не используется, то передается `null`. В данном случае мы проверяем, равен ли параметр строке "EN", то есть мы ожидаем, что параметр будет передавать строковое значение. И если равен, то возвращаем дату немного в другом формате.

Для применения параметра изменим код xaml:
```xml
<StackPanel>
    <TextBlock Text="{Binding Source={StaticResource myDate},Converter={StaticResource myDateConverter}}" />
    <TextBlock Text="{Binding Source={StaticResource myDate}, ConverterParameter=EN, Converter={StaticResource myDateConverter}}" />
    <TextBlock Text="{Binding Source={StaticResource myDate}}" />
</StackPanel>
```

Параметр привязки задается с помощью свойства **`ConverterParameter`**. Итак, у нас тут три текстовых блока, и применяя конвертер, мы получим три разных отображения даты.

Также мы можем использовать передаваемые в конвертер параметры культуры и типа, к которому надо преобразовать. Например, мы можем смотреть на тип целевого значения и в зависимости от результатов производить определенные действия:
```cs
public class DateTimeToDateConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        if (targetType != typeof(Brush))
        {
            //....
        }
//...................
```

В данном случае предполагается, что тип объекта, к которому надо преобразовать, представляет тип `Brush`.

#### Списочные элементы управления
Форматирование строки и конвертеры значений — это все, что нужно для применения гибкого форматирования к индивидуальным привязанным значениям. Но привязанным спискам требуется нечто большее. К счастью, WPF предлагает несколько решений форматирования. Большинство из них встроено в базовый класс `ItemsControl`, от которого наследуются все списочные элементы управления, так что именно отсюда следует начать исследование форматирования списков.

Как известно, класс `ItemsControl` определяет базовую функциональность для элементов управления, которые содержат в себе список элементов. Этими элементами могут быть вхождения в списке, узлы дерева, команды меню, кнопки в панели инструментов и т.п.

Некоторые оболочки элементов списков появляются в иерархии классов, унаследованных от `ItemsControl`. Например, здесь будут не только ожидаемые классы `Menu` и `TreeView`, но также `MenuItem` и `TreeViewItem`. Причина в том, что эти классы обладают способностью содержать собственные коллекции подэлементов — именно это обеспечивает деревьям и меню их вложенную иерархическую структуру. С другой стороны, вы не найдете здесь `ComboBoxItem` и `ListBoxItem`, поскольку они не содержат коллекций вложенных элементов, и потому не наследуются от `ItemsControl`.

В `ItemsControl` определены свойства, которые поддерживают привязку данных, и два ключевых средства форматирования: стили и шаблоны данных. В таблице ниже содержится краткий обзор свойств `ItemsControl`. (Свойства перечисляются от самых базовых до наиболее сложных.)

Следующий элемент иерархии наследования `ItemsControl` — класс `Selector`, который добавляет простой набор свойств для определения (и установки) выбранного элемента. Не все классы `ItemsControl` поддерживают выбор. Например, выбор не имеет никакого значения для `ToolBar` или `Menu`, потому эти классы наследуются от `ItemsControl`, а не от `Selector`.

*Свойства класса `ItemsControl`, относящиеся к форматированию*
Наименование | Описание
-- | --
`ItemsSource` | Привязанный источник данных (коллекция `DataView`, которую необходимо отобразить в списке).
`DisplayMemberPath` | Свойство, которое должно отображаться для каждого элемента данных. Для более сложного представления или комбинирования свойств используйте вместо него `ItemsTemplate`.
`ItemsStringFormat` | Строка формата .NET, которая, будучи установленной, используется для форматирования текста каждого элемента. Обычно этот прием используется для преобразования числовых значений или значений дат в подходящее видимое представление — точно так же, как это делает свойство `Binding.StringFormat`.
`ItemContainerStyle` | Стиль, позволяющий устанавливать свойства контейнера, который включает в себя каждый элемент. Контейнер зависит от типа списка (например, это `ListBoxItem` для класса `ListBox` и `ComboBoxItem` — для класса `ComboBox`).Объекты-оболочки создаются автоматически при наполнении списка.
`ItemContainerStyleSelector` | `StyleSelector`, использующий код для выбора стиля оболочки каждого элемента в списке. Это позволяет назначать разным элементам списка различные стили. Специальный класс `StyleSelector` должен быть создан самостоятельно.
`AlternationCount` | Число чередующихся наборов для данных. Например, при значении `AlternationCount`, равном 2, варьируется 2 стиля строк, при `AlternationCount`, равном 3, существует три чередующихся стиля строк и т.д.
`ItemTemplate` | Шаблон, извлекающий соответствующие данные из привязанного объекта и организующий их в соответствующую комбинацию элементов управления.
`ItemTemplateSelector` | `DataTemplateSelector`, использующий код для выбора шаблона каждого элемента в списке. Это позволяет назначать разным элементам различные шаблоны. Специальный класс `DataTemplateSelector` должен быть создан самостоятельно.
`ItemsPanel` | Определяет панель, созданную для хранения всех элементов списка. Все оболочки элементов добавляются в этот контейнер. Обычно для вертикальной ориентации списка (сверху вниз) применяется `VirtualizingStackPanel`.
`GroupStyle` | Если используется группирование, это стиль, определяющий, как должна быть сформатирована каждая группа. При использовании группирования оболочки элементов (`ListBoxItem`, `ComboBoxItem` и т.п.) добавляются к оболочкам `GroupItem`, представляющим каждую группу, и эти группы затем добавляются в список.
`GroupStyleSelector` | `StyleSelector`, использующий код для выбора стиля каждой группы. Это позволяет назначать разным группам различные стили. Специальный класс `StyleSelector` должен быть создан самостоятельно.

К свойствам, которые добавляет класс `Selector`, относятся **`SelectedItem`** (выбранный объект данных), **`SelectedIndex`** (позиция выбранного элемента) и **`SelectedValue`** (свойство "значения" выбранного объекта данных, которое указывается установкой `SelectedValuePath`). Обратите внимание, что класс `Selector` не поддерживает множественный выбор — это добавляется к `ListBox` посредством свойств `SelectionMode` и `SelectionItems` (что по существу и все, что класс `ListBox` добавляет к этой модели).
