## Bindings / Привязки

- [Bindings / Привязки](#bindings--привязки)
  - [Введение в привязку](#введение-в-привязку)
    - [Классификация привязок](#классификация-привязок)
    - [Работа с привязкой в C#](#работа-с-привязкой-в-c)
    - [Режимы привязки](#режимы-привязки)
    - [Обновление привязки. UpdateSourceTrigger](#обновление-привязки-updatesourcetrigger)
    - [Свойство Source](#свойство-source)
    - [Свойство TargetNullValue](#свойство-targetnullvalue)
    - [Свойство RelativeSource](#свойство-relativesource)
    - [Свойство IsAsync](#свойство-isasync)
    - [Свойство DataContext](#свойство-datacontext)
  - [Привязка элементов](#привязка-элементов)
    - [Связывание элементов](#связывание-элементов)
      - [Ошибки привязки](#ошибки-привязки)
    - [Режимы привязки](#режимы-привязки-1)
    - [Создание привязки в коде](#создание-привязки-в-коде)
    - [Множественные привязки](#множественные-привязки)
    - [Обновление привязок](#обновление-привязок)
    - [Привязка к объектам](#привязка-к-объектам)
      - [Свойство Source](#свойство-source-1)
      - [Свойство RelativeSource](#свойство-relativesource-1)
      - [Свойство DataContext](#свойство-datacontext-1)
  - [Привязка данных](#привязка-данных)
    - [Режимы привязки](#режимы-привязки-2)
    - [Особенности](#особенности)

### Введение в привязку
В WPF привязка (binding) является мощным инструментом программирования, без которого не обходится ни одно серьезное приложение. <dfn title="привязка">Привязка</dfn> в WPF — это мощный механизм, позволяющий связывать свойства элементов управления с данными из различных источников. Это позволяет синхронизировать значения свойств двух разных объектов, что упрощает представление и взаимодействие с данными в приложениях.

Привязка подразумевает взаимодействие двух объектов: *источника* и *приемника*. Объект-приемник создает привязку к определенному свойству объекта-источника. В случае модификации объекта-источника, объект-приемник также будет модифицирован.

Например, простейшая форма с использованием привязки:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="250" Width="300">
    <StackPanel>
        <TextBox x:Name="myTextBox" Height="30" />
        <TextBlock x:Name="myTextBlock" Text="{Binding ElementName=myTextBox,Path=Text}" Height="30" />
    </StackPanel>
</Window>
```

Для определения привязки используется выражение типа:
```xml
{Binding ElementName=Имя_объекта-источника, Path=Свойство_объекта-источника}
```

То есть в данном случае у нас элемент `TextBox` является источником, а `TextBlock` — приемником привязки. Свойство `Text` элемента `TextBlock` привязывается к свойству `Text` элемента `TextBox`. В итоге при осуществлении ввода в текстовое поле синхронно будут происходить изменения в текстовом блоке.

#### Классификация привязок
В WPF существует несколько видов привязок, которые позволяют связывать свойства элементов управления с данными из различных источников. Основные виды привязок включают:

1. <dfn title="привязка элементов">Привязка элементов</dfn> — это механизм, позволяющий связывать свойства различных элементов управления между собой. Привязка элементов — это простейший сценарий, когда источником данных является другой элемент WPF, а целевым свойством — свойство зависимости другого элемента. Это позволяет синхронизировать значения свойств элементов, что упрощает создание динамического и отзывчивого пользовательского интерфейса. Пример:

    ```xml
    <TextBox x:Name="textBox1" />
    <TextBlock Text="{Binding ElementName=textBox1, Path=Text}" />
    ```

2. <dfn title="привязка объектов">Привязка объектов</dfn> предполагает связывание свойств элементов WPF с свойствами объектов .NET. Это может быть любой объект, который содержит данные, например, класс с публичными свойствами. Чтобы использовать этот подход, вы должны определить объект в ресурсах или задать его как `DataContext` для элемента.

    ```xml
    <Window.Resources>
        <local:MyData x:Key="myData" ColorName="Red" />
    </Window.Resources>

    <Grid DataContext="{StaticResource myData}">
        <TextBlock Text="{Binding Path=ColorName}" />
    </Grid>
    ```

3. <dfn title="привязка данных">Привязка данных</dfn> — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными. Привязка данных — это более широкое понятие, которое включает в себя привязку элементов WPF к различным источникам данных, таким как коллекции, объекты ADO.NET или XML-данные. Привязка данных позволяет автоматически обновлять интерфейс при изменении данных и наоборот. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения. Пример:

    ```xml
    <ListBox ItemsSource="{Binding Path=Employees}" />
    ```

4. <dfn title="вложенная привязка">Вложенные привязки</dfn> позволяют использовать несколько привязок одновременно для одного свойства. В WPF существуют три вида вложенных привязок:

   - **`Binding`**: Стандартная привязка.

   - **`PriorityBinding`**: Выполняет привязку к нескольким источникам с приоритетом.

   - **`MultiBinding`**: Объединяет несколько значений из разных источников в одно.

   Пример `MultiBinding`:
   ```xml
   <TextBlock>
       <TextBlock.Text>
           <MultiBinding StringFormat="{}{0} {1}">
               <Binding Path="FirstName" />
               <Binding Path="LastName" />
           </MultiBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

#### Работа с привязкой в C#
Ключевым объектом при создании привязки является объект `System.Windows.Data.Binding`.

Определение:
```cs
public class Binding : System.Windows.Data.BindingBase
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.data.binding?view=windowsdesktop-9.0

Используя этот объект мы можем получить уже имеющуюся привязку для элемента:
```cs
Binding binding = BindingOperations.GetBinding(myTextBlock, TextBlock.TextProperty);
```

В данном случае получаем привязку для свойства зависимостей `TextProperty` элемента `myTextBlock`.

Также можно полностью установить привязку в коде C#:
```cs
public MainWindow()
{
    InitializeComponent();

    Binding binding = new Binding();

    binding.ElementName = "myTextBox"; // элемент-источник
    binding.Path = new PropertyPath("Text"); // свойство элемента-источника
    myTextBlock.SetBinding(TextBlock.TextProperty, binding); // установка привязки для элемента-приемника
}
```

Если в дальнейшем нам станет не нужна привязка, то мы можем воспользоваться классом **`BindingOperations`** и его методами **`ClearBinding()`** (удаляет одну привязку) и **`ClearAllBindings()`** (удаляет все привязки для данного элемента)
```cs
BindingOperations.ClearBinding(myTextBlock, TextBlock.TextProperty);
```

или
```cs
BindingOperations.ClearAllBindings(myTextBlock);
```

Некоторые свойства класса **`Binding`**:

- **`ElementName`**: имя элемента, к которому создается привязка

- **`IsAsync`**: если установлено в `True`, то использует асинхронный режим получения данных из объекта. По умолчанию равно `False`

- **`Mode`**: режим привязки

- **`Path`**: ссылка на свойство объекта, к которому идет привязка

- **`TargetNullValue`**: устанавливает значение по умолчанию, если привязанное свойство источника привязки имеет значение `null`

- **`RelativeSource`**: создает привязку относительно текущего объекта

- **`Source`**: указывает на объект-источник, если он не является элементом управления.

- **`XPath`**: используется вместо свойства `path` для указания пути к xml-данным

#### Режимы привязки
Свойство **`Mode`** объекта `Binding`, которое представляет режим привязки, может принимать следующие значения:

- **`OneWay`**: свойство объекта-приемника изменяется после модификации свойства объекта-источника.

- **`OneTime`**: свойство объекта-приемника устанавливается по свойству объекта-источника только один раз. В дальнейшем изменения в источнике никак не влияют на объект-приемник.

- **`TwoWay`**: оба объекта — приемник и источник — могут изменять привязанные свойства друг друга.

- **`OneWayToSource`**: объект-приемник, в котором объявлена привязка, меняет объект-источник.

- **`Default`**: по умолчанию (если меняется свойство `TextBox.Text`, то имеет значение `TwoWay`, в остальных случаях `OneWay`).

Применение режима привязки:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30" Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay}" />
</StackPanel>
```

#### Обновление привязки. UpdateSourceTrigger
Односторонняя привязка от источника к приемнику практически мгновенно изменяет свойство приемника. Но если мы используем двустороннюю привязку в случае с текстовыми полями (как в примере выше), то при изменении приемника свойство источника не изменяется мгновенно. Так, в примере выше, чтобы текстовое поле-источник изменилось, нам надо перевести фокус с текстового поля-приемника. И в данном случае в дело вступает свойство **`UpdateSourceTrigger`** класса `Binding`, которое задает, как будет происходить обновление. Это свойство в качестве принимает одно из значений перечисления `UpdateSourceTrigger`:

- `PropertyChanged`: источник привязки обновляется сразу после обновления свойства в приемнике

- `LostFocus`: источник привязки обновляется только после потери фокуса приемником

- `Explicit`: источник не обновляется до тех пор, пока не будет вызван метод `BindingExpression.UpdateSource()`

- `Default`: значение по умолчанию. Для большинства свойств это значение `PropertyChanged`. А для свойства `Text` элемента `TextBox` это значение `LostFocus`

В данном случае речь идет об обновлении источника привязки после изменения приемника в режимах `OneWayToSource` или `TwoWay`. То есть чтобы у нас оба текстовых поля, которые связаны режимом `TwoWay`, моментально обновлялись после изменения одного из них, надо использовать значение `UpdateSourceTrigger.PropertyChanged`:
```xml
<StackPanel>
    <TextBox x:Name="textBox1" Height="30" />
    <TextBox x:Name="textBox2" Height="30"
        Text="{Binding ElementName=textBox1, Path=Text, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
</StackPanel>
```

#### Свойство Source
Свойство `Source` позволяет установить привязку даже к тем объектам, которые не являются элементами управления WPF. Например, определим класс `Phone`:
```cs
class Phone
{
    public string Title { get; set; }
    public string Company { get; set; }
    public int Price { get; set; }
}
```

Теперь создадим объект этого класса и определим к нему привязку:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black">
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <TextBlock Text="Модель:" Foreground="White"/>
        <TextBlock x:Name="titleTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Title}"
                        Foreground="White" Grid.Column="1"/>
        <TextBlock Text="Цена:" Foreground="White" Grid.Row="1"/>
        <TextBlock x:Name="priceTextBlock" Text="{Binding Source={StaticResource nexusPhone}, Path=Price}"
                        Foreground="White" Grid.Column="1" Grid.Row="1"/>
    </Grid>
</Window>
```

#### Свойство TargetNullValue
На случай, если свойство в источнике привязки вдруг имеет значение `null`, то есть оно не установлено, мы можем задать некоторое значение по умолчанию. Например:
```xml
<Window.Resources>
    <local:Phone x:Key="nexusPhone" Company="Google" Price="25000" />
</Window.Resources>
<StackPanel>
    <TextBlock x:Name="titleTextBlock"
        Text="{Binding Source={StaticResource nexusPhone}, Path=Title, TargetNullValue=Текст по умолчанию}" />
</StackPanel>
```

#### Свойство RelativeSource
Свойство **`RelativeSource`** позволяет установить привязку относительно элемента-источника, который связан какими-нибудь отношениями с элементом-приемником. Например, элемент-источник может быть одним из внешних контейнеров для элемента-приемника. Либо источником и приемником может быть один и тот же элемент.

Для установки этого свойства используется одноименный объект **`RelativeSource`**. У этого объекта есть свойство **`Mode`**, которое задает способ привязки. Оно принимает одно из значений перечисления **`RelativeSourceMode`**:

- `Self`: привязка осуществляется к свойству этого же элемента. То есть элемент-источник привязки в то же время является и приемником привязки.

- `FindAncestor`: привязка осуществляется к свойству элемента-контейнера.

Например, совместим источник и приемник привязке в самом элементе:
```xml
<TextBox Text="{Binding RelativeSource={RelativeSource Mode=Self}, Path=Background, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" />
```

Здесь текст и фоновый цвет текстового поля связаны двусторонней привязкой. В итоге мы можем увидеть в поле числовое значение цвета, поменять его, и вместе с ним изменится и фон поля.

Привязка к свойствам контейнера:
```xml
<Grid Background="Black">
    <TextBlock Foreground="White"
        Text="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType={x:Type Grid}}, Path=Background}" />
</Grid>
```

При использовании режима `FindAncestor`, то есть привязке к контейнеру, необходимо еще указывать параметр **`AncestorType`** и передавать ему тип контейнера в виде выражения `AncestorType={x:Type Тип_элемента-контейнера}`. При этом в качестве контейнера мы могли бы выбрать любой контейнер в дереве элементов, в частности, в данном случае кроме `Grid` таким контейнером также является элемент `Window`.

#### Свойство IsAsync
Свойство `IsAsync` класса `Binding` в WPF используется для указания, следует ли получать и задавать значения привязки асинхронно. Это означает, что если `IsAsync` установлено в `true`, привязка будет выполняться в асинхронном режиме, что может быть полезно для предотвращения блокировки интерфейса пользователя при работе с медленными операциями, такими как загрузка данных из внешних источников.

Однако, стоит отметить, что использование `IsAsync` может не всегда быть самым эффективным или правильным решением для всех сценариев. Например, если источник данных доступен быстро, использование асинхронной привязки может не дать заметных преимуществ и может даже привести к дополнительной сложности.

Пример использования `IsAsync` в XAML:
```xml
<Run Text="{Binding Source={StaticResource nexusPhone}, Path=Discount, IsAsync=True}" />
```

В коде-behind это можно установить так:
```cs
var binding = new Binding("Discount") { IsAsync = true };
```

Несмотря на то, что `IsAsync` может быть полезен в определенных ситуациях, его применение должно быть тщательно обосновано, чтобы избежать ненужной сложности и потенциальных проблем с синхронизацией данных.

Кроме того, стоит отметить, что для более сложных асинхронных операций, таких как загрузка данных из внешних источников, могут быть более подходящими другие механизмы, такие как использование `ObjectDataProvider` с `IsAsynchronous=true` или реализация асинхронных команд в MVVM-паттерне.

#### Свойство DataContext
У объекта `FrameworkElement`, от которого наследуются элементы управления, есть интересное свойство `DataContext`. Оно позволяет задавать для элемента и вложенных в него элементов некоторый контекст данных. Тогда вложенные элементы могут использовать объект `Binding` для привязки к конкретным свойствам этого контекста. Например, используем ранее определенный класс `Phone` и создадим контекст данных из объекта этого класса:
```xml
<Window x:Class="BindingApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:BindingApp"
        mc:Ignorable="d"
        Title="MainWindow" Height="150" Width="300">
    <Window.Resources>
        <local:Phone x:Key="nexusPhone" Title="Nexus X5" Company="Google" Price="25000" />
    </Window.Resources>
    <Grid Background="Black" DataContext="{StaticResource nexusPhone}" TextBlock.Foreground="White">
        <Grid.ColumnDefinitions>
            <ColumnDefinition />
            <ColumnDefinition />
            <ColumnDefinition />
        </Grid.ColumnDefinitions>
        <Grid.RowDefinitions>
            <RowDefinition />
            <RowDefinition />
        </Grid.RowDefinitions>
        <TextBlock Text="Модель" />
        <TextBlock Text="{Binding Title}" Grid.Row="1" />
        <TextBlock Text="Производитель" Grid.Column="1"/>
        <TextBlock Text="{Binding Company}" Grid.Column="1" Grid.Row="1" />
        <TextBlock Text="Цена" Grid.Column="2" />
        <TextBlock Text="{Binding Price}" Grid.Column="2" Grid.Row="1" />
    </Grid>
</Window>
```

![Picture 10.4](./img/67d423945040133e8429f1a8-10.4.png)

Таким образом мы задаем свойству `DataContext` некоторый динамический или статический ресурс. Затем осуществляем привязку к этому ресурсу.

### Привязка элементов

#### Связывание элементов
Простейший сценарий привязки данных подразумевает ситуацию, когда исходным объектом является элемент WPF, а исходным свойством — свойство зависимости. Причина в том, что свойство зависимости имеет встроенную поддержку уведомлений об изменениях. В результате, когда значение свойства зависимости изменяется в исходном объекте, привязанное свойство целевого объекта немедленно обновляется. Это именно то, что требуется, и происходит оно без необходимости построения любой дополнительной инфраструктуры.

Хотя привязка элемента к элементу является простейшим подходом, большинство разработчиков заинтересовано в нахождении самого общего подхода для реальных приложений. В общем, большая часть работы по привязке данных будет тратиться на привязку элементов к объектам данных. Это позволит отображать информацию, извлекаемую из внешнего источника (такого как база данных или файл). Однако привязка элемента к элементу также часто бывает полезной.

Например, ее можно использовать для автоматизации способа, которым элементы взаимодействуют, так что когда пользователь модифицирует один элемент управления, другой элемент обновляется автоматически. Это ценное сокращение, которое избавляет от написания громоздкого и рутинного кода (и это прием, не доступный в предыдущем поколении приложений Windows Forms).

Рассмотрим пример приложения из двух элементов управления: ползунка (`Slider`) и текстового блока (`TextBlock`). При изменении положения ползунка размер шрифта текстового блока должен меняться. Такое поведение можно реализовать за счет обработки события изменения положения ползунка `ValueChaned`:
```xml
<Slider Minimum="8" Maximum="30" ValueChanged="Slider_ValueChanged"></Slider>
<TextBlock x:Name="Message" FontSize="20">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

```cs
private void Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
{
    if (Message != null)
        Message.FontSize = ((Slider)sender).Value;
}
```

Как видно из исходного кода, возникает необходимость проверки существования объекта `Message`, т.к. первый вызов обработчика `Slider_ValueChanged` происходит в момент обработки элемента `Slider` XAML-файла, когда элемент `TextBlock` еще не обработан и, соответственно, объект `Message` еще не создан. Второй проблемой является несоответствие начального значения ползунка и начального размера шрифта.

Для решения поставленной задачи можно задействовать связывание элементов управления WPF. Для использования привязки данных необходимо  указать в качестве значения свойства `FontSize` текстового блока следующее выражение привязки:
```cs
{Binding ElementName=SliderFontSize, Path=Value}`
```

Выражение привязки данных задается в виде расширения разметки XAML в фигурных скобках.

Составляющие выражения привязки:
- **`Binding`** – означает, что будет создан объект класса `System.Windows.Data.Binding`
- **`ElementName`** – имя исходного объекта,
- **`Path`** – имя свойства (или путь до свойства) исходного объекта. Пример пути до свойства: `Background.Opacity`

```xml
<Slider Minimum="8" Maximum="30" x:Name="SliderFontSize"></Slider>
<TextBlock x:Name="Message" FontSize="{Binding ElementName=SliderFontSize, Path=Value}">
    Пример WPF-приложения для демонстрации привязки данных
</TextBlock>
```

В данном примере отсутствуют проблемы, обнаруженные в предыдущем примере. Начальные значения связанных свойств будут согласованы даже в том случае, если элемент `TextBlock` будет предшествовать элементу `Slider`.

Чтобы понять, как привязывать один элемент к другому, рассмотрим простое окно. Оно содержит два элемента управления: `Slider` (ползунок) и `TextBlock` (текстовый блок) с единственной строкой текста. Перемещение ползунка вправо приводит к немедленному увеличению размера шрифта текста, а перемещение влево — к уменьшению размера шрифта.

*XAML*:
```xml
<Slider Margin="5" Minimum="1" Maximum="72" Value="12" Name="sld"
                TickFrequency="5" TickPlacement="BottomRight"></Slider>
<TextBlock Margin="5" Text="Какой-то текст"
            FontSize="{Binding ElementName=sld, Path=Value}"></TextBlock>
```

Привязка определена в элементе `TextBlock`. Вместо установки `FontSize` с использованием литерального значения применяется выражение привязки.

Выражения привязки данных используют расширение разметки XAML (и потому помещаются в фигурные скобки). В начале идет слово `Binding`, потому что создается экземпляр класса **`System.Windows.Data.Binding`**. Хотя объект `Binding` может быть сконфигурирован различными способами, в данной ситуации необходимо установить только два свойства: `ElementName`, которое указывает исходный элемент, и `Path`, указывающее свойство в исходном элементе.

Вместо `Property` используется `Path`, потому что `Path` может указывать на свойство свойства (например, `FontFamily.Source`) или индексатор, используемый свойством (например, `Content.Children[0]`). Путь может включать множество фрагментов, переходящих от свойства к свойству, и т.д.

Чтобы сослаться на присоединенное свойство (свойство, которое определено в другом классе, но применяется к привязанному элементу), имя свойства должно быть указано в круглых скобках. Например, в случае привязки к элементу, помещенному в `Grid`, путь `(Grid.Row)` извлекает номер строки, в которой он находится.

##### Ошибки привязки
WPF не генерирует исключения для уведомления о проблемах привязки данных. Если указан несуществующий элемент или свойство, никакого сообщения об этом не будет; вместо этого данные просто не попадут в целевое свойство. На первый взгляд это может показаться кошмаром для отладки. К счастью, WPF выводит трассировочную информацию, которая детализирует сбои в привязке. Во время отладки приложения эта информация появляется в выходном окне Visual Studio.

Например, попытка привязки к несуществующему свойству приводит к выводу в выходное окно следующего сообщения:
```
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.App"
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.InitializeComponent"
System.Windows.Data Error: 40 : BindingExpression path error:
'SliderValue' property not found on 'object' ''Slider' (Name='sld')'
.BindingExpression:Path=SliderValue; DataItem='Slider' (Name='sld'); target element
is 'TextBlock' (Name=''); target property is 'FontSize' (type 'Double')
```

Среда WPF также игнорирует любые исключения, которые генерируются при попытке читать исходное свойство, и молча поглощает исключение, возникающее, если исходные данные не могут быть приведены к типу данных целевого свойства. Однако есть и другой способ справиться с этой проблемой — можно сообщить WPF о необходимости изменения внешнего вида исходного элемента для индикации возникшей ошибки. Например, неверный ввод можно пометить значком с восклицательным знаком или рамкой красного цвета.

#### Режимы привязки
Одной из ценных особенностей привязки данных является то, что цель обновляется автоматически, независимо от того, как модифицируется источник. В примере из предыдущей статьи источник может быть модифицирован только в одном направлении — через взаимодействие пользователя с ползунком. Однако рассмотрим несколько усложненную версию этого примера, в которой добавляется кнопка, при щелчке на которой изменяется положение ползунка:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    sld.Value += 5;
}
```

Этот код перемещает значение ползунка на 5 единиц, который, в свою очередь, изменяет размер шрифта текста через привязку данных. Это то же самое, как если бы вы двигали ползунок вручную. В этом и заключается основная сила привязки элементов.

Интересно, что существует способ заставить данные перемещаться в обоих направлениях: от источника к цели и от цели к источнику. Трюк заключается в установке свойства **`Mode`** объекта `Binding`. Ниже приведена усовершенствованная двунаправленная привязка, которая позволяет применять значения либо к источнику, либо к цели, и заставит противоположную часть привязки обновлять себя автоматически:
```xml
<TextBlock Margin="5" Text="Какой-то текст"
      FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBlock>
```

В рассматриваемом примере нет причин применять двунаправленную привязку (которая требует больше накладных расходов), поскольку эту проблему можно решить с помощью кода. Однако рассмотрим вариант этого примера, включающий текстовое поле, в котором пользователь может точно устанавливать размер шрифта. Этому текстовому полю понадобится двунаправленная привязка, чтобы оно могло как применять пользовательские изменения, так и отражать последнее значение размера, когда оно изменяется другим путем.

При установке свойства `Binding.Mode` можно использовать одно из пяти значений перечисления `System.Windows.Data.BindingMode`. Ниже приведен их полный список:

- **`OneWay`**

    Целевое свойство обновляется при изменениях исходного свойства

- **`TwoWay`**

    Целевое свойство обновляется при изменениях исходного свойства, а исходное свойство обновляется при изменении целевого свойства

- **`OneTime`**

    Целевое свойство устанавливается изначально на основе значения исходного свойства. Однако с этого момента изменения игнорируются (если только привязка не устанавливается на совершенно другой объект или не вызывается `BindingExpression.UpdateTarget()`). Обычно этот режим используется для сокращения накладных расходов, если известно, что целевое свойство не изменится

- **`OneWayToSource`**

    Подобно `OneWay`, но действует в обратном направлении. Исходное свойство обновляется, когда изменяется целевое свойство (что может показаться несколько странным), но целевое свойство никогда не обновляется

- **`Default`**

    Этот тип привязки зависит от целевого свойства. Это либо `TwoWay` (для устанавливаемых пользователем свойств, таких как `TextBox.Text`), либо `OneWay` (для всего остального). Все привязки используют данный подход, если только не указано иное

Вы уже видели `OneWay` и `TwoWay`. Значение `OneTime` достаточно очевидно. Оставшиеся два варианта требуют ряда дополнительных исследований.

Может возникнуть вопрос: зачем нужны две опции — и `OneWay`, и `OneWayToSource`? В конце концов, оба значения создают однонаправленную привязку, которая работает одинаковым образом. Единственное отличие в том, куда помещено выражение привязки. По сути, `OneWayToSource` позволяет поменять местами источник и цель, поместив выражение в то, что обычно считается источником привязки.

Наиболее общая причина использования этого трюка состоит в установке свойства, которое не является свойством зависимости. Как упоминалось, выражения привязки могут применяться только для установки свойств зависимости. Однако с помощью `OneWayToSource` это ограничение можно обойти, предоставляя в качестве свойства, поставляющего значение, свойство зависимости.

Изначально кажется логичным предположить, что все привязки однонаправленные, если только явно не указано иное. (В конце концов, именно так работает простой пример с ползунком.) Но на самом деле это не так. Чтобы убедиться в этом, вернемся к примеру с привязанным текстовым полем и позволим редактировать текущий размер шрифта. Если убрать установку `Mode=TwoWay`, этот пример все равно будет работать точно также. Причина в том, что WPF использует разные значения `Mode` по умолчанию, в зависимости от привязываемого свойства. (Формально в каждом свойстве зависимости присутствует фрагмент метаданных — флаг `FrameworkPropertyMetadata.BindsTwoWayByDefault`, который указывает, какую привязку должно использовать свойство: однонаправленную или двунаправленную).

Часто значение по умолчанию — именно то, что и нужно. Тем не менее, можно представить пример с текстовым полем только для чтения, которое пользователь не может изменять. В этом случае удается слегка сократить накладные расходы, установив режим однонаправленной привязки.

В качестве общего эмпирического правила: всегда неплохо явно устанавливать режим. Даже в случае текстового поля стоит подчеркнуть, что нужна двунаправленная привязка, включив свойство `Mode`.

#### Создание привязки в коде
При построении окна обычно наиболее эффективно объявлять выражение привязки в разметке XAML с помощью расширения разметки `Binding`. Тем не менее, допускается также создавать привязку и в коде.

Вот как можно создать привязку для элемента `TextBlock`, показанного в примере из предыдущей статьи:
```cs
Binding bind = new Binding();
bind.Source = sld;
bind.Path = new PropertyPath("Value");
bind.Mode = BindingMode.TwoWay;
txb.SetBinding(TextBlock.FontSizeProperty, bind);
```

Для удаления привязки в коде предусмотрены два статических метода класса **`BindingOperations`**. Метод `ClearBinding()` принимает ссылку на свойство зависимости, которое имеет привязку, подлежащую удалению, а метод `ClearAllBindings()` удаляет все привязки данных элемента:
```cs
BindingOperations.ClearAllBindings(txb);
```

И `ClearBinding()`, и `ClearAllBindings()` используют метод `ClearValue()`, который каждый элемент наследует от базового класса `DependencyObject`. Метод `ClearValue()` просто удаляет локальное значение свойства (которым в данном случае является выражение привязки).

Привязка на основе разметки применяется намного чаще, чем программная привязка, потому что она яснее и требует меньше работы. Однако код может применяться для создания привязки в некоторых специализированных сценариях:

- **Создание динамических привязок**

    Если необходимо тонко настраивать привязку на основе другой информации времени выполнения или создавать разные привязки в зависимости от обстоятельств, имеет смысл делать это в коде. (В качестве альтернативы можно было бы определить все необходимые привязки в коллекции `Resources` окна и просто добавить код, который вызывает `SetBinding()` с соответствующим объектом привязки.)

- **Удаление привязки**

    Чтобы удалить привязку и получить возможность установки свойства обычным образом, понадобится помощь метода `ClearBinding()` или `ClearAllBindings()`. Недостаточно просто присвоить новое значение свойству. В случае использования двунаправленной привязки установленное значение распространится на привязанный объект, и оба свойства останутся синхронизированными.

    С помощью методов `ClearBinding()` и `ClearAllBindings()` можно удалить любую привязку. Не имеет значения, применялась привязка программно или в коде XAML.

- **Создание специальных элементов управления**

    Чтобы облегчить для других модификацию визуального представления специального элемента управления, который разрабатывается, определенные детали (такие как обработчики событий и выражения привязки данных) понадобится перенести в код разметки.

#### Множественные привязки
В WPF в одном элементе управления разрешается использовать сколько угодно привязок. Можно модифицировать пример из предыдущей статьи, добавив к элементу `TextBlock` еще несколько привязок:
```xml
<StackPanel>
            <Slider Name="sld" Minimum="1" Maximum="72" Margin="10"
                TickFrequency="5" TickPlacement="BottomRight" Value="12"></Slider>
            <TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"></TextBox>
            <ListBox Margin="10" Name="lst">
                <ListBoxItem Tag="DarkBlue">
                    <Label>Dark Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="Blue">
                    <Label>Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="LightBlue">
                    <Label>Light Blue</Label>
                </ListBoxItem>
            </ListBox>
            <!-- Используем несколько привязок -->
            <TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Text="{Binding ElementName=txt, Path=Text}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}"></TextBlock>
</StackPanel>
```

Допускается также реализовать привязку данных. Например, можно создать выражение привязки для свойства `TextBox.Text`, связывающее его со свойством `TextBlock.FontSize`, которое содержит выражение привязки, связывающее со свойством `Slider.Value`. В этом случае, когда пользователь перетаскивает ползунок в новую позицию, значение передается от `Slider` в `TextBlock` и затем из `TextBlock` в `TextBox`.

Хотя все работает прозрачно, более ясный подход состоит в том, чтобы привязать элементы как можно ближе к данным, которые они используют. В описанном здесь примере необходимо предусмотреть привязку и `TextBlock`, и `TextBox` непосредственно к свойству `Slider.Value`.

Все становится немного более интересно, когда на целевое свойство должны оказывать влияние более одного источника, например, если нужно иметь две равноправные привязки, устанавливающие одно и то же свойство. На первый взгляд это кажется невозможным. Однако существует несколько способов решения.

Простейший подход состоит в изменении режима привязки данных. Как уже известно, свойство `Mode` позволяет модифицировать способ работы привязки так, что данные передаются не только от источника к цели, но и от цели к источнику. С помощью такого приема можно создать несколько выражений привязки, устанавливающих одно и то же свойство. Последнее из них будет иметь эффект.

Чтобы понять, как это работает, рассмотрим вариацию примера элемента — панели с ползунком, который включает текстовое поле, куда можно поместить точное значение размера шрифта. В этом примере свойство `TextBlock.FontSize` может быть установлено двумя путями: перетаскиванием ползунка или вводом в текстовом поле размера шрифта. Все элементы управления синхронизированы так, что если вводится новое число в текстовом поле, размер шрифта текста примера изменяется и ползунок перемещается в соответствующую позицию.

Как уже упоминалось, к свойству `TextBlock.FontSize` можно применять только одну привязку данных. Поэтому имеет смысл оставить свойство `TextBlock.FontSize` в том виде, как оно есть, чтобы оно привязывалось прямо к ползунку.

Хотя добавить другую привязку к свойству `FontSize` нельзя, можно привязать новый элемент управления `TextBox` к свойству `TextBlock.FontSize`. Ниже показана необходимая для этого разметка:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        Text="{Binding ElementName=txb, Path=FontSize, Mode=TwoWay}"></TextBox>
```

Теперь при каждом изменении свойства `TextBlock.FontSize` текущее значение будет вставляться в текстовое поле. Более того, значение в текстовом поле можно редактировать, применяя указанный размер шрифта. Обратите внимание, что для того, чтобы пример работал, свойство `TextBox.Text` должно использовать двунаправленную привязку, передающую данные в обоих направлениях. В противном случае текстовое поле сможет отображать значение `TextBlock.FontSize`, но не позволит изменять его.

С этим примером связано несколько нюансов:

- Поскольку значение свойства `Slider.Value` имеет тип `double`, при перетаскивании ползунка получается дробное значение размера. Установив свойство `TickFrequency` в 1 (или в некоторый целочисленный интервал), a свойство `IsSnapToTickEnabled` в `true`, можно ограничить значение ползунка только целыми величинами.

- Текстовое поле позволяет вводить буквы и другие нечисловые символы. В таком случае значение текстового поля не сможет быть интерпретировано как число. В результате привязка данных молча потерпит неудачу, а значение размера шрифта станет равно 0. Другой подход мог бы состоять в обработке нажатий клавиш в текстовом поле, чтобы вообще предотвратить неправильный ввод, либо в использовании проверки достоверности.

- Изменения, которые вносятся в текстовое поле, не будут применены до тех пор, пока текстовое поле не потеряет фокус (например, когда с помощью клавиши `<Tab>` происходит переход на другой элемент управления). Если такое поведение не подходит, можно обеспечить непрерывное обновление, используя свойство `UpdateSourceTrigger` объекта `Binding`.

Интересно, что показанное здесь решение — не единственный способ привязки текстового поля. Столь же разумно конфигурировать текстовое поле таким образом, чтобы оно изменяло значение свойства `Slider.Value` вместо свойства `TextBlock.FontSize`:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBox>
```

Теперь изменение текстового поля инициирует изменение положения ползунка, которое затем установит новый размер шрифта текста. Опять-таки, данный подход работает только с двунаправленной привязкой данных.

И, наконец, можно поменять местами роли ползунка и текстового поля, чтобы ползунок привязывался к текстовому полю.

В случае привязки `Slider.Value` текстовое поле ведет себя несколько иначе, чем в предыдущих двух примерах. Любые изменения, которые вносятся в текстовое поле, применяются немедленно, вместо того, чтобы ожидать момента утери фокуса.

Как видно из примера, двунаправленные привязки обеспечивает значительную гибкость. Их можно использовать для применения изменений от источника к цели и от цели к источнику. Допускается их применение в комбинации, что позволяет создать неожиданно сложные окна без какого-либо кода.

Обычно решение относительно того, куда применять выражение привязки, диктуется логикой модели кодирования. В предыдущем примере, возможно, было бы больше смысла поместить привязку в свойство `TextBox.Text` вместо свойства `Slider.Value`, потому что текстовое поле — это необязательное дополнение к вполне готовому примеру, а не основной ингредиент, на который полагается ползунок.

Также имело бы больше смысла привязать текстовое поле непосредственно к свойству `TextBlock.FontSize` вместо свойства `Slider.Value`. (Концептуально вы заинтересованы в том, чтобы видеть текущий размер шрифта, и ползунок — только один из способов его установки. Даже несмотря на то, что положение ползунка совпадает с размером шрифта, это — необязательная дополнительная деталь, если вы пытаетесь написать максимально ясную разметку.) Конечно, эти решения субъективны и определяются стилем кодирования. Наиболее важный урок состоит в том, что три подхода могут обеспечить одинаковое поведение.

В следующих статьях мы рассмотрим две детали, касающиеся этого примера. Во-первых, речь пойдет о возможных выборах при установке направления привязки. Во-вторых, будет показано, каким образом точно указать WPF, когда имеет смысл обновлять исходное свойство при двунаправленной привязке.

#### Обновление привязок
В примере из предыдущей статьи (где `TextBox.Text` привязывается к `TextBlock.FontSize`) имеется еще один нюанс. При попытке изменить отображаемый размер шрифта, вводя значение в текстовое поле, ничего не происходит. Изменение не применяется до тех пор, пока не будет совершен переход на другой элемент. Это поведение отличается от поведения, которое демонстрировалось в примере с ползунком. Там новый размер шрифта применялся после перетаскивания ползунка в другую позицию, т.е. в переходе на другой элемент вообще не было необходимости.

Чтобы понять это различие, следует повнимательнее присмотреться к выражениям привязки, которые используются этими двумя элементами управления. Когда применяется привязка `OneWay` или `TwoWay`, измененное значение распространяется от источника к цели немедленно. В случае с ползунком есть однонаправленное выражение привязки в `TextBlock`. Таким образом, изменения в свойстве `Slider.Value` немедленно отражаются в свойстве `TextBlock.FontSize`. То же поведение имеет место в примере с текстовым полем: изменения в источнике (которым является `TextBlock.FontSize`) немедленно влияют на цель (`TextBox.Text`).

Однако изменения, протекающие в обратном направлении — от цели к источнику — не обязательно происходят немедленно. Вместо этого их поведение управляется свойством **`Binding.UpdateSourceTrigger`**, которое принимает одно из значений, описанных ниже. Когда текст берется из текстового поля и используется для обновления свойства `TextBlock.FontSize`, это пример обновления цель-источник, которое использует поведение `UpdateSourceTrigger.LostFocus`.

- **`PropertyChanged`**

    Источник обновляется немедленно, когда изменяется целевое свойство

- **`LostFocus`**

    Источник обновляется немедленно, когда изменяется целевое свойство и цель теряет фокус

- **`Explicit`**

    Источник не обновляется, пока не будет вызван метод `BindingExpression.UpdateSource()`

- **`Default`**

    Поведение обновления определяется метаданными целевого свойства (формально — его свойства `FrameworkPropertyMetadata.DefaultUpdateSourceTrigger`). Для большинства свойств поведением по умолчанию будет `PropertyChanged`, хотя свойство `TextBox.Text` обладает поведением по умолчанию `LostFocus`

Помните, что эти значения не оказывают эффекта на обновление цели. Они просто управляют тем, как обновляется источник в привязках `TwoWay` и `OneWayToSource`.

Вооружившись этим знанием, можно усовершенствовать пример с текстовым полем, чтобы изменения применялись к размеру шрифта по мере их ввода в текстовое поле:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
       Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

Поведением по умолчанию свойства `TextBox.Text` является `LostFocus` просто потому, что текст в текстовом поле будет изменяться непрерывно в процессе пользовательского ввода, вызывая множественные обновления. В зависимости от того, как исходный элемент управления обновляет себя, режим обновления `PropertyChanged` может сделать приложение более медлительным. Вдобавок это может заставить исходный объект обновлять себя до завершения редактирования, что создаст проблемы при проверке достоверности.

Для полного контроля над моментом обновления исходного объекта можно выбрать режим `UpdateSourceTrigger.Explicit`. Если воспользоваться этим подходом в примере с текстовым полем, то когда текстовое поле утратит фокус, ничего не произойдет.

Вместо этого код должен будет вручную инициировать обновление. Например, можно было бы добавить кнопку Add (Добавить), которая вызовет метод **`BindingExpression.UpdateSource()`**, инициируя немедленное обновление размера шрифта. Разумеется, прежде чем можно будет вызвать метод `BindingExpression.UpdateSource()`, нужен способ получения объекта `BindingExpression`. Объект `BindingExpression` — это тонкая упаковка, которая содержит в себе две вещи: уже известный объект `Binding` (предоставленный через свойство `BindingExpression.ParentBinding`) и объект, привязанный от источника (`BindingExpression.DataItem`).

Вдобавок объект `BindingExpression` предоставляет два метода для запуска немедленного обновления одной части привязки: `UpdateSource()` и `UpdateTarget()`.

Для получения объекта `BindingExpression` используется метод `GetBindingExpression()`, унаследованный каждым элементом от базового класса `FrameworkElement`, которому передается целевое свойство, имеющее привязку.

#### Привязка к объектам
[67ef67e35040133e8429f2e5](https://professorweb.ru/my/WPF/binding_and_styles_WPF/level8/8_6.php)

До сих пор добавлялись привязки, которые устанавливали связь между двумя элементами. Однако в приложениях, управляемых данными, чаще создаются выражения привязки, которые извлекают данные из невизуальных объектов. Единственное требование, которое должно при этом соблюдаться — информация, которую необходимо отобразить, должны храниться в *общедоступных свойствах*. Инфраструктура привязки данных WPF не может извлекать приватную информацию или читать общедоступные поля.

При привязке к объекту, не являющемуся элементом, следует отказаться от свойства `Binding.ElementName` и применять вместо него одно из следующих свойств:

- **`Source`**

    Ссылка, указывающая на исходный объект; другими словами, это объект, поставляющий данные.

- **`RelativeSource`**

    Указывает на исходный объект, использующий объект `RelativeSource`, который позволяет базировать ссылку на текущем элементе. Это специализированный инструмент, который удобен при написании шаблонов элементов управления и шаблонов данных.

- **`DataContext`**

    Если источник не был указан с помощью свойства `Source` или `RelativeSource`, то среда WPF производит поиск в дереве элементов, начиная с текущего элемента. Она проверяет свойство `DataContext` каждого элемента и использует первый из них, который не равен `null`. Свойство `DataContext` исключительно полезно, когда нужно привязать несколько свойств одного объекта к разным элементам, потому что можно установить свойство `DataContext` высокоуровневого объекта контейнера, вместо его установки непосредственно на целевой элемент.

Ниже эти варианты описаны более подробно.

##### Свойство Source
Свойство `Source` достаточно прямолинейно. Единственный момент, который следует учитывать — объект данных должен быть сделан удобным для привязки. Как будет показано, для получения объекта данных существует несколько подходов: извлечь его из ресурса, генерировать программно или получить от поставщика данных.

Простейший вариант — установить `Source` в некоторый готовый и доступный статический объект. Например, можно создать статический объект в коде и использовать его. Или же можно применить ингредиент из библиотеки классов .NET, как показано ниже:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        FontFamily="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"
        Text="Текст"></TextBox>
```

Это выражение привязки получает объект `FontFamily`, который предоставлен свойством `SystemFonts.IconFontFamily`. (Обратите внимание, что для установки свойства `Binding.Source` понадобится помощь расширения разметки `Static`.) Затем свойство `Binding.Path` устанавливается в свойство `FontFamily.Source`, которое выдает имя семейства шрифтов. Результатом будет единственная строка текста. В Windows Vista или Windows 7 имя шрифта выглядит как Segoe UI.

Другой вариант состоит в привязке к объекту, который ранее создавался в виде ресурса. Например, следующая разметка создает объект `FontFamily`, указывающий на шрифт `Calibri`:
```xml
<Window.Resources>
        <FontFamily x:Key="CustomFont">Calibri</FontFamily>
</Window.Resources>
    ...
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           FontFamily="{Binding Source={StaticResource CustomFont}, Path=Source}"
           Text="Текст"></TextBox>
```

##### Свойство RelativeSource
Свойство `RelativeSource` позволяет установить его в исходный объект на основе его отношения к целевому объекту. Например, свойством `RelativeSource` можно воспользоваться для привязки элемента к самому себе или для привязки к родительскому элементу, который находится в неизвестном количестве уровней выше в дереве элементов.

Для установки свойства `Binding.RelativeSource` применяется объект `RelativeSource`. Это несколько усложняет синтаксис, поскольку нужно создать объект `Binding` и внутри него — вложенный объект `RelativeSource`. Один вариант состоит в использовании синтаксиса установки свойства вместо расширения разметки `Binding`.

Например, в следующем коде создается объект `Binding` для свойства `TextBlock.Text`. Объект `Binding` использует `RelativeSource`, которое ищет родительское окно и отображает заголовок окна:
```xml
<TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}">
           <TextBlock.Text>
                    <Binding Path="Title">
                        <Binding.RelativeSource>
                            <RelativeSource Mode="FindAncestor" AncestorType="{x:Type Window}"></RelativeSource>
                        </Binding.RelativeSource>
                    </Binding>
           </TextBlock.Text>
</TextBlock>
```

Для объекта `RelativeSource` выбран режим `FindAncestor`, который заставляет его осуществлять поиск вверх по дереву элементов до тех пор, пока не будет найден тип элемента, определенный свойством `AncestorType`.

Наиболее общий способ записи этой привязки состоит в комбинировании ее в одну строку, используя расширения разметки `Binding` и `RelativeSource`, как показано ниже:
```xml
Text="{Binding Path=Title, RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"
```

Режим `FindAncestor` — один из четырех возможных вариантов при создании объекта `RelativeSource`. Все варианты кратко описаны ниже:

- **`Self`**

    Выражение привязывается к другому свойству того же элемента

- **`FindAncestor`**

    Выражение привязывается к родительскому элементу. WPF будет проводить поиск вверх по дереву элементов, пока не найдет нужный родительский элемент. Чтобы указать родителя, необходимо также установить свойство `AncestorType` для индикации типа родительского элемента, который должен быть найден. Дополнительно с помощью свойства `AncestorLevel` можно пропустить определенное количество совпадений указанного элемента. Например, если требуется привязка к третьему элементу типа `ListBoxItem` при восхождении вверх по дереву, то следует установить `AncestorType={x:Type ListBoxItem}` и `AncestorLevel=3`, тем самым пропуская первые два `ListBoxItem`. По умолчанию `AncestorLevel` равен 1, и поиск прекращается на первом найденном элементе.

- **`PreviousData`**

    Выражение осуществляет привязку к предыдущему элементу данных в списке, привязанном к данным. Это можно использовать в элементе списка

- **`TemplatedParent`**

    Выражение осуществляет привязку к элементу, к которому применен шаблон. Этот режим работает, только если привязка находится внутри шаблона элемента управления или шаблона данных

На первый взгляд свойство `RelativeSource` может показаться излишним усложнением разметки. В конце концов, почему бы просто не привязаться непосредственно к необходимому источнику, используя свойство `Source` или `ElementName`? Однако, это не всегда возможно, и обычно потому, что объект-источник и целевой объект находятся в разных частях разметки. Так получается при создании шаблонов элементов управления и шаблонов данных. Например, при построении шаблона данных, который изменяет способ представления элементов в списке, может понадобиться доступ к объекту `ListBox` верхнего уровня, чтобы прочитать какое-то его свойство.

##### Свойство DataContext
В некоторых случаях имеется множество элементов, привязанных к одному объекту. Например, рассмотрим следующую группу элементов `TextBlock`, каждый из которых использует исходное выражение привязки для извлечения различных деталей о шрифте, значков по умолчанию, включая промежутки между строками, стиль и вес первой гарнитуры (то и другое — просто Regular). Можете воспользоваться свойством `Source` для каждого из них, но это приводит к довольно длинной разметке:
```xml
<StackPanel Margin="10">
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=LineSpacing}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Weight}"></TextBlock>
        <TextBlock Text="{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Style}"></TextBlock>
</StackPanel>
```

В такой ситуации было бы яснее и удобнее определить источник привязки один раз с помощью свойства `FrameworkElement.DataContext`. В данном примере имеет смысл установить свойство `DataContext` элемента `StackPanel`, содержащего в себе все элементы `TextBlock`. (Можно было бы также установить свойство `DataContext` на еще более высоком уровне, например, на уровне всего окна, но лучше определить его насколько возможно уже, чтобы яснее выразить намерения.)

Установить свойство `DataContext` элемента можно таким же образом, как устанавливается свойство `Binding.Source`. Другими словами, можно встроить объект, извлечь его из статического свойства либо получить из ресурса, как показано ниже:
```xml
<StackPanel DataContext="{х:Static SystemFonts.IconFontFamily}">
```

После этого выражения привязки упрощаются за счет исключения некоторой информации об источнике:
```xml
<TextBlock Margin="5" Text="{Binding Path=Source}"></TextBlock>
```

Когда информация об источнике отсутствует в выражении привязки, WPF проверяет свойство `DataContext` элемента. Если оно равно `null`, WPF ищет в дереве элементов первый контекст данных, отличный от `null`. (Изначально свойства `DataContext` всех элементов равны `null`.) Если подходящий контекст данных обнаружен, то он используется для привязки. Если же нет, то выражение привязки не передает никакого значения целевому свойству.

### Привязка данных
<dfn title="привязка данных">Привязка данных</dfn> (data binding) в графической системе WPF представляет собою отношение, которое сообщает WPF о необходимости извлечения данных из свойства исходного объекта (Source) и использования её для задания значения некоторого свойства целевого объекта (Target) (и, в некоторых случаях, наоборот).

Объектом-источником может быть как элемент WPF, так и объект ADO.NET или пользовательский объект, хранящий данные.

#### Режимы привязки
В выражении привязки с помощью параметра `Mode` можно задать одно из следующих пяти значений режима привязки:
1) `OneWay` – целевое свойство обновляется при изменении исходного свойства.

2) `OneTime` – первоначально значение исходного свойства копируется в целевое свойство, но дальнейшие изменения исходного свойства не учитываются.

3) `TwoWay` — целевое свойство обновляется при изменении исходного свойства, исходное свойство обновляется при изменении целевое свойства.

4) `OneWayToSource` – исходное свойство обновляется при изменении целевое свойства.

5) `Default` – значение по умолчанию. Если целевое свойство устанавливается пользователем (например, `TextBox.Text`, `Slider.Value`, `CheckBox.IsChecked`, …), то это `TwoWay`, в остальных случаях – это `OneWay`.

Пример выражения привязки с параметром Mode: `{Binding ElementName=slider1, Path=Value, Mode=OneTime}`.

#### Особенности
Свойство `EditingMode` (тип данных `InkCanvasEditingMode`) элемента управления `InkCanvas` нельзя напрямую связать с текстовым свойством выпадающего списка `ComboBox` или списка `ListBox`, т.к. в этом случае будет несовпадение типов. Для привязки данных необходимо, чтобы тип элементов списка совпадал с типом свойства `EditingMode`. Для этой цели необходимо добавить в  ресурсы окна приложения (элемент `Windows.Resources`) массив (элемент `x:Array`) элементов типа `InkCanvasEditingMode` (атрибут `x:Type`), данному ресурсу необходимо задать ключ (атрибут `x:Key`), который необходимо указать в свойстве `ItemSource` списка `ListBox` или выпадающего списка `ComboBox`. В этом случае можно будет осуществить привязку данных между свойством `EditingMode` и выделенным элементом списка:
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyEditingModes" x:Type="{x:Type InkCanvasEditingMode}">
      <x:Static Member="InkCanvasEditingMode.Ink"/>
      <x:Static Member="InkCanvasEditingMode.Select"/>
      <x:Static Member="InkCanvasEditingMode.EraseByPoint"/>
      <x:Static Member="InkCanvasEditingMode.EraseByStroke"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas EditingMode="{Binding ElementName=lbEditingModes, Path=SelectedValue}" />
    <ListBox x:Name="lbEditingModes" ItemsSource="{StaticResource MyEditingModes}" />
  </StackPanel>
</Window>
```

Аналогичным образом можно задать привязку данных между свойством  `DefaultDrawingAttributes` и выделенным элементом списка (в данном случае массив  `x:Array` будет содержать элементы типа `DrawingAttributes`):
```xml
<Window x:Class="WpfApplication1.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
  <Window.Resources>
    <x:Array x:Key="MyDrawingAttributes" x:Type="{x:Type DrawingAttributes}">
      <DrawingAttributes Color="Red" Width="3" Height="3"/>
      <DrawingAttributes Color="Green" Width="10" Height="10"/>
      <DrawingAttributes Color="Blue" Width="15" Height="15"/>
    </x:Array>
  </Window.Resources>
  <StackPanel>
    <InkCanvas DefaultDrawingAttributes="{Binding ElementName=lbColors, Path=SelectedValue}" />
    <ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}" />
  </StackPanel>
</Window>
```

Недостатком последнего примера является то, что все элементы в списке выводятся с текстом «System.Windows.Ink.DrawingAttributes». Для придания элементам списка осмысленного содержания, необходимо определить шаблон элементов (`ListBox.ItemTemplate`), в котором определить, каким образом элементы списка будут отображены на экране (например, в виде текстового блока, содержащего поле `Color`):
```xml
<ListBox x:Name="lbColors" ItemsSource="{StaticResource MyDrawingAttributes}">
  <ListBox.ItemTemplate>
    <DataTemplate>
      <TextBlock Text="{Binding Path=Color}"></TextBlock>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
```
