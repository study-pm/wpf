## Bindings / Привязки

- [Bindings / Привязки](#bindings--привязки)
  - [Привязка элементов](#привязка-элементов)
    - [Связывание элементов](#связывание-элементов)
      - [Ошибки привязки](#ошибки-привязки)
    - [Режимы привязки](#режимы-привязки)
    - [Создание привязки в коде](#создание-привязки-в-коде)
    - [Множественные привязки](#множественные-привязки)
    - [Обновление привязок](#обновление-привязок)

В WPF существует несколько видов привязок, которые позволяют связывать свойства элементов управления с данными из различных источников. Основные виды привязок включают:

1. <dfn title="привязка элементов">Привязка элементов</dfn> — это механизм, позволяющий связывать свойства различных элементов управления между собой. Это позволяет синхронизировать значения свойств элементов, что упрощает создание динамического и отзывчивого пользовательского интерфейса.

    Пример:
    ```xml
    <TextBox x:Name="textBox1" />
    <TextBlock Text="{Binding ElementName=textBox1, Path=Text}" />
    ```

2. <dfn title="привязка данных">Привязка данных</dfn> — это процесс установки соединения между пользовательским интерфейсом и отображаемыми данными. Если для привязки заданы правильные настройки, а изменения значений данных сопровождаются правильными уведомлениями, привязанные к данным элементы автоматически отражают изменения.

    Пример:
    ```xml
    <ListBox ItemsSource="{Binding Path=Employees}" />
    ```

3. <dfn title="вложенная привязка">Вложенные привязки</dfn> позволяют использовать несколько привязок одновременно для одного свойства. В WPF существуют три вида вложенных привязок:

   - **`Binding`**: Стандартная привязка.

   - **`PriorityBinding`**: Выполняет привязку к нескольким источникам с приоритетом.

   - **`MultiBinding`**: Объединяет несколько значений из разных источников в одно.

   Пример `MultiBinding`:
   ```xml
   <TextBlock>
       <TextBlock.Text>
           <MultiBinding StringFormat="{}{0} {1}">
               <Binding Path="FirstName" />
               <Binding Path="LastName" />
           </MultiBinding>
       </TextBlock.Text>
   </TextBlock>
   ```

### Привязка элементов

#### Связывание элементов
Простейший сценарий привязки данных подразумевает ситуацию, когда исходным объектом является элемент WPF, а исходным свойством — свойство зависимости. Причина в том, что свойство зависимости имеет встроенную поддержку уведомлений об изменениях. В результате, когда значение свойства зависимости изменяется в исходном объекте, привязанное свойство целевого объекта немедленно обновляется. Это именно то, что требуется, и происходит оно без необходимости построения любой дополнительной инфраструктуры.

Хотя привязка элемента к элементу является простейшим подходом, большинство разработчиков заинтересовано в нахождении самого общего подхода для реальных приложений. В общем, большая часть работы по привязке данных будет тратиться на привязку элементов к объектам данных. Это позволит отображать информацию, извлекаемую из внешнего источника (такого как база данных или файл). Однако привязка элемента к элементу также часто бывает полезной.

Например, ее можно использовать для автоматизации способа, которым элементы взаимодействуют, так что когда пользователь модифицирует один элемент управления, другой элемент обновляется автоматически. Это ценное сокращение, которое избавляет от написания громоздкого и рутинного кода (и это прием, не доступный в предыдущем поколении приложений Windows Forms).

Чтобы понять, как привязывать один элемент к другому, рассмотрим простое окно. Оно содержит два элемента управления: `Slider` (ползунок) и `TextBlock` (текстовый блок) с единственной строкой текста. Перемещение ползунка вправо приводит к немедленному увеличению размера шрифта текста, а перемещение влево — к уменьшению размера шрифта.

*XAML*:
```xml
<Slider Margin="5" Minimum="1" Maximum="72" Value="12" Name="sld"
                TickFrequency="5" TickPlacement="BottomRight"></Slider>
<TextBlock Margin="5" Text="Какой-то текст"
            FontSize="{Binding ElementName=sld, Path=Value}"></TextBlock>
```

Привязка определена в элементе `TextBlock`. Вместо установки `FontSize` с использованием литерального значения применяется выражение привязки.

Выражения привязки данных используют расширение разметки XAML (и потому помещаются в фигурные скобки). В начале идет слово `Binding`, потому что создается экземпляр класса **`System.Windows.Data.Binding`**. Хотя объект `Binding` может быть сконфигурирован различными способами, в данной ситуации необходимо установить только два свойства: `ElementName`, которое указывает исходный элемент, и `Path`, указывающее свойство в исходном элементе.

Вместо `Property` используется `Path`, потому что `Path` может указывать на свойство свойства (например, `FontFamily.Source`) или индексатор, используемый свойством (например, `Content.Children[0]`). Путь может включать множество фрагментов, переходящих от свойства к свойству, и т.д.

Чтобы сослаться на присоединенное свойство (свойство, которое определено в другом классе, но применяется к привязанному элементу), имя свойства должно быть указано в круглых скобках. Например, в случае привязки к элементу, помещенному в `Grid`, путь `(Grid.Row)` извлекает номер строки, в которой он находится.

##### Ошибки привязки
WPF не генерирует исключения для уведомления о проблемах привязки данных. Если указан несуществующий элемент или свойство, никакого сообщения об этом не будет; вместо этого данные просто не попадут в целевое свойство. На первый взгляд это может показаться кошмаром для отладки. К счастью, WPF выводит трассировочную информацию, которая детализирует сбои в привязке. Во время отладки приложения эта информация появляется в выходном окне Visual Studio.

Например, попытка привязки к несуществующему свойству приводит к выводу в выходное окно следующего сообщения:
```
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.App"
Шаг с заходом: обход кода, не являющегося кодом пользователя "WpfApplication1.App.InitializeComponent"
System.Windows.Data Error: 40 : BindingExpression path error:
'SliderValue' property not found on 'object' ''Slider' (Name='sld')'
.BindingExpression:Path=SliderValue; DataItem='Slider' (Name='sld'); target element
is 'TextBlock' (Name=''); target property is 'FontSize' (type 'Double')
```

Среда WPF также игнорирует любые исключения, которые генерируются при попытке читать исходное свойство, и молча поглощает исключение, возникающее, если исходные данные не могут быть приведены к типу данных целевого свойства. Однако есть и другой способ справиться с этой проблемой — можно сообщить WPF о необходимости изменения внешнего вида исходного элемента для индикации возникшей ошибки. Например, неверный ввод можно пометить значком с восклицательным знаком или рамкой красного цвета.

#### Режимы привязки
Одной из ценных особенностей привязки данных является то, что цель обновляется автоматически, независимо от того, как модифицируется источник. В примере из предыдущей статьи источник может быть модифицирован только в одном направлении — через взаимодействие пользователя с ползунком. Однако рассмотрим несколько усложненную версию этого примера, в которой добавляется кнопка, при щелчке на которой изменяется положение ползунка:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    sld.Value += 5;
}
```

Этот код перемещает значение ползунка на 5 единиц, который, в свою очередь, изменяет размер шрифта текста через привязку данных. Это то же самое, как если бы вы двигали ползунок вручную. В этом и заключается основная сила привязки элементов.

Интересно, что существует способ заставить данные перемещаться в обоих направлениях: от источника к цели и от цели к источнику. Трюк заключается в установке свойства **`Mode`** объекта `Binding`. Ниже приведена усовершенствованная двунаправленная привязка, которая позволяет применять значения либо к источнику, либо к цели, и заставит противоположную часть привязки обновлять себя автоматически:
```xml
<TextBlock Margin="5" Text="Какой-то текст"
      FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBlock>
```

В рассматриваемом примере нет причин применять двунаправленную привязку (которая требует больше накладных расходов), поскольку эту проблему можно решить с помощью кода. Однако рассмотрим вариант этого примера, включающий текстовое поле, в котором пользователь может точно устанавливать размер шрифта. Этому текстовому полю понадобится двунаправленная привязка, чтобы оно могло как применять пользовательские изменения, так и отражать последнее значение размера, когда оно изменяется другим путем.

При установке свойства `Binding.Mode` можно использовать одно из пяти значений перечисления `System.Windows.Data.BindingMode`. Ниже приведен их полный список:

- **`OneWay`**

    Целевое свойство обновляется при изменениях исходного свойства

- **`TwoWay`**

    Целевое свойство обновляется при изменениях исходного свойства, а исходное свойство обновляется при изменении целевого свойства

- **`OneTime`**

    Целевое свойство устанавливается изначально на основе значения исходного свойства. Однако с этого момента изменения игнорируются (если только привязка не устанавливается на совершенно другой объект или не вызывается `BindingExpression.UpdateTarget()`). Обычно этот режим используется для сокращения накладных расходов, если известно, что целевое свойство не изменится

- **`OneWayToSource`**

    Подобно `OneWay`, но действует в обратном направлении. Исходное свойство обновляется, когда изменяется целевое свойство (что может показаться несколько странным), но целевое свойство никогда не обновляется

- **`Default`**

    Этот тип привязки зависит от целевого свойства. Это либо `TwoWay` (для устанавливаемых пользователем свойств, таких как `TextBox.Text`), либо `OneWay` (для всего остального). Все привязки используют данный подход, если только не указано иное

Вы уже видели `OneWay` и `TwoWay`. Значение `OneTime` достаточно очевидно. Оставшиеся два варианта требуют ряда дополнительных исследований.

Может возникнуть вопрос: зачем нужны две опции — и `OneWay`, и `OneWayToSource`? В конце концов, оба значения создают однонаправленную привязку, которая работает одинаковым образом. Единственное отличие в том, куда помещено выражение привязки. По сути, `OneWayToSource` позволяет поменять местами источник и цель, поместив выражение в то, что обычно считается источником привязки.

Наиболее общая причина использования этого трюка состоит в установке свойства, которое не является свойством зависимости. Как упоминалось, выражения привязки могут применяться только для установки свойств зависимости. Однако с помощью `OneWayToSource` это ограничение можно обойти, предоставляя в качестве свойства, поставляющего значение, свойство зависимости.

Изначально кажется логичным предположить, что все привязки однонаправленные, если только явно не указано иное. (В конце концов, именно так работает простой пример с ползунком.) Но на самом деле это не так. Чтобы убедиться в этом, вернемся к примеру с привязанным текстовым полем и позволим редактировать текущий размер шрифта. Если убрать установку `Mode=TwoWay`, этот пример все равно будет работать точно также. Причина в том, что WPF использует разные значения `Mode` по умолчанию, в зависимости от привязываемого свойства. (Формально в каждом свойстве зависимости присутствует фрагмент метаданных — флаг `FrameworkPropertyMetadata.BindsTwoWayByDefault`, который указывает, какую привязку должно использовать свойство: однонаправленную или двунаправленную).

Часто значение по умолчанию — именно то, что и нужно. Тем не менее, можно представить пример с текстовым полем только для чтения, которое пользователь не может изменять. В этом случае удается слегка сократить накладные расходы, установив режим однонаправленной привязки.

В качестве общего эмпирического правила: всегда неплохо явно устанавливать режим. Даже в случае текстового поля стоит подчеркнуть, что нужна двунаправленная привязка, включив свойство `Mode`.

#### Создание привязки в коде
При построении окна обычно наиболее эффективно объявлять выражение привязки в разметке XAML с помощью расширения разметки `Binding`. Тем не менее, допускается также создавать привязку и в коде.

Вот как можно создать привязку для элемента `TextBlock`, показанного в примере из предыдущей статьи:
```cs
Binding bind = new Binding();
bind.Source = sld;
bind.Path = new PropertyPath("Value");
bind.Mode = BindingMode.TwoWay;
txb.SetBinding(TextBlock.FontSizeProperty, bind);
```

Для удаления привязки в коде предусмотрены два статических метода класса **`BindingOperations`**. Метод `ClearBinding()` принимает ссылку на свойство зависимости, которое имеет привязку, подлежащую удалению, а метод `ClearAllBindings()` удаляет все привязки данных элемента:
```cs
BindingOperations.ClearAllBindings(txb);
```

И `ClearBinding()`, и `ClearAllBindings()` используют метод `ClearValue()`, который каждый элемент наследует от базового класса `DependencyObject`. Метод `ClearValue()` просто удаляет локальное значение свойства (которым в данном случае является выражение привязки).

Привязка на основе разметки применяется намного чаще, чем программная привязка, потому что она яснее и требует меньше работы. Однако код может применяться для создания привязки в некоторых специализированных сценариях:

- **Создание динамических привязок**

    Если необходимо тонко настраивать привязку на основе другой информации времени выполнения или создавать разные привязки в зависимости от обстоятельств, имеет смысл делать это в коде. (В качестве альтернативы можно было бы определить все необходимые привязки в коллекции `Resources` окна и просто добавить код, который вызывает `SetBinding()` с соответствующим объектом привязки.)

- **Удаление привязки**

    Чтобы удалить привязку и получить возможность установки свойства обычным образом, понадобится помощь метода `ClearBinding()` или `ClearAllBindings()`. Недостаточно просто присвоить новое значение свойству. В случае использования двунаправленной привязки установленное значение распространится на привязанный объект, и оба свойства останутся синхронизированными.

    С помощью методов `ClearBinding()` и `ClearAllBindings()` можно удалить любую привязку. Не имеет значения, применялась привязка программно или в коде XAML.

- **Создание специальных элементов управления**

    Чтобы облегчить для других модификацию визуального представления специального элемента управления, который разрабатывается, определенные детали (такие как обработчики событий и выражения привязки данных) понадобится перенести в код разметки.

#### Множественные привязки
В WPF в одном элементе управления разрешается использовать сколько угодно привязок. Можно модифицировать пример из предыдущей статьи, добавив к элементу `TextBlock` еще несколько привязок:
```xml
<StackPanel>
            <Slider Name="sld" Minimum="1" Maximum="72" Margin="10"
                TickFrequency="5" TickPlacement="BottomRight" Value="12"></Slider>
            <TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"></TextBox>
            <ListBox Margin="10" Name="lst">
                <ListBoxItem Tag="DarkBlue">
                    <Label>Dark Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="Blue">
                    <Label>Blue</Label>
                </ListBoxItem>
                <ListBoxItem Tag="LightBlue">
                    <Label>Light Blue</Label>
                </ListBoxItem>
            </ListBox>
            <!-- Используем несколько привязок -->
            <TextBlock Name="txb" Margin="10,5,0,10"
                       FontSize="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"
                       Text="{Binding ElementName=txt, Path=Text}"
                       Foreground="{Binding ElementName=lst, Path=SelectedItem.Tag, Mode=OneWay}"></TextBlock>
</StackPanel>
```

Допускается также реализовать привязку данных. Например, можно создать выражение привязки для свойства `TextBox.Text`, связывающее его со свойством `TextBlock.FontSize`, которое содержит выражение привязки, связывающее со свойством `Slider.Value`. В этом случае, когда пользователь перетаскивает ползунок в новую позицию, значение передается от `Slider` в `TextBlock` и затем из `TextBlock` в `TextBox`.

Хотя все работает прозрачно, более ясный подход состоит в том, чтобы привязать элементы как можно ближе к данным, которые они используют. В описанном здесь примере необходимо предусмотреть привязку и `TextBlock`, и `TextBox` непосредственно к свойству `Slider.Value`.

Все становится немного более интересно, когда на целевое свойство должны оказывать влияние более одного источника, например, если нужно иметь две равноправные привязки, устанавливающие одно и то же свойство. На первый взгляд это кажется невозможным. Однако существует несколько способов решения.

Простейший подход состоит в изменении режима привязки данных. Как уже известно, свойство `Mode` позволяет модифицировать способ работы привязки так, что данные передаются не только от источника к цели, но и от цели к источнику. С помощью такого приема можно создать несколько выражений привязки, устанавливающих одно и то же свойство. Последнее из них будет иметь эффект.

Чтобы понять, как это работает, рассмотрим вариацию примера элемента — панели с ползунком, который включает текстовое поле, куда можно поместить точное значение размера шрифта. В этом примере свойство `TextBlock.FontSize` может быть установлено двумя путями: перетаскиванием ползунка или вводом в текстовом поле размера шрифта. Все элементы управления синхронизированы так, что если вводится новое число в текстовом поле, размер шрифта текста примера изменяется и ползунок перемещается в соответствующую позицию.

Как уже упоминалось, к свойству `TextBlock.FontSize` можно применять только одну привязку данных. Поэтому имеет смысл оставить свойство `TextBlock.FontSize` в том виде, как оно есть, чтобы оно привязывалось прямо к ползунку.

Хотя добавить другую привязку к свойству `FontSize` нельзя, можно привязать новый элемент управления `TextBox` к свойству `TextBlock.FontSize`. Ниже показана необходимая для этого разметка:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
        Text="{Binding ElementName=txb, Path=FontSize, Mode=TwoWay}"></TextBox>
```

Теперь при каждом изменении свойства `TextBlock.FontSize` текущее значение будет вставляться в текстовое поле. Более того, значение в текстовом поле можно редактировать, применяя указанный размер шрифта. Обратите внимание, что для того, чтобы пример работал, свойство `TextBox.Text` должно использовать двунаправленную привязку, передающую данные в обоих направлениях. В противном случае текстовое поле сможет отображать значение `TextBlock.FontSize`, но не позволит изменять его.

С этим примером связано несколько нюансов:

- Поскольку значение свойства `Slider.Value` имеет тип `double`, при перетаскивании ползунка получается дробное значение размера. Установив свойство `TickFrequency` в 1 (или в некоторый целочисленный интервал), a свойство `IsSnapToTickEnabled` в `true`, можно ограничить значение ползунка только целыми величинами.

- Текстовое поле позволяет вводить буквы и другие нечисловые символы. В таком случае значение текстового поля не сможет быть интерпретировано как число. В результате привязка данных молча потерпит неудачу, а значение размера шрифта станет равно 0. Другой подход мог бы состоять в обработке нажатий клавиш в текстовом поле, чтобы вообще предотвратить неправильный ввод, либо в использовании проверки достоверности.

- Изменения, которые вносятся в текстовое поле, не будут применены до тех пор, пока текстовое поле не потеряет фокус (например, когда с помощью клавиши `<Tab>` происходит переход на другой элемент управления). Если такое поведение не подходит, можно обеспечить непрерывное обновление, используя свойство `UpdateSourceTrigger` объекта `Binding`.

Интересно, что показанное здесь решение — не единственный способ привязки текстового поля. Столь же разумно конфигурировать текстовое поле таким образом, чтобы оно изменяло значение свойства `Slider.Value` вместо свойства `TextBlock.FontSize`:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
           Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay}"></TextBox>
```

Теперь изменение текстового поля инициирует изменение положения ползунка, которое затем установит новый размер шрифта текста. Опять-таки, данный подход работает только с двунаправленной привязкой данных.

И, наконец, можно поменять местами роли ползунка и текстового поля, чтобы ползунок привязывался к текстовому полю.

В случае привязки `Slider.Value` текстовое поле ведет себя несколько иначе, чем в предыдущих двух примерах. Любые изменения, которые вносятся в текстовое поле, применяются немедленно, вместо того, чтобы ожидать момента утери фокуса.

Как видно из примера, двунаправленные привязки обеспечивает значительную гибкость. Их можно использовать для применения изменений от источника к цели и от цели к источнику. Допускается их применение в комбинации, что позволяет создать неожиданно сложные окна без какого-либо кода.

Обычно решение относительно того, куда применять выражение привязки, диктуется логикой модели кодирования. В предыдущем примере, возможно, было бы больше смысла поместить привязку в свойство `TextBox.Text` вместо свойства `Slider.Value`, потому что текстовое поле — это необязательное дополнение к вполне готовому примеру, а не основной ингредиент, на который полагается ползунок.

Также имело бы больше смысла привязать текстовое поле непосредственно к свойству `TextBlock.FontSize` вместо свойства `Slider.Value`. (Концептуально вы заинтересованы в том, чтобы видеть текущий размер шрифта, и ползунок — только один из способов его установки. Даже несмотря на то, что положение ползунка совпадает с размером шрифта, это — необязательная дополнительная деталь, если вы пытаетесь написать максимально ясную разметку.) Конечно, эти решения субъективны и определяются стилем кодирования. Наиболее важный урок состоит в том, что три подхода могут обеспечить одинаковое поведение.

В следующих статьях мы рассмотрим две детали, касающиеся этого примера. Во-первых, речь пойдет о возможных выборах при установке направления привязки. Во-вторых, будет показано, каким образом точно указать WPF, когда имеет смысл обновлять исходное свойство при двунаправленной привязке.

#### Обновление привязок
В примере из предыдущей статьи (где `TextBox.Text` привязывается к `TextBlock.FontSize`) имеется еще один нюанс. При попытке изменить отображаемый размер шрифта, вводя значение в текстовое поле, ничего не происходит. Изменение не применяется до тех пор, пока не будет совершен переход на другой элемент. Это поведение отличается от поведения, которое демонстрировалось в примере с ползунком. Там новый размер шрифта применялся после перетаскивания ползунка в другую позицию, т.е. в переходе на другой элемент вообще не было необходимости.

Чтобы понять это различие, следует повнимательнее присмотреться к выражениям привязки, которые используются этими двумя элементами управления. Когда применяется привязка `OneWay` или `TwoWay`, измененное значение распространяется от источника к цели немедленно. В случае с ползунком есть однонаправленное выражение привязки в `TextBlock`. Таким образом, изменения в свойстве `Slider.Value` немедленно отражаются в свойстве `TextBlock.FontSize`. То же поведение имеет место в примере с текстовым полем: изменения в источнике (которым является `TextBlock.FontSize`) немедленно влияют на цель (`TextBox.Text`).

Однако изменения, протекающие в обратном направлении — от цели к источнику — не обязательно происходят немедленно. Вместо этого их поведение управляется свойством **`Binding.UpdateSourceTrigger`**, которое принимает одно из значений, описанных ниже. Когда текст берется из текстового поля и используется для обновления свойства `TextBlock.FontSize`, это пример обновления цель-источник, которое использует поведение `UpdateSourceTrigger.LostFocus`.

- **`PropertyChanged`**

    Источник обновляется немедленно, когда изменяется целевое свойство

- **`LostFocus`**

    Источник обновляется немедленно, когда изменяется целевое свойство и цель теряет фокус

- **`Explicit`**

    Источник не обновляется, пока не будет вызван метод `BindingExpression.UpdateSource()`

- **`Default`**

    Поведение обновления определяется метаданными целевого свойства (формально — его свойства `FrameworkPropertyMetadata.DefaultUpdateSourceTrigger`). Для большинства свойств поведением по умолчанию будет `PropertyChanged`, хотя свойство `TextBox.Text` обладает поведением по умолчанию `LostFocus`

Помните, что эти значения не оказывают эффекта на обновление цели. Они просто управляют тем, как обновляется источник в привязках `TwoWay` и `OneWayToSource`.

Вооружившись этим знанием, можно усовершенствовать пример с текстовым полем, чтобы изменения применялись к размеру шрифта по мере их ввода в текстовое поле:
```xml
<TextBox Name="txt" Margin="10" MinHeight="26" VerticalContentAlignment="Center"
       Text="{Binding ElementName=sld, Path=Value, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"></TextBox>
```

Поведением по умолчанию свойства `TextBox.Text` является `LostFocus` просто потому, что текст в текстовом поле будет изменяться непрерывно в процессе пользовательского ввода, вызывая множественные обновления. В зависимости от того, как исходный элемент управления обновляет себя, режим обновления `PropertyChanged` может сделать приложение более медлительным. Вдобавок это может заставить исходный объект обновлять себя до завершения редактирования, что создаст проблемы при проверке достоверности.

Для полного контроля над моментом обновления исходного объекта можно выбрать режим `UpdateSourceTrigger.Explicit`. Если воспользоваться этим подходом в примере с текстовым полем, то когда текстовое поле утратит фокус, ничего не произойдет.

Вместо этого код должен будет вручную инициировать обновление. Например, можно было бы добавить кнопку Add (Добавить), которая вызовет метод **`BindingExpression.UpdateSource()`**, инициируя немедленное обновление размера шрифта. Разумеется, прежде чем можно будет вызвать метод `BindingExpression.UpdateSource()`, нужен способ получения объекта `BindingExpression`. Объект `BindingExpression` — это тонкая упаковка, которая содержит в себе две вещи: уже известный объект `Binding` (предоставленный через свойство `BindingExpression.ParentBinding`) и объект, привязанный от источника (`BindingExpression.DataItem`).

Вдобавок объект `BindingExpression` предоставляет два метода для запуска немедленного обновления одной части привязки: `UpdateSource()` и `UpdateTarget()`.

Для получения объекта `BindingExpression` используется метод `GetBindingExpression()`, унаследованный каждым элементом от базового класса `FrameworkElement`, которому передается целевое свойство, имеющее привязку.
