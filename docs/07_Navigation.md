## Navigation / Навигация

- [Navigation / Навигация](#navigation--навигация)
  - [Основные подходы к навигации](#основные-подходы-к-навигации)
  - [Оконная навигация](#оконная-навигация)
    - [Окно](#окно)
    - [Важнейшие свойства окна](#важнейшие-свойства-окна)
  - [Страничная навигация](#страничная-навигация)
    - [Страничные интерфейсы](#страничные-интерфейсы)
      - [Окно навигации](#окно-навигации)
      - [Класс Page](#класс-page)
    - [Гиперссылка](#гиперссылка)
      - [Навигация по веб-сайтам](#навигация-по-веб-сайтам)
    - [Размещение страниц](#размещение-страниц)
      - [Размещение страниц во фрейме](#размещение-страниц-во-фрейме)
      - [Размещение страниц внутри другой страницы](#размещение-страниц-внутри-другой-страницы)
    - [Хронология страниц](#хронология-страниц)
      - [Хронология навигации](#хронология-навигации)
    - [Служба навигации](#служба-навигации)
      - [Программная навигация](#программная-навигация)
      - [События навигации](#события-навигации)
    - [Управление журналом навигации](#управление-журналом-навигации)
    - [Добавление в журнал специальных элементов](#добавление-в-журнал-специальных-элементов)

### Основные подходы к навигации
В WPF существуют несколько видов навигации, которые можно использовать для создания приложений с разными моделями взаимодействия. Основные виды навигации включают:

- <dfn title="оконная навигация">Оконная навигация</dfn> — это традиционный подход, при котором приложение состоит из нескольких окон (`Window`). Каждое окно может содержать различные элементы управления и может быть открыто независимо от других окон. Эта модель широко используется в настольных приложениях, где пользователю необходимо взаимодействовать с несколькими окнами одновременно.

- <dfn title="страничная навигация">Страничная навигация</dfn> в WPF реализуется с помощью класса `Page`. Она напоминает навигацию в веб-приложениях, где пользователь перемещается между страницами. Эта модель часто используется в простых приложениях или для создания приложений, которые могут работать внутри браузера (XBAP), или для создания мастеров и справочных систем. Использует журнал для запоминания истории переходов и позволяет возвращаться к предыдущим страницам. Основные элементы страничной навигации включают:

  - `Page`: Представляет собой отдельную страницу.

  - `NavigationService`: Служба, которая управляет переходами между страницами.

  - `NavigationWindow`: Окно, которое содержит страницы и обеспечивает навигацию между ними.

- <dfn title="навигация с использованием фреймов">Навигация с использованием фреймов</dfn> в WPF — это мощный и гибкий способ создания приложений с поддержкой переходов между страницами. Как и предыдущий, этот вид обеспечивает навигацию между страницами, но страничная навигация более тесно связана с возможностью работы в браузере и поддержкой журнала переходов, в то время как навигация с помощью фреймов более гибка и подходит для автономных приложений, где необходимо создать навигацию между страницами внутри одного окна. Основные компоненты, участвующие в этой навигации, включают:

  - `Frame` — это элемент управления, который позволяет содержать и отображать страницы (`Page`). Он обеспечивает поддержку навигации между страницами, аналогичную браузерной навигации. `Frame` может быть размещен внутри главного окна приложения (`MainWindow`) и служит контейнером для страниц.

  - `Page`— это класс, представляющий отдельную страницу в приложении. Каждая страница может содержать различные элементы управления и может быть создана как отдельный XAML-файл. Страницы наследуют класс `Page` и могут быть загружены в `Frame` для отображения.

  - `NavigationService` — это служба, которая управляет переходами между страницами. Она позволяет программно переходить между страницами, используя методы `Navigate`, `GoBack`, и `GoForward`. Доступ к `NavigationService` можно получить через `Frame` или `NavigationWindow`, в которых размещена страница.

- <dfn title="структурная навигация">Структурная навигация</dfn> — это более сложная модель, которая позволяет передавать параметры между страницами и возвращать результаты. Она часто используется для реализации диалогов или мастеров, где страницы взаимодействуют друг с другом. Структурная навигация часто используется в приложениях, где необходимо собрать данные на нескольких страницах или выполнить сложную логику, например, в мастерах или при добавлении новых записей в базу данных. Этот подход к навигации между страницами напоминает вызов методов в программировании. Основные компоненты и принципы:
  - `Page`: представляет собой отдельную страницу
  - `PageFunction<T>` — это специальный тип страницы, который позволяет возвращать значения после завершения работы.
  - **Передача данных**: Структурная навигация позволяет передавать данные между страницами. Когда одна страница вызывает другую, она может передавать необходимые параметры.
  - **Возврат результатов**: Вызванная страница может возвращать результаты вызывающей странице. Это может включать информацию о состоянии (например, подтверждение или отмена) и собранные данные.
  - **Журнал навигации**: Структурная навигация управляет журналом навигации так, чтобы вызванная страница удалялась из журнала после завершения работы, предотвращая повторное использование одного и того же экземпляра страницы.

Помимо этих основных видов, в WPF также можно использовать другие подходы к навигации, такие как создание пользовательских навигационных систем с помощью MVVM-паттерна.

### Оконная навигация
В основе большинства традиционных приложений Windows лежит окно с различными панелями инструментов и меню. Панели инструментов и меню являются своего рода "двигателем" приложения — когда пользователь на них щелкает, происходит какое-то действие, и появляются другие окна. В документных приложениях может существовать несколько одинаковых по степени важности "главных" окон, которые открываются одновременно, но в целом модель та же. Пользователи проводят большую часть своего времени в каком-то одном месте и переходят в другие окна, только когда это необходимо.

#### Окно
Определение:
```cs
[System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]
public class Window : System.Windows.Controls.ContentControl
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.window?view=windowsdesktop-9.0

Класс `Window` является определяет базовый вид окна, предоставляя такие свойства, как рамка (standard border), строка заголовка (title bar) и кнопки управления окном (maximize, minimize and close buttons). Окно в WPF представляет собой сочетание файлов XAML (.xaml) (где корневым элементом является `<Window>`) и файла отделенного кода (CodeBehind) (.cs). При создании нового WPF-приложения Visual Studio (Express) автоматически генерирует окно по умолчанию, выглядящее примерно так:
```xml
<Window x:Class="WpfApplication1.Window1"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    Title="Window1" Height="300" Width="300">
    <Grid>

    </Grid>
</Window>
```

Атрибут *`x:class`* сообщает файлу XAML о том, какой класс необходимо использовать — в данном случае это `Window1`, также автоматически создаваемый Visual Studio. Его можно обнаружить в дереве проекта VS как вложенный узел файла XAML. По умолчанию он выгядит примерно так:
```cs
using System;
using System.Windows;
using System.Windows.Controls;
//…more using statements

namespace WpfApplication1
{
    /// <summary>
    /// Interaction logic for Window1.xaml
    /// </summary>
    public partial class Window1 : Window
    {
        public Window1()
        {
            InitializeComponent();
        }
    }
}
```

Как видно, класс `Window1` определен как частичный (`partial`), поскольку во время выполнения (runtime) он объединяется с файлом XAML для создания полноценного окна. За это как раз ответственен вызов `InitializeComponent()`, который необходим для запуска и успешной работы полнофункционального окна.

Если вернуться к файлу XAML, то можно обратить внимание на несколько интересных атрибутов элемента `Window`, таких как `Title`, который определяет заголовок окна (title bar), а также начальные ширина и высота. Так же, здесь находится несколько определений пространств имен.

Также можно обратить внимание на то, что Visual Studio создаёт элемент `Grid` внутри `Window`. `Grid` является одним из контейнеров WPF, и хотя на его месте может быть любая панель или элемент управления, `Window` может содержать только один элемент в качестве прямого потомка, поэтому использование в этом качестве любого наследника класса `Panel`, который допускает вложение множества элементов, обычно является хорошим выбором.

#### Важнейшие свойства окна
Класс `Window` имеет несколько атрибутов, которые можно устанавливать для управления внешним видом и поведением окна приложения. Ниже представлен короткий список наиболее интересных:

- **`Icon`** — позволяет определить иконку окна, которая обычно расположена в левом верхнем углу, слева от заголовка.

- **`ResizeMode`** — управляет тем, может ли конечный пользователь изменять размер окна. Значение по умолчанию — `CanResize`, что позволяет пользователю изменять размер окна либо с помощью кнопок "свернуть"/"развернуть", либо перетягиванием за углы курсором мыши. `CanMinimize` позволяет пользователю свернуть окно, но запрещает разворачивать его на весь экран или изменять его размер. `NoResize` — самое строгое правило, которое убирает кнопки "свернуть"/"развернуть" и не позволяет менять размер окна.

- **`ShowInTaskbar`** — по умолчанию имеет значение `true`, но если переназначить его на `false`, то окно не будет представлено в панели задач `Windows`. Это свойство очень полезно, так как позволяет убрать с панели задач второстепенные окна или приложения, которые должны быть свернуты в трей.

- **`SizeToContent`** — определяет, будет ли окно автоматически менять свой размер, приспосабливаясь под содержимое. Значение по умолчанию — `Manual`, что означает, что окно не будет автоматически подстраивать свой размер. Другими опциями являются: `Width`, `Height` и `WidthAndHeight`, которые позволяют настроить автоподстройку размера окна по ширине, высоте, либо по двум параметрам сразу.

- **`Topmost`** — по умолчанию `false`, но при переключении на `true` окно будет оставаться на переднем плане (поверх остальных окон), если его не минимизировать, что в определенных ситуациях может быть полезным.

- **`WindowStartupLocation`** — управляет начальным положением окна. Значение по умолчанию `Manual`, означает, что окно при инициализации будет расположено в соответствии со свойствами окна `Top` и `Left`. Другими опциями являются `CenterOwner`, которая будет располагать окно в центре родительского окна и `CenterScreen`, располагающая окно в центре экрана.

- **`WindowState`** — регулирует начальное состояние окна. Оно может принимать значения `Normal`, `Maximized` или `Minimized`. По умолчанию `Normal`, которое используется в случае, если вы не хотите, чтобы при запуске окно было свернуто 
или развернулось на весь экран.

Следует иметь в виду, что помимо вышеописанных у `Window` имеется множество других атрибутов.

### Страничная навигация
В основе большинства традиционных приложений Windows лежит окно с различными панелями инструментов и меню. Панели инструментов и меню являются своего рода "двигателем" приложения — когда пользователь на них щелкает, происходит какое-то действие, и появляются другие окна. В документных приложениях может существовать несколько одинаковых по степени важности "главных" окон, которые открываются одновременно, но в целом модель та же. Пользователи проводят большую часть своего времени в каком-то одном месте и переходят в другие окна, только когда это необходимо.

Приложения Windows являются настолько привычными, что порой даже бывает трудно представить, каким еще образом можно разработать приложение. Однако в Интернете используется совершенно иная модель навигации, основанная на *страницах*, и разработчики настольных приложений осознали, что она удивительно хорошо подходит для создания приложений определенных типов.

Чтобы предоставить разработчикам возможность создавать настольные приложения в стиле веб-приложений, в состав WPF была включена собственная система страничной навигации, которая является удивительно гибкой по своей природе.

*[XBAP]: XAML Browser Applications
В настоящее время страничная модель чаще всего применяется в простых, облегченных приложениях (или для реализации небольших наборов средств в более сложных оконных приложениях). Однако она является замечательным вариантом в тех случаях, когда требуется упростить процесс развертывания. Причина в том, что WPF позволяет создавать страничные приложения, способные выполняться внутри браузера Internet Explorer или Firefox. Это означает, что пользователи получают возможность запуска таких приложений, не выполняя их явную установку, а просто указывая в браузерах нужное расположение. Такая модель называется ХВАР[^xbap].

[^xbap]: XBAP (англ. XAML Browser Application — браузерное приложение XAML) — это WPF-приложение, которые выполняется внутри браузера Web-страниц. В отличие от программной модели, используемой в технологиях ActiveX и Silverlight, где апплеты действительно загружаются внутри процесса браузера, XBAP-приложения *только* отображают своё содержимое в окне браузера, но при этом, как любое WPF-приложение, запускаются в виде отдельного процесса управляемого средой CLR. Для работы XBAPs требуются устаревшие браузеры, такие как Internet Explorer и старые версии Firefox. Эти старые браузеры обычно не поддерживаются в Windows 10 и Windows 11. Современные браузеры больше не поддерживают технологию, необходимую для приложений XBAP из-за рисков безопасности. Модули, позволяющие работу с XBAP, перестали поддерживаться.

И, наконец, в WPF существует элемент управления **WebBrowser**, который позволяет размещать HTML-страницы в WPF-окне. Этот элемент управления предоставляет возможность не только отображать веб-страницы, но также программно исследовать их структуру и содержимое (с использованием модели HTML DOM). Кроме того, он даже позволяет приложению взаимодействовать с кодом JavaScript.

Элемент управления WebBrowser, появился в версии WPF 3.5 SP1. Для получения похожей функциональности в предшествующих версиях WPF разработчики должны были использовать элемент управления WebBrowser из Windows Forms.

Обычное веб-приложение на вид значительно отличается от традиционного клиентского программного обеспечения с множеством функций. Пользователи веб-сайта проводят время, перемещаясь с одной страницы на другую. Если не считать всплывающие рекламные сообщения, они никогда не видят одновременно более одной страницы. При решении задачи (например, размещении заказа или выполнении сложного поиска) им приходится проходить эти страницы в линейной последовательности от начала до конца.

HTML не поддерживает сложных оконных возможностей настольных операционных систем, поэтому профессиональные веб-разработчики всегда полагаются на качественное проектное решение и понятные интерфейсы. Поскольку технологии веб-проектирования значительно усложнились, разработчики приложений Windows тоже начали замечать преимущества такого подхода. Но важнее то, что веб-модель является простой и хорошо отлаженной. Именно по этой причине новичками часто легче разобраться в использовании веб-сайтов, чем в работе с Windows-приложениями, хотя очевидно, что вторые обладают куда большим количеством возможностей.

Благодаря WPF, больше нет причин искать какой-то компромисс, потому что в состав WPF входит встроенная модель страниц с уже готовыми средствами навигации. Лучше всего то, что эту модель можно применять для создания самых разнообразных страничных приложений, приложений, использующих только какие-то определенные страничные функции (например, в мастере или справочной системе), или приложений, функционирующих непосредственно в браузере.

#### Страничные интерфейсы
Чтобы создать страничное приложение в WPF, нужно перестать применять для пользовательских интерфейсов в качестве контейнера высшего уровня класс `Window` и вместо него переключиться на класс **`System.Windows.Controls.Page`**.

Модель для создания страниц в WPF во многом похожа на модель для создания окон. Хотя создавать объекты страниц можно и с помощью одного лишь кода, обычно для каждой страницы создается файл XAML и файл отделенного кода. При компиляции этого приложения компилятор создает производный класс страницы, который объединяет написанный разработчиком код с генерируемыми автоматически связующими элементами (такими как поля, которые ссылаются на каждый именованный элемент на странице).

Страницу можно добавлять в любой проект WPF. Для этого в Visual Studio нужно выбрать в меню *Project* (*Проект*) пункт *Add Page* (*Добавить страницу*). Хотя страницы и являются самым высокоуровневым компонентом пользовательского интерфейса при проектировании приложения, во время его выполнения контейнером наивысшего уровня они уже не будут. Вместо этого они обслуживаются в другом контейнере. Именно в этом и состоит секрет гибкости, обеспечиваемой WPF в случае страничных приложений, ведь в качестве такого контейнера WPF позволяет использовать любой из нескольких следующих объектов:

- объект `NavigationWindow`, который представляет собой немного видоизмененную версию класса `Window`;

- объект `Frame`, находящийся внутри другого окна;

- объект `Frame`, находящийся внутри другой страницы;

- объект `Frame`, обслуживаемый непосредственно в Internet Explorer или Firefox.

В качестве примера простейшего страничного приложения давайте создадим следующую страницу:
```xml
<Page x:Class="WpfApplication1.Page1"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      Title="Page1" WindowTitle="Page1">
    <StackPanel Margin="5">
        <Label Margin="5">Пример обычной страницы</Label>
        <Button Margin="5,0,5,0" Padding="5">OK</Button>
        <Button Padding="5" Margin="5">Close</Button>
    </StackPanel>
</Page>
```

Теперь изменим содержимое файла *App.xaml* так, чтобы в качестве начальной страницы использовался файл этой страницы:
```xml
<Application x:Class="WpfApplication1.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="Page1.xaml">
    <Application.Resources></Application.Resources>
</Application>
```

При запуске этого приложения среде WPF хватит "интеллектуальных способностей", чтобы понять, что указывается страница, а не окно. Она автоматически создаст новый объект `NavigationWindow` для выполнения роли контейнера и отобразит страницу внутри него. Она также считает свойство `WindowTitle` и использует его значение в качестве заголовка окна.

Одно из отличий между страницей и окном заключается в том, что размер страницы обычно не устанавливается, поскольку он определяется обслуживающим ее контейнером (хостом). Если же для свойств `Width` и `Height` страницы все-таки указаны какие-то значения, страница делается именно такого размера, но часть ее содержимого может быть усечена, если размер окна хоста оказывается меньше, или размещена по центру доступного пространства, если его размер больше.

##### Окно навигации
Определение:
```cs
[System.Windows.Markup.ContentProperty]
[System.Windows.TemplatePart(Name="PART_NavWinCP", Type=typeof(System.Windows.Controls.ContentPresenter))]
public class NavigationWindow : System.Windows.Window, System.Windows.Markup.IUriContext
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.navigation.navigationwindow?view=windowsdesktop-9.0

Объект `NavigationWindow` более или менее похож на обычное окно, за исключением кнопок навигации "вперед" и "назад", которые отображаются в строке сверху. Поэтому нетрудно догадаться, что класс `NavigationWindow` унаследован от класса `Window` и имеет небольшой дополнительный набор связанных с навигацией свойств. Извлечь ссылку на содержащий объект `NavigationWindow` можно с помощью следующего кода:
```cs
// Извлечение ссылки на окно, содержащее текущую страницу
NavigationWindow win = (NavigationWindow)Window.GetWindow(this);
```

В конструкторе страницы данный код работать не будет, потому что на этом этапе страница пока еще не находится внутри своего контейнера, поэтому нужно дождаться хотя бы, когда возникнет событие `Page.Loaded`.

Особенность `NavigationWindow` в WPF заключается в его способности поддерживать навигацию между страницами в стиле браузера. Это позволяет создавать приложения, которые могут работать как автономно, так и внутри браузера (XBAP), обеспечивая пользователям возможность перемещаться между страницами с помощью навигационных кнопок.

Ключевые особенности `NavigationWindow`:

1. **Поддержка журнала навигации**: `NavigationWindow` поддерживает журнал навигации, что позволяет пользователям перемещаться назад и вперед между страницами, аналогично браузеру`.

2. **Возможность содержать разные типы содержимого**: `NavigationWindow` может содержать любой объект .NET Framework или HTML-файл, но обычно используется с объектами `Page` для навигации.

3. **Переходы между страницами**: Переходы между страницами осуществляются с помощью методов `Navigate`, которые могут принимать URI или объекты страниц.

4. **Визуализация навигации**: `NavigationWindow` автоматически отображает навигационные кнопки (назад и вперед) при необходимости, что позволяет пользователям перемещаться между страницами.

5. **Наследование от `Window`**: NavigationWindow является производным от Window, что означает, что он наследует все свойства и поведение окна, но добавляет функциональность навигации.

6. **Возможность настройки**: Стиль и поведение `NavigationWindow` можно настраивать, например, изменяя стиль навигационных кнопок или отключая их отображение.

В целом, `NavigationWindow` обеспечивает удобный способ создания приложений с навигацией между страницами, что делает его полезным для разработки мастеров, справочных систем или других приложений, требующих навигации в стиле браузера.

По возможности подхода с применением `NavigationWindow` лучше вообще избегать и использовать вместо него свойства класса `Page` (и службу навигации). Иначе страница будет тесно связана с контейнером `NavigationWindow`, и потому ее нельзя будет использовать повторно в других хостах.

При желании создать приложение, состоящее только из кода, для достижения эффекта, показанного на рисунке выше, потребовалось бы создать как страницу, так и навигационное окно. Код, который пришлось бы для этого использовать, показан ниже:
```cs
NavigationWindow win = new NavigationWindow()
win.Content = new Page1();
win.Show();
```

##### Класс Page
Определение:
```cs
[System.Windows.Markup.ContentProperty("Content")]
public class Page : System.Windows.FrameworkElement, System.Windows.Markup.IAddChild
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.page?view=windowsdesktop-9.0

Класс `Page` в WPF — это элемент, который представляет собой отдельную страницу в приложении. Он часто используется для создания страничных приложений, которые могут работать как автономно, так и внутри браузера (XBAP).

Подобно `Window`, класс `Page` допускает наличие только единственного вложенного элемента. Однако класс `Page` не является элементом управления содержимым: он на самом деле унаследован непосредственно от класса `FrameworkElement`. Вдобавок класс `Page` является более простым и отлаженным, чем класс `Window`. Он имеет небольшой набор дополнительных свойств, которые позволяют настраивать его внешний вид, взаимодействовать с контейнером только определенным, ограниченным образом и применять навигацию. Все эти свойства перечислены ниже:

- **`Background`**

    Принимает кисть, которая позволяет устанавливать заливку для фона

- **`Content`**

    Принимает один элемент, который отображается на странице. Обычно в роли такого элемента выступает контейнер компоновки, такой как `Grid` или `StackPanel`

- **`Foreground`**, **`FontFamily`** и **`FontSize`**

    Определяют внешний вид по умолчанию для текста внутри страницы. Значения этих свойств наследуются элементами внутри страницы. Например, если устанавливается заливка переднего плана и размер шрифта, по умолчанию содержимое внутри страницы получает эти же настройки

- **`WindowWidth`**, **`WindowHeight`** и **`WindowTitle`**

    Определяют внешний вид окна, в которое упаковывается страница. Эти свойства позволяют управлять хостом путем установки его ширины, высоты и заголовка. Однако они действуют только в том случае, если страница обслуживается в окне (а не во фрейме)

- **`NavigationService`**

    Возвращает ссылку на объект `NavigationService`, которую можно использовать для отправки пользователя на другую страницу программным путем

- **`KeepAlive`**

    Определяет, должен ли объект страницы оставаться действующим после перехода пользователя на другую страницу. Это свойсство определяет, должен ли экземпляр страницы сохраняться в журнале навигации после перехода пользователя на другую страницу. По умолчанию это свойство установлено в `false`, что означает, что при переходе на другую страницу текущая страница удаляется из памяти, а при возвращении к ней создается новый экземпляр страницы.

- **`ShowsNavigationUI`**

    Определяет, должен ли хост для данной страницы отображать навигационные элементы управления (кнопки "назад" и "вперед"). По умолчанию имеет значение `true`

- **`Title`**

    Устанавливает имя, которое должно применяться для страницы в хронологии навигации. Хост не использует свойство `Title` для установки заголовка в строке заголовка: для этой цели у него есть свойство `WindowTitle`

Также важно обратить внимание на отсутствующие компоненты — в классе `Page` нет эквивалентов для методов `Hide()` и `Show()`, доступных в классе `Window`. Если потребуется показать другую страницу, придется воспользоваться навигацией.

#### Гиперссылка

Определение:
```cs
[System.Windows.Documents.TextElementEditingBehavior(IsMergeable=false, IsTypographicOnly=false)]
public class Hyperlink : System.Windows.Documents.Span, System.Windows.Input.ICommandSource, System.Windows.Markup.IUriContext
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.documents.hyperlink?view=windowsdesktop-9.0

Наиболее простой способ позволить пользователю перемещаться с одной страницы на другую — это гиперссылки. В WPF гиперссылки являются не отдельными, а *внутристрочными потоковыми элементами*, которые обязательно должны размещаться внутри другого поддерживающего их элемента. (Причина такого проектного решения связана с тем, что гиперссылки и текст часто используются вперемешку.)

Например, ниже показано объединение текста и ссылок в элементе `TextBlock`, который является самым практичным контейнером для гиперссылок:
```xml
<TextBlock Margin="5">
      Это обычная страница. А это <Hyperlink NavigateUri="page2.xaml">ссылка на другую страницу!</Hyperlink>
</TextBlock>
```

Класс `Hyperlink` в WPF — это элемент управления, который позволяет создавать ссылки на другие страницы или внешние ресурсы. Он наследует класс `Span` и реализует интерфейсы `ICommandSource` и `IUriContext`.

Основные свойства и методы
- **`NavigateUri`**: Это свойство определяет URI, на который будет переходить приложение при щелчке на гиперссылку. Может указывать как на локальные страницы, так и на внешние ресурсы.

- **`RequestNavigate`**: Это событие возникает при щелчке на гиперссылку. Обработчик этого события может быть использован для программного управления навигацией.

- **`Command`**: Позволяет связать гиперссылку с командой, что может быть полезно для выполнения определенных действий при щелчке на ссылку.

Пример использования:
```xml
<TextBlock>
    <Hyperlink NavigateUri="http://www.example.com">Перейти на сайт</Hyperlink>
</TextBlock>
```

Программное создание гиперссылки:
```cs
TextBlock tb = new TextBlock();
Hyperlink hyperlink = new Hyperlink();
Run run = new Run();
run.Text = "Перейти на сайт";
hyperlink.NavigateUri = new Uri("http://www.example.com");
hyperlink.Inlines.Add(run);
tb.Inlines.Add(hyperlink);
```

Этот код создает гиперссылку программно и добавляет ее в `TextBlock`.

При визуализации гиперссылки отображаются как хорошо знакомый подчеркнутый текст синего цвета.

Щелчки на ссылке можно обрабатывать двумя способами: реагировать на событие `Click` и использовать код для выполнения какой-то задачи либо просто направлять пользователя на другую страницу. Однако существует и более простой подход. Класс `Hyperlink` также включает свойство **`NavigateUri`**, которое можно устанавливать так, чтобы оно указывало на любую другую страницу в приложении. В таком случае при щелчке на гиперссылке пользователи будут попадать на целевую страницу автоматически.

Свойство `NavigateUri` работает только в том случае, если гиперссылка размещается на странице. При желании использовать гиперссылку в оконном приложении, чтобы позволить пользователям выполнять какую-то задачу, переходить на веб-страницу или открывать новое окно, придется обрабатывать событие **`RequestNavigate`** и писать код самостоятельно.

Чтобы контролировать навигацию, можно обработать событие `RequestNavigate`. Например, чтобы открыть ссылку в системном браузере:
```cs
private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
{
    Process.Start(new ProcessStartInfo(e.Uri.ToString()) { UseShellExecute = true });
    e.Handled = true;
}
```

Этот код открывает ссылку в системном браузере вместо попытки загрузить ее внутри приложения.

Гиперссылки не являются единственным способом для перехода с одной страницы на другую. `NavigationWindow` включает две заметные кнопки: "назад" и "вперед" (если только они не скрыты установкой свойства `Page.ShowsNavigationUI` в `false`). Щелкая на этих кнопках, пользователи могут перемещаться по навигационной последовательности на одну страницу назад или вперед. Как и в окне браузера, пользователи также могут щелкать на стрелке раскрывающегося списка, отображаемой по краям этих кнопок, и просматривать всю последовательность, а также "перепрыгивать" сразу на несколько страниц назад или вперед.

В случае перехода на новую страницу, у которой свойство `WindowTitle` не установлено, окно сохраняет тот же заголовок, который был на предыдущей странице. Если свойство `WindowTitle` не устанавливается ни на одной странице, заголовок окна остается пустым.

##### Навигация по веб-сайтам
Интересно то, что также можно создавать и гиперссылку, указывающую на веб-содержимое. Когда пользователь щелкает на такой ссылке, в области страницы загружается целевая веб-страница:
```xml
<TextBlock Margin="5">
            Это обычная страница. А это
            <Hyperlink NavigateUri="http://professorweb.ru">ссылка на наш сайт</Hyperlink>
        </TextBlock></pre>
```

Однако при использовании такого приема обязательно должен быть присоединен обработчик к событию `Application.DispatcherUnhandledException` или `Application.NavigationFailed`. Попытка посещения веб-сайта может оказаться неудачной, если компьютер не подключен к сети, сайт не доступен или веб-содержимое отсутствует. В таком случае сеть возвращает ошибку вроде "404: File Not Found" (404: файл не найден), которая воплощается в исключение **`WebException`**. Для аккуратной обработки этого исключения и предотвращения неожиданного завершения работы приложения оно должно быть нейтрализовано с помощью следующего обработчика:
```cs
private void Application_NavigationFailed(object sender,
       System.Windows.Navigation.NavigationFailedEventArgs e)
{
   if (e.Exception is System.Net.WebException)
   {
         MessageBox.Show("Сайт "+e.Uri.ToString() + " не доступен :(");
         // Нейтрализовать ошибку, чтобы приложение продолжило свою работу
         e.Handled = true;
   }
}
```

`NavigationFailed` — это всего лишь одно из нескольких навигационных событий, которые определены в классе `Application`.

Попав на веб-страницу, пользователи смогут щелкать на доступных на ней ссылках и переходить на другие веб-страницы, оставляя исходное содержимое далеко позади. В действительности, они смогут вернуться на вашу WPF-страницу, только если воспользуются хронологией навигации для возврата назад, или если эта страница будет отображаться в специальном окне (как будет показано в следующем разделе), и это окно будет включать элемент управления, позволяющий вернуться обратно к вашему содержимому.

*[DOM]: Document Object Model
В случае отображения страниц с внешних веб-сайтов нельзя делать много вещей. Например, нельзя запретить пользователю переходить на какие-то конкретные страницы или сайты. Также нельзя и взаимодействовать с веб-страницей с помощью объектной модели документов **HTML DOM** (**Document Object Model** — **объектная модель документа**). Это означает, что сканировать страницу для поиска ссылок или изменять ее динамически тоже нельзя. Выполнение всех этих задач становится возможным только в случае использования элемента управления `WebBrowser`.

Последним приемом, который можно использовать с гиперссылкой, является навигация по фрагментам. Добавив знак `#` в конце `NavigateUri`, а за ним — имя элемента, можно сразу же переходить к конкретному элементу управления на странице. Однако такой прием работает, только если целевая страница является прокручиваемой (а таковой она является тогда, когда использует элемент управления `ScrollViewer` или обслуживается в веб-браузере).

#### Размещение страниц

##### Размещение страниц во фрейме
Элемент `NavigationWindow` является удобным контейнером, но не единственным вариантом. Страницы также можно размещать и непосредственно внутри других окон или даже внутри других страниц. Это подразумевает возможность создания чрезвычайно гибкой системы, поскольку означает, что одну и ту же страницу можно использовать многократно разными способами в зависимости от типа приложения, которое требуется создать.

Чтобы вставить страницу внутрь окна, нужно воспользоваться классом `Frame`. **Класс `Frame`** представляет собой элемент управления содержимым, который может удерживать любой элемент, но особенно полезен именно в качестве контейнера для страницы. Он включает свойство под названием `Source`, которое указывает на отображаемую страницу XAML.

Элемент управления `Frame` в WPF — это специальный вид элемента управления содержимым, который позволяет отображать и перемещаться по различным типам содержимого, включая XAML-страницы (Page) и HTML-страницы. Он часто используется для создания приложений с навигацией между страницами.

Определение:
```cs
[System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)]
[System.Windows.Markup.ContentProperty]
[System.Windows.TemplatePart(Name="PART_FrameCP", Type=typeof(System.Windows.Controls.ContentPresenter))]
public class Frame : System.Windows.Controls.ContentControl, System.Windows.Markup.IAddChild, System.Windows.Markup.IUriContext
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.controls.frame?view=windowsdesktop-9.0

Основные свойства и методы
- **`Source`**: Это свойство определяет URI содержимого, которое будет отображено внутри фрейма. Может быть как XAML-страницей, так и HTML-документом.

- **`Navigate`**: Метод позволяет программно переходить к новому содержимому. Он может принимать URI или объект страницы.

- **`BackStack`** и **`ForwardStack`**: Эти геттеры позволяют получить доступ к истории навигации, что позволяет перемещаться назад и вперед между страницами с помощью методов `GoBack` и `GoForward`.

- **`JournalOwnership`**: Определяет, кто управляет журналом навигации. Если установлено в `OwnsJournal`, фрейм будет управлять своим собственным журналом навигации.

- **`NavigationUIVisibility`**: Определяет отображение навигационных кнопок.

Ниже показан код обычного окна, которое упаковывает кое-какое содержимое в элементе `StackPanel` и размещает элемент `Frame` в отдельном столбце:
```xml
<Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition></ColumnDefinition>
            <ColumnDefinition></ColumnDefinition>
        </Grid.ColumnDefinitions>
        <TextBlock TextWrapping="Wrap" Margin="5">
            Данная страница находится в оконном приложении
        </TextBlock>
        <Frame Grid.Column="1" Source="Page1.xaml" Margin="3"
               BorderBrush="LimeGreen" BorderThickness="2"></Frame>
</Grid>
```

На рисунке показан результат. Граница вокруг фрейма (элемента `Frame`) отображает содержимое страницы. Останавливаться на одном фрейме не обязательно. Можно легко создать окно с множеством фреймов и указать им всем на разные страницы.

Как видно на рисунке, в этом примере отсутствуют знакомые кнопки навигации. Дело в том, что для свойства `Frame.NavigationUIVisibility` по умолчанию устанавливается значение `Automatic`. Из-за этого навигационные кнопки появляются только тогда, когда в списке посещений уже присутствуют какие-то страницы. Чтобы проверить это, достаточно перейти на новую страницу, и внутри фрейма тут же появятся эти кнопки.

Если свойство `NavigationUIVisibility` установить в `Hidden`, навигационные кнопки не будут отображаться никогда, а если в `Visible` — то будут отображаться с самого начала.

Наличие навигационных кнопок внутри фрейма является хорошим проектным решением, если во фрейме находится содержимое, отделенное от основного потока приложения (например, он служит для отображения контекстно-зависимой справки или содержания последовательного руководства). Но в других случаях может понадобиться, чтобы они отображались в верхней части окна. Для этого потребуется изменить контейнер наивысшего уровня с `Window` на `NavigationWindow`. В таком случае окно будет включать навигационные кнопки. Находящийся внутри этого окна фрейм автоматически привяжет себя к этим кнопкам.

В окно можно добавлять столько объектов `Frame`, сколько нужно. Например, с помощью трех отдельных фреймов несложно построить окно, которое позволит пользователю просматривать задачи приложения, справочную документацию и внешний веб-сайт.

Свойства `BackStack` и `ForwardStack` класса `Frame` в WPF используются для управления историей навигации. Эти свойства предоставляют доступ к спискам страниц, которые были посещены ранее (`BackStack`) и те, на которые можно перейти вперед (`ForwardStack`).

Пример использования `BackStack` и `ForwardStack`:
```cs
// Получение текущего количества страниц в BackStack
int backStackCount = mainFrame.BackStackDepth;

// Переход назад
if (mainFrame.CanGoBack)
{
    mainFrame.GoBack();
}

// Переход вперед
if (mainFrame.CanGoForward)
{
    mainFrame.GoForward();
}

// Очистка BackStack
while (mainFrame.CanGoBack)
{
    mainFrame.GoBack();
}
```

В этом примере показано, как использовать `BackStack` и `ForwardStack` для навигации между страницами:

1. Получение количества страниц в `BackStack`: Свойство `BackStackDepth` возвращает количество страниц в истории навигации.

2. Переход назад: Метод `GoBack()` позволяет переместиться на предыдущую страницу в истории навигации.

3. Переход вперед: Метод `GoForward()` позволяет переместиться на следующую страницу в истории навигации.

4. Очистка `BackStack`: Если необходимо очистить историю навигации, можно последовательно вызывать `GoBack()`, пока не будет достигнут начало истории.

Хотя свойства `BackStack` и `ForwardStack` доступны только для чтения и не позволяют напрямую изменять списки страниц, вы можете использовать их для отображения истории навигации:
```cs
foreach (var entry in mainFrame.BackStack)
{
    // entry — объект JournalEntry, содержащий информацию о странице
    Console.WriteLine(entry.Source.ToString());
}
```
Этот код выводит URI всех страниц в истории навигации.

Примечания:
- Свойства `BackStack` и `ForwardStack` не позволяют напрямую удалять или изменять записи в истории навигации. Для управления историей можно использовать методы `GoBack()` и `GoForward()`.

- Если необходимо более детально контролировать историю навигации, может потребоваться создать собственный механизм для управления страницами.

##### Размещение страниц внутри другой страницы
Объекты `Frame` дают возможность создавать более сложные композиции окон. Как уже упоминалось в предыдущем разделе, в одном окне можно использовать сразу несколько фреймов (объектов `Frame`). Однако, помимо этого, фрейм также можно размещать внутри другой страницы и тем самым создавать так называемую вложенную страницу. В действительности этот процесс выглядит точно так же — объект `Frame` просто добавляется внутрь разметки страницы.

Вложенные страницы представляют более сложную ситуацию в плане навигации. Например, предположим, что вы посещаете страницу и затем щелкаете на ссылке во вложенном фрейме. Что произойдет, если вы после этого щелкнете на кнопке возврата?

По сути, все страницы во фрейме выстраиваются в один список. Так что при первом щелчке на кнопке возврата вы вернетесь на предыдущую страницу во вставленном фрейме, а если щелкнете на этой кнопке еще раз, то вернетесь на посещенную до этого родительскую страницу.

Такая модель навигации является по большей части достаточно понятной, поскольку предполагает наличие в списке предыдущих страниц по одному элементу для каждой посещенной страницы. Однако бывают случаи, когда вложенный фрейм играет менее важную роль, например, показывает различные представления одних и тех же данных или позволяет просматривать многочисленные страницы справочного содержимого.

В таких случаях проход по всем страницам во вложенном фрейме может показаться неудобным или отнимающим много времени процессом. Может быть решено использовать навигационные элементы для управления навигацией только родительского фрейма, т.е. сделать так, чтобы при щелчке на кнопке возврата пользователь сразу же попадал на предыдущую родительскую страницу. Для получения такого эффекта потребуется установить для свойства **`JournalOwnership`** вложенного фрейма значение `OwnsJournal`. Это заставит фрейм применять собственную, отдельную хронологию страниц, в результате чего он также по умолчанию получит собственные навигационные кнопки, позволяющие перемещаться назад и вперед именно по своему содержимому.

Если эти кнопки не нужны, к свойству `JournalOwnership` можно будет добавить свойство `NavigationUIVisibility` и с его помощью просто скрыть их. После этого вложенный фрейм будет восприниматься просто как фрагмент динамического содержимого внутри страницы. С точки зрения пользователя никаких навигационных возможностей у него не будет.

#### Хронология страниц
Теперь, когда уже известно о страницах и различных способах их размещения, можно переходить к более подробному рассмотрению используемой WPF модели навигации. В этой статье речь пойдет о том, как именно работают гиперссылки WPF и каким образом восстанавливаются страницы, когда пользователь снова к ним возвращается.

Вам наверняка интересно узнать, как в действительности работают свойства вроде `Application.StartupUri`, `Frame.Source` и `Hyperlink.NavigateUri`. В приложении, которое состоит из несвязанных XAML-файлов и выполняется в браузере, этот процесс выглядит довольно просто: при щелчке на гиперссылке браузер интерпретирует ссылку на страницу как относительный URI-адрес и ищет указанную XAML-страницу в текущей папке. Но в скомпилированном приложении страницы перестают быть доступными в виде отдельных ресурсов: они компилируются в **BAML** (**Binary Application Markup Language** — **двоичный язык разметки приложений**) и вставляются в сборку. Так как же на них ссылаться с помощью URI?

Эта система работает благодаря способу, которым WPF обращается к ресурсам приложения. При выполнении щелчка на гиперссылке в скомпилированном XAML-приложении URI все равно интерпретируется как относительный путь. Однако он является относительным по отношению к базовому URI приложения. Поэтому гиперссылка, указывающая на *Page1.xaml*, фактически преобразуется в следующий упакованный URI:
```cs
NavigateUri="pack://application:,,,/Page3.xaml"
```

Может возникнуть вопрос: почему так важно знать, как работают URI-адреса гиперссылок, если весь процесс проходит столь гладко? Главная причина состоит в том, что может потребоваться создать приложение, позволяющее переходить на XAML-страницы, которые хранятся в другой сборке. На самом деле для принятия такого проектного решения имеются веские основания. Поскольку страницы могут применяться в разных контейнерах, может возникнуть желание повторно использовать один и тот же набор страниц как в приложении ХВАР, так и в обычном приложении Windows.

В таком случае можно развернуть просто две версии приложения — браузерную и настольную. Чтобы избежать дублирования кода, все страницы, которые планируется использовать повторно, следует поместить в отдельную сборку библиотеки классов (DLL), на которую затем можно сослаться в обоих проектах приложений.

Это потребует внесения изменения в URI-адреса. При наличии страницы в одной сборке, указывающей на страницу в другой сборке, нужно будет использовать следующий синтаксис:
```xml
pack://application:,,,/PageLibrary;component/Page1.xaml
```

Здесь компонент имеет имя `PageLibrary`, а путь *,,,PageLibrary;component/Page1.xaml* указывает на скомпилированную и вставленную внутри него страницу *Page1.xaml*.

Конечно, абсолютный путь вряд ли будет использоваться. Вместо него гораздо целесообразнее применять в URI-адресах следующий относительный путь:
```cs
/PageLibrary;component/Page1.xaml
```

При создании сборки `SharedLibrary` для получения правильных ссылок на сборки, импортированных пространств имен и настроек приложения лучше использовать шаблон проекта Custom Control Library (WPF) (Библиотека специальных элементов управления (WPF)).

##### Хронология навигации
Хронология страниц в WPF работает точно так же, как и в браузере. При каждом переходе на новую страницу текущая страница добавляется в список предыдущих страниц. При щелчке на кнопке возврата страница добавляется в список следующих страниц. В случае возврата на одну страницу и перехода с нее на новую страницу список следующих страниц очищается.

Поведение списков предыдущих и следующих страниц выглядит довольно просто, но внутренние механизмы, обеспечивающие работу этих списков, являются гораздо более сложными. Например, предположим, что вы посещаете страницу с двумя текстовыми полями, вводите в них что-нибудь и двигаетесь дальше. Если вы после этого вернетесь обратно на эту страницу, то увидите, что WPF восстанавливает состояние текстовых полей, т.е. в них отображается все, что было ранее введено.

Между возвращением на страницу через хронологию навигации и выполнением щелчка на ссылке, которая направляет на эту же самую страницу, существует большая разница. Например, при переходе со страницы *Page1* на страницу *Раgе2* и затем снова на страницу *Page1* с помощью соответствующих ссылок WPF создаст три отдельных объекта страницы. При втором отображении страница *Page1* создастся как отдельный экземпляр с собственным состоянием. Однако в случае возврата к первому экземпляру *Page1* за счет двукратного щелчка на кнопке возврата она будет видна в исходном состоянии.

Может показаться, что WPF поддерживает состояние ранее посещенных страниц за счет удержания объекта страницы в памяти. Проблема такого подхода состоит в том, что связанные с памятью накладные расходы в сложном приложении с множеством страниц в таком случае могут быть слишком большими. По этой причине удержание объекта страницы не считается безопасной стратегией и вместо него при покидании страницы сохраняется информация о состоянии всех элементов управления, а объект страницы уничтожается. При возврате на эту страницу WPF создает ее заново (из исходного XAML-файла) и восстанавливает состояние ее элементов управления.

Такая стратегия сопровождается меньшим количеством накладных расходов, поскольку для сохранения деталей о состоянии элементов управления требуется гораздо меньше памяти, чем для сохранения всей страницы вместе с визуальным деревом объектов.

Глядя на эту систему, возникает интересный вопрос: как WPF решает, какие детали нужно сохранять? WPF анализирует все дерево элементов страницы и просматривает имеющиеся у этих элементов свойства зависимости. Свойства, которые должны быть сохранены, имеют небольшой фрагмент дополнительных метаданных — журнальный флаг, который указывает, что они должны помещаться в журнал навигации. Этот флаг устанавливается с помощью объекта `FrameworkPropertyMetadata` при регистрации свойства зависимости.

Присмотревшись к системе навигации поближе, можно будет заметить, что у многих свойств нет журнального флага. Например, если установить свойство `Content` элемента управления содержимым или свойство `Text` элемента `TextBlock` с помощью кода, ни одна из этих деталей не будет восстановлена при возврате на страницу. То же самое будет и при динамической установке свойства `Foreground` или `Background`. Однако если установить свойство `Text` элемента `TextBox`, свойство `IsSelected` элемента `CheckBox` или свойство `SelectedIndex` элемента `ListBox`, то все эти детали сохранятся.

Так что же можно предпринять, если такое поведение не подходит? Как быть в случае установки множества свойств динамическим образом и желании, чтобы вся эта информация сохранялась на страницах? Существует несколько возможных вариантов.

Самый мощный предполагает применение свойства **`Page.KeepAlive`**, которое по умолчанию имеет значение `false`. Когда это свойство устанавливается в `true`, WPF не применяет описанный выше механизм сериализации. Вместо этого WPF оставляет объекты всех страниц в действующем состоянии. Благодаря этому, при возврате обратно страница оказывается в том же виде, в котором была ранее. Разумеется, у этого варианта есть один недостаток, заключающийся в увеличении накладных расходов, связанных с памятью, поэтому его следует применять только для нескольких страниц, которые действительно в нем нуждаются.

В случае использования свойства `KeepAlive` для сохранения страницы в действующем состоянии, при следующем возврате к ней событие `Initialized` генерироваться не будет. (Для страниц, которые не сохраняются в действующем состоянии, а "возвращаются к жизни" с помощью системы журнализации WPF, такое событие будет инициироваться при каждом их посещении пользователем.) Если такое поведение не подходит, тогда следует обработать события `Unloaded` и `Loaded`, которые генерируются всегда.

Второй вариант — построить другое проектное решение, способное передавать информацию, где это необходимо. Например, можно создать **страничные функции**, предназначенные для возврата информации. Используя страничные функции вместе с дополнительной логикой инициализации, можно разработать собственную систему для извлечения из страницы важной информации и ее сохранения в подходящем месте.

С хронологией навигации WPF связан еще один недостаток. Можно написать код, который будет динамически создавать объект страницы и затем переходить на нее. В такой ситуации обычный механизм сохранения состояния страницы работать не будет. У WPF нет ссылки на XAML-документ страницы, поэтому ей не известно, как реконструировать страницу. (А если страница создается динамически, у нее может вообще не быть соответствующего XAML-документа.) В такой ситуации WPF всегда будет сохранять объект страницы в памяти, каким бы ни было значение свойства `KeepAlive`.

#### Служба навигации
Пока что все рассмотренные возможности навигации подразумевали в основном применение гиперссылок. Когда такой подход работает, он элегантен и прост. Однако в некоторых случаях бывает необходимо иметь больший контроль над процессом навигации. Например, гиперссылки прекрасно подходят, если страницы используются для воспроизведения фиксированной, линейной последовательности шагов, которую пользователь должен проходить от начала до конца (вроде мастера). Однако если нужно, чтобы пользователь выполнял только какие-то небольшие последовательности шагов и возвращался на общую страницу, или же требуется сконфигурировать последовательность шагов на основе каких-нибудь других деталей (например, предыдущих действий пользователя), необходимо нечто большее.

##### Программная навигация
Можно сделать так, чтобы значения свойств `Hyperlink.NavigateUri` и `Frame.Source` устанавливались динамически. Однако самый гибкий и мощный подход предполагает использование службы навигации WPF.

Служба навигации WPF — это ключевая часть инфраструктуры навигации в приложениях WPF. Она позволяет управлять переходами между страницами (`Page`) и отслеживать историю навигации. Основными компонентами службы навигации являются классы `NavigationService`, `Page`, и элементы управления, такие как `Frame` и `NavigationWindow`.

Определение:
```cs
public sealed class NavigationService
```

Описание: https://learn.microsoft.com/en-us/dotnet/api/system.windows.navigation.navigationservice?view=windowsdesktop-9.0

Получать доступ к этой службе навигации можно через контейнер, в котором размещена страница (например, объект `Frame` или `NavigationWindow`), но такой подход ограничивает страницы использованием в контейнере только этого типа. Поэтому лучше всего получать доступ к службе навигации через статический метод **`NavigationService.GetNavigationService()`**. Этому методу передается ссылка на страницу, а он возвращает действующий объект `NavigationService`, который позволяет реализовать навигацию программно:
```cs
NavigationService nav;
nav = NavigationService.GetNavigationService(this);
```

Этот код работает независимо от того, какой контейнер выбран для обслуживания страниц.

Объект `NavigationService` нельзя использовать ни в конструкторе страницы, ни на этапе срабатывания события `Page.Initialized`. Больше всего для этого подходит событие `Page.Loaded`.

В классе `NavigationService` определен набор методов для работы с навигацией. Наиболее часто используется метод `Navigate()`, который позволяет переходить на страницу по ее URI:
```cs
nav.Navigate(new System.Uri("Page1.xaml", UriKind.RelativeOrAbsolute));
```

или за счет создания соответствующего объекта страницы:
```cs
Page1 nextPage = new Page1();
nav.Navigate(nextPage);
```

Пример использования `NavigationService`:
```cs
private void Button_Click(object sender, RoutedEventArgs e)
{
    NavigationService nav = NavigationService.GetNavigationService(this);
    nav.Navigate(new Uri("NextPage.xaml", UriKind.Relative));
}
```

По возможности лучше всегда применять URI, поскольку это позволяет системе журнализации WPF сохранять данные страницы, не удерживая в памяти все дерево ее объектов. Когда методу `Navigate()` передается объект страницы, в памяти сохраняется весь объект.

Однако создание объекта страницы вручную может понадобиться, если в страницу необходимо передать какую-то информацию. Передать эту информацию можно либо с помощью специального конструктора класса страницы (что является наиболее распространенным подходом), либо вызовом специального метода в классе страницы после создания. Если в страницу добавлен новый конструктор, в нем должен обязательно вызываться метод `InitializeComponent()` для обработки кода разметки и создания объектов элементов управления.

Решив использовать программную навигацию, вы сами определяете, что применять: навигационные кнопки, гиперссылки или что-нибудь еще. Как правило, для принятия решения о том, на какую страницу следует переходить, в обработчике событий используется условный код.

Навигация в WPF осуществляется асинхронным образом. Это значит, что запрос на навигацию можно отменять до того, как он будет выполнен, посредством вызова метода **`NavigationService.StopLoading()`**. Вдобавок можно использовать метод `Refresh()` для повторной загрузки страницы.

И, наконец, класс `NavigationService` также предоставляет методы **`GoBack()`** и **`GoForward()`**, которые позволяют перемещаться по спискам предыдущих и следующих страниц. Это удобно в ситуации, когда разработчик создает собственные навигационные элементы управления. Оба эти метода генерируют исключение `InvalidOperationException` при попытке перехода на страницу, которой не существует (например, при попытке вернуться назад, находясь на первой странице). Во избежание таких ошибок перед вызовом соответствующих методов следует проверять значения булевских свойств `CanGoBack` и `CanGoForward`.

Служба навигации WPF обеспечивает гибкий и мощный способ управления переходами между страницами в приложениях WPF, что делает ее ключевым инструментом для создания сложных навигационных систем.

##### События навигации
Класс `NavigationService` также предоставляет полезный набор событий, которые можно использовать для реагирования на навигацию. Эти события позволяют обрабатывать различные этапы навигации и реагировать на ошибки. Наиболее распространенной причиной реагирования на навигацию является необходимость выполнения по ее завершении какой-то задачи. Например, если страница размещается внутри рамки в обычном окне, может понадобиться, чтобы по завершении навигации в окне обновлялся текст строки состояния.

Поскольку навигация осуществляется асинхронным образом, возврат из метода `Navigate()` происходит до появления целевой страницы. В некоторых случаях разница во времени может быть значительной, например, как в случае перехода на несвязанную XAML-страницу, расположенную на веб-сайте (или на XAML-страницу, находящуюся в другой сборке, которая инициирует веб-загрузку), или в случае, когда страница включает длительно выполняющийся код в обработчике событий `Initialized` или `Loaded`.

Процесс навигации в WPF описан ниже:

- Определяется местонахождение страницы.

- Извлекается информация о странице. (Если страница находится на удаленном сайте, тогда она на этом этапе загружается.)

- Устанавливается местонахождение всех необходимых странице и связанных с ней ресурсов (например, изображений) и выполняется их загрузка.

- Осуществляется синтаксический анализ страницы и генерируется дерево ее объектов. На этом этапе страница запускает события `Initialized` (если только она не восстанавливается из журнала) и `Loaded`.

- Страница визуализируется.

- Если URI включает фрагмент, WPF переходит сразу же к этому элементу.

Ниже перечислены события, генерируемые классом `NavigationService` в течение этого процесса. Эти события навигации также предоставляются классом `Application` и навигационными контейнерами (такими как `NavigationWindow` и `Frame`). При наличии более одного навигационного контейнера это дает возможность обрабатывать процесс навигации в разных контейнерах по отдельности. Однако встроенного способа для обработки навигационных событий единственной страницы не существует:

- **`Navigating`**

    Процесс навигации начинается. Это событие можно отменить и тем самым предотвратить выполнение навигации

- **`Navigated`**

    Процесс навигации начался, но целевая страница еще не извлечена

- **`LoadCompleted`**

    Страница прошла синтаксический анализ. Однако события `Initialized` и `Loaded` еще не были сгенерированы

- **`FragmentNavigation`**

    Страница готовится к прокручиванию до целевого элемента. Это событие срабатывает только в случае, если используется URI с информацией о фрагменте

- **`NavigationStopped`**

    Процесс навигации был отменен с помощью метода `StopLoading()`

- **`NavigationFailed`**

    Процесс навигации не удался из-за того, что не получилось обнаружить или загрузить целевую страницу. Это событие можно использовать для нейтрализации исключения до того, как оно появится и превратится в необработанное исключение приложения. Для этого необходимо просто установить `NavigationFailedEventArgs.Handled` в `true`

- **`NavigationProgress`**

    Процесс навигации идет полным ходом, и часть данных страницы уже загружена. Это событие вызывается периодически для предоставления информации о ходе навигации. Оно предоставляет информацию об объеме данных, которые уже загружены (`NavigationProgressEventArgs.BytesRead`), и общем объеме данных, которые требуется загрузить (`NavigationProgressEventArgs.MaxBytes`). Это событие запускается после каждого извлечения данных объемом 1 Кбайт

После присоединения к навигационному контейнеру службы навигации и обработчика событий он продолжает генерировать события при переходе со страницы на страницу (или до тех пор, пока обработчик событий не будет удален). В целом это означает, что навигацию легче всего обрабатывать на уровне приложения.

События навигации нельзя подавлять с помощью свойства `RoutedEventArgs.Handled`. Причина в том, что они являются не маршрутизируемыми, а обычными событиями .NET.

Навигационным событиям можно передавать данные из метода `Navigate()`. Нужно просто использовать ту из перегруженных версий метода `Navigate()`, которая в качестве параметра принимает дополнительный объект. Этот объект сделан доступным в событиях `Navigated`, `NavigationStopped` и `LoadCompleted` через свойство `NavigationEventArgs.ExtraData`. Данное свойство можно использовать, например, для отслеживания времени поступления запроса на навигацию.

#### Управление журналом навигации
Описанные до этого приемы позволяют создать приложение с возможностями линейной навигации и сделать процесс навигации легко адаптируемым (например, применив условную логику, так чтобы пользователи по пути направлялись к разным шагам), но все равно ограничивают базовым подходом, подразумевающим проход от начала до конца. На рисунке показана такая топология навигации, которая является типичной при создании простых мастеров, основанных на описании задач. Пунктирными линиями обозначены интересующие нас шаги — когда пользователь покидает группу страниц, представляющих логическую задачу.

Если попробовать реализовать такое проектное решение с использованием процесса навигации WPF, то обнаружится, что в нем не хватает одной детали. В частности, нужно, чтобы по завершении процесса навигации пользователем (либо из-за отмены им операции на одном из этапов, либо из-за выполнения им задачи вручную) очищался список предыдущих страниц. Если работа приложения сконцентрирована вокруг одного главного окна, которое не основано на процессе навигации, это не проблема.

При запуске пользователем задачи, связанной с переходом на страницу, приложение может просто создать новый объект `NavigationWindow`, который позволяет сделать это. По завершении задачи этот объект может быть уничтожен. Однако если все приложение основано на навигации, тогда ситуация усложняется. В таком случае необходимо придумать способ для очистки списка ранее посещенных страниц при отмене или завершении задачи, чтобы пользователь не мог вернуться назад на один из промежуточных шагов.

К сожалению, в WPF не позволяет получить высокий контроль над процессом навигации. Все, что имеется — это два метода в классе `NavigationService`: **`AddBackEntry()`** и **`RemoveBackEntry()`**. В рассматриваемом примере необходим метод `RemoveBackEntry()`, который берет самый недавний элемент в списке предыдущих страниц и удаляет его.

Кроме того, `RemoveBackEntry()` возвращает объект `JournalEntry`, описывающий этот элемент. Он сообщает URI-адрес (через свойство `Source`) и имя, которое тот имеет в журнале навигации (через свойство `Name`). Не забывайте, что имя устанавливается на основе свойства `Page.Title`.

Если по завершении задачи должно удаляться сразу несколько записей, потребуется вызывать метод `RemoveBackEntry()` несколько раз. Здесь возможны два варианта. При удалении всего списка предыдущих шагов достижение его конца определяется с помощью свойства `CanGoBack`:
```cs
while (nav.CanGoBack)
{
   nav.RemoveBackEntry();
}
```

В качестве альтернативы можно удалять элементы до тех пор, пока не будет удалена начальная точка выполнения задачи. Например, если выполнение задачи начинается на странице `ConfigureAppWizard.xaml`, по его завершении можно использовать такой код:
```cs
string pageName;
while (pageName != "ConfigureAppWizard.xaml")
{
   JournalEntry entry = nav.RemoveBackEntry();
   pageName = System.IO.Path.GetFileName(entry.Source.ToStnng());
}
```

Этот код берет полный URI, который хранится в свойстве `JournalEntry.Source`, и усекает его до имени страницы с помощью статического метода `GetFileName()` класса `Path` (который также эффективно работает и с URI). Использование свойства `Title` сделало бы кодирование более удобным, но не таким надежным. Поскольку заголовок страницы отображается в хронологии навигации и является видимым для пользователя, он представляет собой фрагмент информации, который в случае локализации приложения потребуется переводить на другие языки. А это чревато нарушением кода, который ожидает жестко закодированного заголовка страницы. И даже если приложение не планируется локализовать, нетрудно представить другой сценарий с изменением заголовка страницы, например, для того, чтобы тот был более понятным или более описательным.

Кстати, все элементы в списке предыдущих и следующих страниц можно просматривать с помощью свойств **`BackStack`** и **`ForwardStack`** навигационного контейнера (вроде `NavigationWindow` или `Frame`). Однако получать эту информацию через класс `NavigationService` нельзя. В любом случае эти свойства предоставляют простые и доступные только для чтения объекты `JournalEntry`. Вносить изменения в списки они не позволяют, и поэтому реальная необходимость в них возникает крайне редко.

#### Добавление в журнал специальных элементов
Вместе с методом `RemoveBackEntry()` класс `NavigationService` также предоставляет метод **`AddBackEntry()`**. Этот метод позволяет сохранять в списке предыдущих страниц "виртуальные" записи. Например, предположим, что имеется одна страница, которая позволяет пользователю выполнять довольно сложную задачу по конфигурированию. Если нужно сделать так, чтобы пользователь мог возвращаться к предыдущему состоянию этого окна, его можно сохранить с помощью метода `AddBackEntry()`. Несмотря на то что страница всего одна, она может иметь несколько связанных записей в списке.

Вопреки возможным ожиданиям, при вызове метода `AddBackEntry()` объект `JournalEntry` передавать не требуется. (На самом деле класс `JournalEntry` имеет защищенный конструктор, поэтому создать его экземпляр не получится.) Вместо этого понадобится создать специальный класс, унаследованный от абстрактного класса `System.Windows.Navigation.CustomContentState` и сохраняющий всю необходимую информацию. Например, взгляните на приложение, показанное на рисунке, которое позволяет перемещать элементы из одного списка в другой.

Теперь предположим, что состояние этого окна должно сохраняться при каждом перемещении элемента из одного списка в другой. Первое, что потребуется — это класс, унаследованный от `CustomContentState` и отслеживающий эту необходимую информацию. В данном случае нужно просто записать содержимое обоих списков. Поскольку этот класс будет сохраняться в журнале (для того, чтобы страница могла при необходимости "восстанавливаться"), он должен допускать сериализацию:
```cs
[Serializable()]
    public class ListSelectionJournalEntry : CustomContentState
    {
        private List<String> sourceItems;
        public List<String> SourceItems
        {
            get { return sourceItems; }
        }

        private List<String> targetItems;
        public List<String> TargetItems
        {
            get { return targetItems; }
        }
        ...
}
```

Это дает хорошее начало, но все равно еще нужно много чего сделать. Например, вряд ли захочется, чтобы страница появлялась в хронологии навигации с одним и тем же заголовком множество раз. Потребуется использовать какое-то более описательное имя. Для этого придется переопределить свойство **`JournalEntryName`**.

В данном примере никакого очевидного и логичного способа для описания состояния обоих списков нет. Поэтому имеет смысл позволить странице самой выбирать имя при сохранении записи в журнале. В таком случае страница сможет добавлять описательное имя на основе самого последнего действия (вроде Added Blue или Removed Yellow). Для реализации такого проектного решения необходимо сделать свойство `JournalEntryName` зависимым от переменной, установить которую можно непосредственно в конструкторе:
```cs
private string _journalName;
public override string JournalEntryName
{
    get
    {
         return _journalName;
    }
}
```

Система навигации WPF будет обращаться к свойству `JournalEntryName` для получения имени, которое должно быть показано в списке.

Следующий шаг состоит в переопределении метода **`Replay()`**. WPF вызывает этот метод, когда пользователь переходит к записи в списке предыдущих или следующих страниц, позволяя применять предыдущее сохраненное состояние.

Существуют два подхода, которые можно использовать в методе `Replay()`. Первый — извлечь ссылку на текущую страницу с помощью свойства `NavigationService.Content`, а затем привести эту страницу к типу соответствующего класса страницы и вызвать любой требуемый для реализации задуманного изменения метод. Второй подход (который иллюстрируются здесь) — полагаться на обратный вызов:
```cs
public delegate void ReplayListChange(ListSelectionJournalEntry state);

private ReplayListChange replayListChange;

public override void Replay(NavigationService navigationService, NavigationMode mode)
{
     this.replayListChange(this);
}

public ListSelectionJournalEntry(List<String> sourceItems, List<String> targetItems,
     string journalName, ReplayListChange replayListChange)
{
     this.sourceItems = sourceItems;
     this.targetItems = targetItems;
     this._journalName = journalName;
}
```

Чтобы добавить эту функциональность к странице, потребуется выполнить три описанных ниже шага:

- Вызвать в подходящее время метод `AddBackReference()` для сохранения в хронологии навигации дополнительной записи.

- Обработать обратный вызов `ListSelectionJournalEntry` для восстановления окна при проходе пользователя по хронологии.

- Реализовать в своем классе страницы интерфейс **`IProvideCustomContentState`** и его единственный метод `GetContentState()`. При переходе пользователя на другую страницу в хронологии метод `GetContentState()` вызывается службой навигации. Это позволяет вернуть экземпляр специального класса, который будет храниться как состояние текущей страницы.

Интерфейс `IProvideCustomContentState` является часто пропускаемой, но очень существенной деталью. Когда пользователь выполняет навигацию с помощью списка следующих или предыдущих страниц, должны происходить две вещи: страница должна добавить текущее представление в журнал (с помощью `IProvideCustomContentState`), а затем восстановить выбранное представление (с помощью обратного вызова `ListSelectionJournalEntry`).

Для начала при каждом щелчке на кнопке *Add* (*Добавить*) нужно создать новый объект `ListSelectionJournalEntry` и вызвать метод `AddBackReference()`, чтобы предыдущее состояние сохранилось в хронологии. Этот процесс выносится в отдельный метод для того, чтобы его можно было использовать в нескольких местах на странице (например, при щелчке на кнопке *Add* (*Добавить*) или *Remove* (*Удалить*)):
```cs
private void btn_Add_Click(object sender, RoutedEventArgs e)
{
    if (one_lbx.SelectedIndex != -1)
    {
        // Определяем подходящее имя для использования в хронологии навигации
        NavigationService nav = NavigationService.GetNavigationService(this);
        string itemText = one_lbx.SelectedItem.ToString();
        string journalName = "Added" + itemText;

        // Обновляем журнал
        nav.AddBackEntry(GetJournalEntry(journalName));

        one_lbx.Items.Add(itemText);
        two_lbx.Items.Remove(itemText);
    }
}
private ListSelectionJournalEntry GetJournalEntry(string journalName)
{
    List<String> source = GetListState(lstSource);
    List<String> target = GetListState(lstTarget);

    return new ListSelectionJournalEntry(
        source, target, journalName, Replay);
}
```
